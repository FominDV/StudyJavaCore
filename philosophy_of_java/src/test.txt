Привет! Сегодня продолжаем говорить о многопоточности. Рассмотрим класс Thread и работу его нескольких методов. Раньше, когда мы изучали методы класса, чаще всего просто писали это так: «название метода» -> «что он делает».
Многопоточность: что делают методы класса Thread - 1
С методами Thread так не получится :) Их логика сложнее, и без нескольких примеров не разобраться.

Метод Thread.start()
Начнем с повторения. Как ты наверняка помнишь, создать поток можно унаследовав свой класс от класса Thread и переопределив в нем метод run().
в
Но сам он, конечно, не запустится. Для этого у нашего объекта вызываем метод start().
Многопоточность: что делают методы класса Thread - 2Давай вспомним пример из предыдущей лекции:

public class MyFirstThread extends Thread {
<!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1" name=viewport> <meta content=#333333 name=theme-color> <link href=https://www.googletagmanager.com rel=preconnect> <link href=https://www.google-analytics.com rel=preconnect> <base href="/"> <link href=/sapper/assets/global.min.css rel=stylesheet> <link href=/sapper/assets/favicon/apple-icon-57x57.png rel=apple-touch-icon sizes=57x57> <link href=/sapper/assets/favicon/apple-icon-60x60.png rel=apple-touch-icon sizes=60x60> <link href=/sapper/assets/favicon/apple-icon-72x72.png rel=apple-touch-icon sizes=72x72> <link href=/sapper/assets/favicon/apple-icon-76x76.png rel=apple-touch-icon sizes=76x76> <link href=/sapper/assets/favicon/apple-icon-114x114.png rel=apple-touch-icon sizes=114x114> <link href=/sapper/assets/favicon/apple-icon-120x120.png rel=apple-touch-icon sizes=120x120> <link href=/sapper/assets/favicon/apple-icon-144x144.png rel=apple-touch-icon sizes=144x144> <link href=/sapper/assets/favicon/apple-icon-152x152.png rel=apple-touch-icon sizes=152x152> <link href=/sapper/assets/favicon/apple-icon-180x180.png rel=apple-touch-icon sizes=180x180> <link href=/sapper/assets/favicon/android-icon-192x192.png rel=icon sizes=192x192 type=image/png> <link href=/sapper/assets/favicon/favicon-32x32.png rel=icon sizes=32x32 type=image/png> <link href=/sapper/assets/favicon/favicon-96x96.png rel=icon sizes=96x96 type=image/png> <link href=/sapper/assets/favicon/favicon-16x16.png rel=icon sizes=16x16 type=image/png> <script>__SAPPER__={baseUrl:"",preloaded:[(function(a,b){return {me:{id:2496069,key:"anonymous#2496070",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2496069\u002Foriginal.jpeg",displayName:"Fomin Dmitriy",prefferedLanguage:"RU",level:17,sublevel:9,blackMatter:608,rating:144,country:a,city:"Москва",isMailSet:b,isPasswordSet:b,email:"necronaft@mail.ru",phone:a,statusCode:"active",statusMessage:a,premiumStatus:"PREMIUM",roleStatus:"USER",userFeatures:["QUEST_JAVA_SYNTAX","QUEST_JAVA_SYNTAX_LOW","QUEST_JAVA_SYNTAX_HEIGHT","QUEST_JAVA_CORE","QUEST_JAVA_MULTITHREADING","QUEST_JAVA_COLLECTIONS","QUEST_GAMES","TASK_VALIDATION_INFO","TASK_VALIDATION_RECOMMENDATION_INFO","TASK_EXECUTION_INFO","TASK_COMPILATION_INFO","BONUS_TASKS","PRIORITY_VERIFICATION","FORUM_INVITATION","SMART_WEB_EDITOR","TASK_SAVING","QUEST_TUTORIAL"]},sideBarMode:"FULL",currentPath:"groups\u002Fposts\u002F1993-mnogopotochnostjh-chto-delajut-metodih-klassa-thread",isSaleActive:false}}(null,true)),null,null,(function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,_,$,aa,ab,ac,ad,ae,af,ag,ah,ai,aj,ak,al,am,an,ao,ap,aq,ar,as,at,au,av,aw,ax,ay,az,aA,aB,aC,aD,aE,aF,aG,aH,aI,aJ,aK,aL,aM,aN,aO,aP,aQ){return {me:{id:2496069,key:"anonymous#2496070",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2496069\u002Foriginal.jpeg",displayName:"Fomin Dmitriy",prefferedLanguage:"RU",level:o,sublevel:9,blackMatter:608,rating:144,country:a,city:p,isMailSet:ac,isPasswordSet:ac,email:"necronaft@mail.ru",phone:a,statusCode:"active",statusMessage:a,premiumStatus:"PREMIUM",roleStatus:"USER",userFeatures:["QUEST_JAVA_SYNTAX","QUEST_JAVA_SYNTAX_LOW","QUEST_JAVA_SYNTAX_HEIGHT","QUEST_JAVA_CORE","QUEST_JAVA_MULTITHREADING","QUEST_JAVA_COLLECTIONS","QUEST_GAMES","TASK_VALIDATION_INFO","TASK_VALIDATION_RECOMMENDATION_INFO","TASK_EXECUTION_INFO","TASK_COMPILATION_INFO","BONUS_TASKS","PRIORITY_VERIFICATION","FORUM_INVITATION","SMART_WEB_EDITOR","TASK_SAVING","QUEST_TUTORIAL"]},post:{id:1993,key:"1993-mnogopotochnostjh-chto-delajut-metodih-klassa-thread",title:R,description:"Привет! Сегодня продолжаем говорить о многопоточности. Рассмотрим класс Thread и работу его нескольких методов. Раньше, когда мы изучали методы класса, чаще всего просто писали это так: «название метода» -&gt; «что он делает». С методами Thread так не получится :) ...",content:"Привет! Сегодня продолжаем говорить о многопоточности. Рассмотрим класс Thread и работу его нескольких методов. Раньше, когда мы изучали методы класса, чаще всего просто писали это так: «название метода» -\u003E «что он делает».\n\u003Cdiv class='row justify-content-center jr-image-wrap'\u003E\u003Cdiv class='col-12 col-sm-10 col-md-8'\u003E\u003Cimg data-id=\"a721b583-c502-4047-b2d9-a49895b5a89a\" data-max-width=\"710\" alt=\"Многопоточность: что делают методы класса Thread - 1\" data-src=\"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Farticle\u002Fa721b583-c502-4047-b2d9-a49895b5a89a\u002F1024.jpeg\"\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003EС методами Thread так не получится :) Их логика сложнее, и без нескольких примеров не разобраться. \n\n\u003Ch2\u003EМетод Thread.start()\u003C\u002Fh2\u003EНачнем с повторения. Как ты наверняка помнишь, создать поток можно унаследовав свой класс от класса \u003Ccode\u003EThread\u003C\u002Fcode\u003E и переопределив в нем метод \u003Ccode\u003Erun()\u003C\u002Fcode\u003E.\n\nНо сам он, конечно, не запустится. Для этого у нашего объекта вызываем метод \u003Ccode\u003Estart()\u003C\u002Fcode\u003E.\n\u003Cimg data-id=\"b9b6e5a5-b771-4c79-8122-2e453ab57ace\" data-max-width=\"850\" alt=\"Многопоточность: что делают методы класса Thread - 2\" data-src=\"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Farticle\u002Fb9b6e5a5-b771-4c79-8122-2e453ab57ace\u002F1024.jpeg\"\u003EДавай вспомним пример из предыдущей лекции:\n\n\u003Cpre class='lang-java line-numbers'\u003E\u003Ccode\u003E\npublic class MyFirstThread extends Thread {\n\n   @Override\n   public void run() {\n       System.out.println(\"Выполнен поток \" + getName());\n   }\n}\n\n\npublic class Main {\n\n   public static void main(String[] args) {\n\n       for (int i = 0; i \u003C 10; i++) {\n           MyFirstThread thread = new MyFirstThread();\n           thread.start();\n       }\n   }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cem\u003E\u003Cstrong\u003EОбрати внимание:\u003C\u002Fstrong\u003E\u003C\u002Fem\u003E чтобы запустить поток, необходимо вызвать специальный метод \u003Ccode\u003Estart()\u003C\u002Fcode\u003E, а не метод \u003Ccode\u003Erun()\u003C\u002Fcode\u003E! Эту ошибку легко допустить, особенно в начале изучения многопоточности. \n\nЕсли в нашем примере ты 10 раз вызовешь у объекта метод \u003Ccode\u003Erun()\u003C\u002Fcode\u003E вместо \u003Ccode\u003Estart()\u003C\u002Fcode\u003E, результат будет таким:\n\n\u003Cpre class='lang-java line-numbers'\u003E\u003Ccode\u003E\npublic class Main {\n\n   public static void main(String[] args) {\n\n       for (int i = 0; i \u003C 10; i++) {\n           MyFirstThread thread = new MyFirstThread();\n           thread.run();\n       }\n   }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\n\u003Cem\u003E\u003Cstrong\u003EВыполнен поток Thread-0\nВыполнен поток Thread-1\nВыполнен поток Thread-2\nВыполнен поток Thread-3\nВыполнен поток Thread-4\nВыполнен поток Thread-5\nВыполнен поток Thread-6\nВыполнен поток Thread-7\nВыполнен поток Thread-8\nВыполнен поток Thread-9\u003C\u002Fstrong\u003E\u003C\u002Fem\u003E\n\nПосмотри на последовательность вывода: все идет строго по порядку. Странно, да? Мы к такому не привыкли, ведь уже знаем, что порядок запуска и выполнения потоков определяет сверхразум внутри нашей операционной системы — планировщик потоков. Может, просто повезло?\n\nКонечно, дело не в везении. В этом можешь убедиться, запустив программу еще пару раз.\n\nДело в том, что прямой вызов метода \u003Ccode\u003Erun()\u003C\u002Fcode\u003E не имеет отношения к многопоточности. В этом случае программа будет выполнена в главном потоке — том, в котором выполняется метод \u003Ccode\u003Emain()\u003C\u002Fcode\u003E. Он просто последовательно выведет 10 строк на консоль и все. Никакие 10 потоков не запустятся. \n\nПоэтому запомни на будущее и постоянно себя проверяй. Хочешь, чтобы выполнился \u003Ccode\u003Erun()\u003C\u002Fcode\u003E, вызывай \u003Ccode\u003Estart()\u003C\u002Fcode\u003E. Поехали дальше.\n\n\u003Ch2\u003EМетод Thread.sleep()\u003C\u002Fh2\u003EДля приостановки выполнения текущего потока на какое-то время, используем метод \u003Ccode\u003Esleep()\u003C\u002Fcode\u003E.\n\u003Cimg data-id=\"1e9f01d2-6dba-4189-9bf6-121c25c29110\" data-max-width=\"850\" alt=\"Многопоточность: что делают методы класса Thread - 3\" data-src=\"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Farticle\u002F1e9f01d2-6dba-4189-9bf6-121c25c29110\u002F1024.jpeg\"\u003EМетод \u003Ccode\u003Esleep()\u003C\u002Fcode\u003E принимает в качестве параметра число миллисекунд, то есть то время, на которое необходимо «усыпить» поток.\n\n\u003Cpre class='lang-java line-numbers'\u003E\u003Ccode\u003E\npublic class Main {\n\n   public static void main(String[] args) throws InterruptedException {\n\n       long start = System.currentTimeMillis();\n\n       Thread.sleep(3000);\n\n       System.out.println(\" - Сколько я проспал? \\n - \" + ((System.currentTimeMillis()-start)) \u002F 1000 + \" секунды\");\n\n   }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cstrong\u003EВывод в консоль:\n\n\u003Cem\u003E - Сколько я проспал? \n - 3 секунды\u003C\u002Fem\u003E\u003C\u002Fstrong\u003E\n\nОбрати внимание: метод \u003Ccode\u003Esleep()\u003C\u002Fcode\u003E — статический: он усыпляет текущий поток. То есть тот, который работает в данный момент.\n\nЕще один важный нюанс: поток в состоянии сна можно прервать. В таком случае в программе возникнет исключение \u003Ccode\u003EInterruptedException\u003C\u002Fcode\u003E. Мы рассмотрим пример ниже.\n\nКстати, а что произойдет после того, как поток «проснется»? Продолжит ли он сразу же свое выполнение с того места, где закончил? Нет.\n\nПосле того, как поток «просыпается» — когда заканчивается время, переданное в качестве аргумента в \u003Ccode\u003EThread.sleep()\u003C\u002Fcode\u003E, — он переходит в состояние \u003Cem\u003Erunnable\u003C\u002Fem\u003E, «работоспособный». Однако это не значит, что планировщик потоков запустит именно его. Вполне возможно, он отдаст предпочтение какому-то другому «неспящему» потоку, а наш «свежепроснувшийся» продолжит работу чуть позже.\n\nОбязательно запомни: «проснулся — не значит продолжил работать в ту же секунду»!\n\n\u003Ch2\u003EМетод Thread.join()\u003C\u002Fh2\u003E\u003Cimg data-id=\"c3c0548b-4341-4b3f-a577-44ba15c84b23\" data-max-width=\"850\" alt=\"Многопоточность: что делают методы класса Thread - 4\" data-src=\"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Farticle\u002Fc3c0548b-4341-4b3f-a577-44ba15c84b23\u002F1024.jpeg\"\u003EМетод \u003Ccode\u003Ejoin()\u003C\u002Fcode\u003E приостанавливает выполнение текущего потока до тех пор, пока не завершится другой поток.\n\nЕсли у нас есть 2 потока, \u003Ccode\u003Et1\u003C\u002Fcode\u003E и \u003Ccode\u003Et2\u003C\u002Fcode\u003E, и мы напишем —\n\n\u003Cpre class='lang-java line-numbers'\u003E\u003Ccode\u003E\nt1.join()\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ccode\u003Et2\u003C\u002Fcode\u003E не начнет работу, пока t1 не завершит свою. Метод \u003Ccode\u003Ejoin()\u003C\u002Fcode\u003E можно использовать, чтобы гарантировать последовательность выполнения потоков. \n\nДавай рассмотрим работу \u003Ccode\u003Ejoin()\u003C\u002Fcode\u003E на примере:\n\n\u003Cpre class='lang-java line-numbers'\u003E\u003Ccode\u003E\npublic class ThreadExample extends Thread {\n\n   @Override\n   public void run() {\n\n       System.out.println(\"Начало работы потока \" + getName());\n\n       try {\n           Thread.sleep(5000);\n       } catch (InterruptedException e) {\n           e.printStackTrace();\n       }\n       System.out.println(\"Поток \" + getName() +  \" завершил работу.\");\n   }\n}\n\n\npublic class Main {\n\n   public static void main(String[] args) throws InterruptedException {\n\n       ThreadExample t1 = new ThreadExample();\n       ThreadExample t2 = new ThreadExample();\n\n       t1.start();\n\n      \n \u002F*Второй поток t2 начнет выполнение только после того, как будет завершен\n       (или бросит исключение) первый поток - t1*\u002F\n       try {\n           t1.join();\n       } catch (InterruptedException e) {\n           e.printStackTrace();\n       }\n\n       t2.start();\n\n       \u002F\u002FГлавный поток продолжит работу только после того, как t1 и t2 завершат работу\n       try {\n           t1.join();\n           t2.join();\n       } catch (InterruptedException e) {\n           e.printStackTrace();\n       }\n\n       System.out.println(\"Все потоки закончили работу, программа завершена\");\n\n   }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\nМы создали простой класс \u003Ccode\u003EThreadExample\u003C\u002Fcode\u003E. Его задача — вывести на экран сообщение о начале работы, потом уснуть на 5 секунд и в конце сообщить о завершении работы. Ничего сложного.\n\nГлавная логика заключена в классе \u003Ccode\u003EMain\u003C\u002Fcode\u003E. Посмотри на комментарии: с помощью метода \u003Ccode\u003Ejoin()\u003C\u002Fcode\u003E мы успешно управляем последовательностью выполнения потоков. Если ты вспомнишь начало темы, этим занимался планировщик потоков. Он запускал их на свое усмотрение: каждый раз по-разному. \n\nЗдесь же мы с помощью метода гарантировали, что сначала будет запущен и выполнен поток \u003Ccode\u003Et1\u003C\u002Fcode\u003E, затем — \u003Ccode\u003Et2\u003C\u002Fcode\u003E, и только после них — главный поток выполнения программы.  \n\nИдем дальше.\n\nВ реальных программах тебе не раз встретятся ситуации, когда необходимо будет прервать выполнение какого-то потока.\n\nНапример, наш поток выполняется, но при этом ждет определенного события или выполнения условия. Если это произошло, он останавливается. Было бы, наверное, логично, если бы существовал какой-то метод типа \u003Ccode\u003Estop()\u003C\u002Fcode\u003E.\n\nОднако все не так просто. Когда-то давно метод \u003Ccode\u003E\u003Cstrong\u003EThread.stop()\u003C\u002Fstrong\u003E\u003C\u002Fcode\u003E в Java действительно был и позволял прерывать работу потока. Но позже его удалили из библиотеки Java. Ты можешь найти его в документации Oracle и увидеть, что он помечен как \u003Cem\u003Edeprecated\u003C\u002Fem\u003E.\n\nПочему? Потому что он просто останавливал поток без какой-либо дополнительной работы. \n\nНапример, поток мог работать с данными и что-то в них менять. Потом его резко вырубали методом \u003Ccode\u003Estop()\u003C\u002Fcode\u003E посреди работы — и все. Ни корректного завершения работы, ни освобождения ресурсов, ни хотя бы обработки ошибок — ничего этого не было.\n\nМетод \u003Ccode\u003Estop()\u003C\u002Fcode\u003E, если утрировать, просто крушил все на своем пути.\n\nЕго работу можно сравнить с тем, как кто-то выдергивает вилку из розетки, чтобы выключить компьютер. Да, нужного результата добиться можно. Но все понимают, что через пару недель компьютер не скажет за это «спасибо».\n\nПо этой причине логику прерывания потоков в Java изменили, и теперь используется специальный метод — \u003Ccode\u003Einterrupt()\u003C\u002Fcode\u003E.\n\n\u003Ch2\u003EМетод Thread.interrupt()\u003C\u002Fh2\u003EЧто произойдет, если у потока вызвать \u003Cstrong\u003Eметод\u003C\u002Fstrong\u003E \u003Ccode\u003E\u003Cstrong\u003Einterrupt()\u003C\u002Fstrong\u003E\u003C\u002Fcode\u003E?\n\nЕсть 2 варианта:\n\n\u003Col\u003E\n\u003Cli\u003EЕсли объект находился в этот момент в состоянии ожидания, например, \u003Ccode\u003Ejoin\u003C\u002Fcode\u003E или \u003Ccode\u003Esleep\u003C\u002Fcode\u003E, ожидание будет прервано, и программа выбросит \u003Ccode\u003EInterruptedException\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\n\u003Cli\u003EЕсли же поток в этот момент был в работоспособном состоянии, у объекта будет установлен boolean-флаг \u003Ccode\u003E\u003Cstrong\u003Einterrupted\u003C\u002Fstrong\u003E\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\u003C\u002Fol\u003E\nНо проверить объект на значение этого флага и корректно завершить работу мы должны будем самостоятельно! Для этого в классе \u003Ccode\u003EThread\u003C\u002Fcode\u003E есть специальный метод — \u003Ccode\u003E\u003Cstrong\u003Eboolean isInterrupted()\u003C\u002Fstrong\u003E\u003C\u002Fcode\u003E.\n\nДавай вернемся к примеру с часами, который был в лекции основного курса. Для удобства он немного упрощен:\n\n\u003Cpre class='lang-java line-numbers'\u003E\u003Ccode\u003E\npublic class Clock extends Thread {\n\n   public static void main(String[] args) throws InterruptedException {\n       Clock clock = new Clock();\n       clock.start();\n\n       Thread.sleep(10000);\n       clock.interrupt();\n   }\n\n   public void run() {\n       Thread current = Thread.currentThread();\n\n       while (!current.isInterrupted())\n       {\n           try {\n               Thread.sleep(1000);\n           } catch (InterruptedException e) {\n               System.out.println(\"Работа потока была прервана\");\n               break;\n           }\n           System.out.println(\"Tik\");\n       }\n   }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\nВ нашем случае часы стартуют и начинают тикать каждую секунду. На 10-й секунде мы прерываем поток часов.\n\nКак ты уже знаешь, если поток, который мы пытаемся прервать, находится в одном из состояний ожидания, это приводит к \u003Ccode\u003EInterruptedException\u003C\u002Fcode\u003E. Данный вид исключения — проверяемый, поэтому его можно легко перехватить и выполнить нашу логику завершения программы. Что мы и сделали.\n\n\u003Cstrong\u003EВот наш результат:\u003C\u002Fstrong\u003E\n\n\u003Cem\u003E\u003Cstrong\u003ETik\nTik\nTik\nTik\nTik\nTik\nTik\nTik\nTik\u003C\u002Fstrong\u003E\u003C\u002Fem\u003E\n\nРабота потока была прервана\n\nНа этом мы заканчиваем знакомство с основными методами класса \u003Ccode\u003EThread\u003C\u002Fcode\u003E.\n\nЧтобы закрепить знания, можешь посмотреть эту видеолекцию о многопоточности: \n\u003Cdiv class=\"row\"\u003E\n\u003Cdiv class=\"col col-md-10 col-lg-8\"\u003E\n\u003Cdiv class=\"embed-responsive embed-responsive-16by9\"\u003E\n\u003Ciframe width=\"560\" height=\"315\" src=\"https:\u002F\u002Fwww.youtube.com\u002Fembed\u002FzxZ0BXlTys0\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen\u003E\u003C\u002Fiframe\u003E\n\u003C\u002Fdiv\u003E\n\u003C\u002Fdiv\u003E\n\u003C\u002Fdiv\u003Eона послужит отличным дополнительным материалом! В конце, после обзора методов, в ней рассказывается как раз о том, что мы будем проходить дальше по курсу :)\n\nУспехов!",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Farticle\u002Fa11feba5-e610-4125-bce8-a8e73bc30eb6\u002Foriginal.jpeg",type:"USUAL",views:47142,commentsCount:ad,createdTime:1538066518000,updatedTime:1542273830593,rating:4.978201634877384,ratingCount:367,originalGroupInfo:{id:S,key:"java-developer",type:"TECH",title:"Java Developer",description:"Мы все тут очень любим Java! Уверены, ты тоже полюбишь, когда углубишься в самые дебри и познаешь истинные возможности этого языка! Присоединяйся! В нашей группе — статьи и новости о Java, информация о работе Java-программистом, общение, обсуждение вопросов и многое другое.",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Fsystem\u002F243fcb29-d895-4f94-b537-b4c08d29d6ce\u002Foriginal.jpeg",avatarUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Fsystem\u002F7bfe9928-c13b-4658-8cce-ab42a8907ea4\u002Foriginal.jpeg",usersCount:28028,meGroupInfo:a,levelToEditor:ae,visibilityStatus:c,userDiscussionInfo:a,commentsCount:a},groupInfo:a,authorInfo:{id:af,userId:af,key:"anonymous#1770672",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F1770672\u002Foriginal.png",displayName:"Professor Hans Noodles",position:a,job:a,country:a,city:a,level:41,rating:11,publicStatus:"HAVE_JOB",publicStatusMessage:a},likesInfo:{count:410,status:a},visibilityStatus:c,userDiscussionInfo:a},comments:[{id:ag,time:1608667685026,message:"Прошу прощения но в следующем предложении, кажется содержится ошибка - \"Метод join() приостанавливает выполнение текущего потока до тех пор, пока не завершится другой поток.\"",owner:{id:F,userId:F,key:ah,pictureUrl:m,displayName:ai,position:a,job:a,country:d,city:d,level:k,rating:aj,publicStatus:i,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:a,status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:a,childrenComments:[{id:647981,time:1609249119870,message:"А в чём ошибка? \nТы в первом потоке прописываешь join() с указанием второго потока. И пока второй поток не завершится - первый ждёт, т.е. не будет идти дальше по коду.",owner:{id:ak,userId:ak,key:"anonymous#2444882",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Fanonymous.svg?1604407903641",displayName:"Veygard",position:a,job:a,country:d,city:p,level:S,rating:323,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:F,userId:F,key:ah,pictureUrl:m,displayName:ai,position:a,job:a,country:d,city:d,level:k,rating:aj,publicStatus:i,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:ag,childrenComments:a,likes:{count:h,status:a}}],likes:{count:h,status:a}},{id:634544,time:1607366363821,message:"По-моему это лишнее\n   Thread current = Thread.currentThread();\n\nМожно просто написать :\n\n    public void run() {\n        while (!isInterrupted())\n        {\n     \u002F\u002F\u002Fкод\n        }\n    }\n\n",owner:{id:al,userId:al,key:"anonymous#2181104",pictureUrl:m,displayName:"Игорь",position:a,job:a,country:a,city:am,level:26,rating:259,publicStatus:i,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:a,status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:a,childrenComments:[],likes:{count:h,status:a}},{id:634375,time:1607352553780,message:"фух.... насколько же мне проще читать текст, чем слушать лектора....  хотя он и шире излагает, но это прям на морально волевых... ",owner:{id:an,userId:an,key:"anonymous#2275993",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2275993\u002Foriginal.jpeg",displayName:"Максим Дудин",position:a,job:a,country:a,city:"Калининград",level:S,rating:487,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:a,status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:a,childrenComments:[],likes:{count:h,status:a}},{id:ao,time:1606152307397,message:"\"Но проверить объект на значение этого флага и корректно завершить работу мы должны будем самостоятельно!\"\n\nтак как же завершить поток?",owner:{id:G,userId:G,key:ap,pictureUrl:m,displayName:aq,position:a,job:a,country:d,city:ar,level:C,rating:as,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:a,status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:a,childrenComments:[{id:625290,time:1606153232278,message:"Нужно, чтобы метод run полностью выполнился:\n\u003Cpre class=\"language-java line-numbers\"\u003E\u003Ccode\u003E\npublic void run() {\n       Thread current = Thread.currentThread();\n\n       while (!current.isInterrupted())\n       {\n           try {\n               Thread.sleep(1000);\n           } catch (InterruptedException e) {\n               System.out.println(\"Работа потока была прервана\");\n               break;\n           }\n           System.out.println(\"Tik\");\n       }\n   }\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\nВ этом примере программа находится в постоянном цикле, пока значение флага false. Как только он становится true, цикл while завершается, далее в коде больше нет команд, так что и метод run() тоже завершается, ну а вместе с ним и поток.",owner:{id:at,userId:at,key:"anonymous#2328485",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2328484\u002Foriginal.jpeg",displayName:"Гордей",position:a,job:a,country:a,city:a,level:27,rating:483,publicStatus:i,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:G,userId:G,key:ap,pictureUrl:m,displayName:aq,position:a,job:a,country:d,city:ar,level:C,rating:as,publicStatus:f,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:ao,childrenComments:a,likes:{count:h,status:a}}],likes:{count:h,status:a}},{id:H,time:1604054471820,message:"Заинтересовала разница между volatile и synchronized.\nНасколько я понял для себя - основное отличие это, то что volatile применяется только для полей(fields), а synchronized применяется для классов, экземпляров и блоков кода{}. Смысл же один - обеспечить одномоментный доступ к ресурсу.\n\nТолько вот понятно, что synchronized захватывает флаг(?) monitor. А вот механизм работы volatile не понятен мне пока. Иду гуглить)\n\nПоправьте, если где ошибся.",owner:{id:q,userId:q,key:I,pictureUrl:J,displayName:K,position:d,job:a,country:g,city:L,level:r,rating:M,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:a,status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:a,childrenComments:[{id:624109,time:1605972563249,message:"Насколько я знаю volatile используется в том случае, если только 1 поток записывает данные в переменную,в то время как остальные считывают их оттуда.Volatile используется для запрета кеширования этой переменной.Поправь если не так.",owner:{id:D,userId:D,key:T,pictureUrl:U,displayName:V,position:d,job:d,country:g,city:p,level:C,rating:W,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:q,userId:q,key:I,pictureUrl:J,displayName:K,position:d,job:a,country:g,city:L,level:r,rating:M,publicStatus:f,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:H,childrenComments:a,likes:{count:h,status:a}},{id:625105,time:1606137159877,message:"Похоже, что именно так всё и устроено.\n\u003Ca href=\"https:\u002F\u002Furvanov.ru\u002F2017\u002F07\u002F20\u002F%D0%B7%D0%B0%D1%87%D0%B5%D0%BC-%D0%BD%D1%83%D0%B6%D0%BD%D0%BE-volatile-%D0%B2-java\u002F\" target=\"_blank\" rel=\"nofollow\"\u003EСтатейка на тему\u003C\u002Fa\u003E",owner:{id:q,userId:q,key:I,pictureUrl:J,displayName:K,position:d,job:a,country:g,city:L,level:r,rating:M,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:D,userId:D,key:T,pictureUrl:U,displayName:V,position:d,job:d,country:g,city:p,level:C,rating:W,publicStatus:f,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:H,childrenComments:a,likes:{count:h,status:a}},{id:625377,time:1606159804782,message:"спасибо за статью",owner:{id:D,userId:D,key:T,pictureUrl:U,displayName:V,position:d,job:d,country:g,city:p,level:C,rating:W,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:q,userId:q,key:I,pictureUrl:J,displayName:K,position:d,job:a,country:g,city:L,level:r,rating:M,publicStatus:f,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:H,childrenComments:a,likes:{count:h,status:a}}],likes:{count:h,status:a}},{id:X,time:1602870715931,message:"В одних примерах метод прерывается командой break; в других return;\nЕсть между ними разница?",owner:{id:E,userId:E,key:Y,pictureUrl:Z,displayName:_,position:a,job:a,country:d,city:$,level:r,rating:aa,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:a,status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:a,childrenComments:[{id:603471,time:1603068308986,message:"Команда break прерывает работу \u003Cstrong\u003Eцикла\u003C\u002Fstrong\u003E, а return прерывает работу \u003Cstrong\u003Eметода\u003C\u002Fstrong\u003E",owner:{id:au,userId:au,key:"anonymous#2399651",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2399651\u002Foriginal.jpeg",displayName:"Merch",position:"Студент",job:"uio",country:"Узбекистан",city:"Ташкент",level:k,rating:423,publicStatus:i,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:E,userId:E,key:Y,pictureUrl:Z,displayName:_,position:a,job:a,country:d,city:$,level:r,rating:aa,publicStatus:f,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:X,childrenComments:a,likes:{count:ae,status:a}},{id:609602,time:1603914660967,message:"Оператор break приводит к завершению цикла, он выйдет из цикла и остановит дальнейшие итерации.\nReturn : Оператор return выводит вас из метода. Он прекращает выполнение метода и возвращается из выполнения метода.",owner:{id:av,userId:av,key:"anonymous#2421688",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2421688\u002Foriginal.jpeg",displayName:"Dara",position:"Software Developer",job:d,country:a,city:d,level:C,rating:654,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:E,userId:E,key:Y,pictureUrl:Z,displayName:_,position:a,job:a,country:d,city:$,level:r,rating:aa,publicStatus:f,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:X,childrenComments:a,likes:{count:aw,status:a}}],likes:{count:h,status:a}},{id:599969,time:1602596155517,message:"Почему не сказали что в последнем примере если не будет принудительного выхода ихз цикла break; то он будет вечным даже если мы его прервали? \nо том что контроль исключения на InterruptedException сбрасывает признак прерывания у потока и проверка на isInterrupted() вернет ложь Нужно было написать.\nДанный пример только вводит в заблуждение и показывает пример не оптимального кода.",owner:{id:ax,userId:ax,key:"anonymous#1812875",pictureUrl:m,displayName:ab,position:a,job:a,country:g,city:am,level:ay,rating:702,publicStatus:i,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:a,status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:a,childrenComments:[],likes:{count:1,status:a}},{id:n,time:1598172300280,message:"\u003Cpre class=\"lang-java line-numbers\"\u003E\u003Ccode\u003E\npublic class Main {\n\n   public static void main(String[] args) throws InterruptedException {\n\n       long start = System.currentTimeMillis();\n\n       Thread.sleep(3000);\n\n       System.out.println(\" - Сколько я проспал? \\n - \" + ((System.currentTimeMillis()-start)) \u002F 1000 + \" секунды\");\n\n   }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\nЯ немного запутался от большого объема информации, поправьте пожалуйста.\nМетод main у нас является единственным потоком в данном случае? С помощью метода sleep приостанавливается работа главного потока main  на 3 сек. А  метод start у нас используется, только тогда, когда в программе помимо основного потока main, есть дополнительные потоки, все верно? \n",owner:{id:j,userId:j,key:s,pictureUrl:t,displayName:u,position:a,job:a,country:g,city:v,level:o,rating:w,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:a,status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:a,childrenComments:[{id:567800,time:1598440026505,message:"Да, верно. main метод выполняется первым, по дефолту. \nОн является родительской нитью, которая может запускать другие нити. \nВ данном примере дочерних нитей нет, приостанавливается именно работа основного метода. \nthread.start - запускает дочернюю нить",owner:{id:N,userId:N,key:az,pictureUrl:aA,displayName:aB,position:a,job:a,country:g,city:p,level:k,rating:aC,publicStatus:i,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:j,userId:j,key:s,pictureUrl:t,displayName:u,position:a,job:a,country:g,city:v,level:o,rating:w,publicStatus:f,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:n,childrenComments:a,likes:{count:h,status:a}},{id:569597,time:1598634510740,message:"Спасибо! 👍",owner:{id:j,userId:j,key:s,pictureUrl:t,displayName:u,position:a,job:a,country:g,city:v,level:o,rating:w,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:N,userId:N,key:az,pictureUrl:aA,displayName:aB,position:a,job:a,country:g,city:p,level:k,rating:aC,publicStatus:i,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:n,childrenComments:a,likes:{count:h,status:a}},{id:573312,time:1599154658404,message:"Не совсем верно)\nВо первых формулировка: \n\u003Cem\u003EМетод main у нас является единственным потоком\u003C\u002Fem\u003E\nневерна) метод main не является потоком. Верно сказать, что наш классический метод main, является точкой входа в программу, коих может быть множество) и тот поток, который запускается с методом main, является главным)\n\n\u003Cem\u003E С помощью метода sleep приостанавливается работа главного потока main\u003C\u002Fem\u003E\nС помощью статического метода sleep, приостанавливается текущий поток, тот из которого метод sleep был вызван. Он может быть прописан, в методе run(), одного из наших дочерних потоков. Или где угодно еще. Важно, откуда происходит вызов. Для примера набросал немного:\n\u003Cpre class=\"lang-java line-numbers\"\u003E\u003Ccode\u003E\npublic class MainClass {\n    public static void main(String[] args) throws InterruptedException {\n        TestThread ourThread = new TestThread();\n        ourThread.current.sleep(1000);\n    }\n    \n    static class TestThread extends Thread {\n        Thread current;\n\n        public TestThread() {\n            start();\n        }\n\n        @Override\n        public void run() {\n            current = Thread.currentThread();\n            \n            while (!isInterrupted()) {\n                \u002F\u002F...\n            }\n        }\n    }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\nКак по вашему, какая нить остановится в данном случае?))\n\n\u003Cem\u003EА  метод start у нас используется, только тогда, когда в программе помимо основного потока main, есть дополнительные потоки, все верно? \u003C\u002Fem\u003E\nМетод start() используется не \"когда\") он вызывается у созданных вами потоков. Единожды, для того чтобы начать выполнение, переопределенного метода run()",owner:{id:l,userId:l,key:y,pictureUrl:z,displayName:A,position:a,job:a,country:d,city:x,level:k,rating:B,publicStatus:i,publicStatusMessage:a,isFriend:a,subscription:a,badge:O},answerTo:{id:j,userId:j,key:s,pictureUrl:t,displayName:u,position:a,job:a,country:g,city:v,level:o,rating:w,publicStatus:f,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:n,childrenComments:a,likes:{count:aD,status:a}},{id:573780,time:1599228133759,message:"В этом примере просто поясняется как работает sleep: здесь он просто добавляет время простоя к потоку метода main. Переменная long start сохраняет системное время в мс до выполнения метода statlc void sleep() класса java.lang.Thread \u003Ca href=\"https:\u002F\u002Fdocs.oracle.com\u002Fjavase\u002Ftutorial\u002Fessential\u002Fconcurrency\u002Fsleep.html\" target=\"_blank\" rel=\"nofollow\"\u003EPausing Execution with Sleep\u003C\u002Fa\u003E",owner:{id:aE,userId:aE,key:"anonymous#2395987",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2395987\u002Foriginal.jpeg?1605643663546",displayName:"jv.tab",position:a,job:a,country:g,city:p,level:r,rating:422,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:j,userId:j,key:s,pictureUrl:t,displayName:u,position:a,job:a,country:g,city:v,level:o,rating:w,publicStatus:f,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:n,childrenComments:a,likes:{count:h,status:a}},{id:574581,time:1599347602208,message:" \" тот поток, который запускается с методом main, является главным) \" . В лекции у нас 2 потока , t1 и t2, какой поток главный получается? Ни один из них? Там же в лекции написано \"\u002F\u002FГлавный поток продолжит работу только после того, как t1 и t2 завершат работу\". Спасибо за ответ.",owner:{id:j,userId:j,key:s,pictureUrl:t,displayName:u,position:a,job:a,country:g,city:v,level:o,rating:w,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:l,userId:l,key:y,pictureUrl:z,displayName:A,position:a,job:a,country:d,city:x,level:k,rating:B,publicStatus:i,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:n,childrenComments:a,likes:{count:h,status:a}},{id:575558,time:1599492323356,message:"У нас всегда есть основной поток, который мы не запускаем явно. В нем происходит основная работа нашей программы)\nt1 и t2 же - создаются программой явно из основного потока, в методе main(). Всё сходится, ни один из них, не главный)\nВы всё верно поняли) обращайтесь)",owner:{id:l,userId:l,key:y,pictureUrl:z,displayName:A,position:a,job:a,country:d,city:x,level:k,rating:B,publicStatus:i,publicStatusMessage:a,isFriend:a,subscription:a,badge:O},answerTo:{id:j,userId:j,key:s,pictureUrl:t,displayName:u,position:a,job:a,country:g,city:v,level:o,rating:w,publicStatus:f,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:n,childrenComments:a,likes:{count:aD,status:a}},{id:587589,time:1600955358666,message:"хорошее объяснение",owner:{id:aF,userId:aF,key:"facebook#1079488365436381",pictureUrl:m,displayName:"Andrei Po",position:a,job:a,country:a,city:a,level:ay,rating:503,publicStatus:"UNKNOWN",publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:l,userId:l,key:y,pictureUrl:z,displayName:A,position:a,job:a,country:d,city:x,level:k,rating:B,publicStatus:i,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:n,childrenComments:a,likes:{count:h,status:a}},{id:598733,time:1602423210287,message:"Метод  main как раз является потоком (вернее конечно же main содержит внутри себя поток, который создается автоматически при запуске программы), причем главным, если создаем 1 новый поток в своей программе, то у нас их будет 2, главный и побочный.\nИнтересное мнение по поводу входа в программу, не очень понятно как их может быть несколько, если метод main может быть только 1, и только с этого метода начинается выполнение",owner:{id:P,userId:P,key:aG,pictureUrl:m,displayName:ab,position:a,job:a,country:g,city:aH,level:k,rating:aI,publicStatus:i,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:l,userId:l,key:y,pictureUrl:z,displayName:A,position:a,job:a,country:d,city:x,level:k,rating:B,publicStatus:i,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:n,childrenComments:a,likes:{count:h,status:a}},{id:599205,time:1602496534225,message:"Методов main может быть бесчисленное множество - по количеству классов в вашей программе. Каждый может иметь свой метод main",owner:{id:l,userId:l,key:y,pictureUrl:z,displayName:A,position:a,job:a,country:d,city:x,level:k,rating:B,publicStatus:i,publicStatusMessage:a,isFriend:a,subscription:a,badge:O},answerTo:{id:P,userId:P,key:aG,pictureUrl:m,displayName:ab,position:a,job:a,country:g,city:aH,level:k,rating:aI,publicStatus:i,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:n,childrenComments:a,likes:{count:h,status:a}},{id:599462,time:1602520271202,message:"Но ведь при компиляции и запуске программы выбираем главный класс, main которого и запускается. + если вывести имя главного потока, там будет main)",owner:{id:aJ,userId:aJ,key:"github#31883252",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2302914\u002Foriginal.jpeg",displayName:"Darth Nihilus",position:a,job:a,country:a,city:"Planet Korriban",level:o,rating:296,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:j,userId:j,key:s,pictureUrl:t,displayName:u,position:a,job:a,country:g,city:v,level:o,rating:w,publicStatus:f,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:n,childrenComments:a,likes:{count:h,status:a}}],likes:{count:h,status:a}},{id:aK,time:1597594072402,message:"Пример по\u003Cstrong\u003E join()\u003C\u002Fstrong\u003E:\n\u003Cpre class=\"lang-java line-numbers\"\u003E\u003Ccode\u003E\n       \u002F\u002FГлавный поток продолжит работу только после того, как t1 и t2 завершат работу\n       try {\n           t1.join();\n           t2.join();\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\nНо ведь \u003Cstrong\u003Et1.join();\u003C\u002Fstrong\u003E уже было раньше, значит t1 уже точно завершился. Зачем писать это второй раз?\n",owner:{id:Q,userId:Q,key:aL,pictureUrl:m,displayName:aM,position:a,job:a,country:g,city:p,level:aN,rating:aO,publicStatus:i,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:a,status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:a,childrenComments:[{id:573315,time:1599154854515,message:"что для одного может быть очевидно, для другого может стать спасительным билетом) уж лучше так, вместо того, как иногда здесь бывает;)",owner:{id:l,userId:l,key:y,pictureUrl:z,displayName:A,position:a,job:a,country:d,city:x,level:k,rating:B,publicStatus:i,publicStatusMessage:a,isFriend:a,subscription:a,badge:O},answerTo:{id:Q,userId:Q,key:aL,pictureUrl:m,displayName:aM,position:a,job:a,country:g,city:p,level:aN,rating:aO,publicStatus:i,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:aK,childrenComments:a,likes:{count:h,status:a}}],likes:{count:aw,status:a}},{id:557274,time:1596976586534,message:"После просмотра видеоролика больше вопросов, чем ответов, во всяком случае у меня.",owner:{id:aP,userId:aP,key:"github#55682148",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2392258\u002Foriginal.jpeg",displayName:"Erik",position:a,job:a,country:g,city:x,level:25,rating:352,publicStatus:i,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:a,status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:a,childrenComments:[],likes:{count:h,status:a}}],siteMetaData:{title:R,description:aQ,ogTitle:R,ogDescription:aQ,ogPageUrl:"\u002Fgroups\u002Fposts\u002F1993-mnogopotochnostjh-chto-delajut-metodih-klassa-thread",ogPictureUrl:"https:\u002F\u002Fjavarush.ru\u002Fimages\u002Farticle\u002Fa7b37e99-94fd-4795-b95b-cb659ac50939\u002Foriginal.png"},commentsCount:ad}}(null,false,"PUBLIC","","UNVERIFIED","ACTIVE","Россия",0,"STRONG",2273741,22,2105047,"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Fanonymous.svg",565801,17,"Москва",2412909,20,"google#109464292040820866931","https:\u002F\u002Fjavarush.ru\u002Fpictures\u002F2273741\u002Favatar\u002F5v0dk953.png","Павел ","Подольск",351,"Новосибирск","google#111797909486156556924","https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2105047\u002Foriginal.png","Учиха Шисуи",606,19,2437405,2416255,2204027,2241979,610505,"anonymous#2412909","https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2412909\u002Foriginal.jpeg","Е К","Краснодар",520,2377421,"EXPERT",2310084,2361665,"Многопоточность: что делают методы класса Thread",18,"google#111088516188669462182","https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2437405\u002Foriginal.jpeg","Кирилл",335,602291,"anonymous#2416255","https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2416255\u002Foriginal.jpeg","𝔐𝔢𝔱𝔞𝔪𝔬𝔯𝔭𝔥𝔬𝔤𝔢𝔫𝔢𝔰𝔦𝔰","Житомир",529,"Иван",true,109,5,1770672,644125,"anonymous#2204027","Andrzej Latysz",363,2444871,2181104,"Санкт-Петербург",2275993,625277,"anonymous#2241979","Алексей","Night city",430,2328484,2399651,2421688,2,1812875,28,"google#102533881098458520784","https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2377421\u002Foriginal.jpeg","Udjin",412,3,2395987,838725,"anonymous#2310085","Рязань",518,2302914,561907,"anonymous#2361665","wan-derer.ru",39,1214,2392258,"Привет! Сегодня продолжаем говорить о многопоточности. Рассмотрим класс Thread и работу его нескольких методов. Раньше, когда мы изучали методы класса, чаще все"))],session:(function(a,b,c){return {cookie:"_ga=GA1.2.1635737358.1591724185; _fbp=fb.1.1591724185323.1870404734; intercom-id-mqlef7yz=84d17a4c-0270-4786-829d-112c48d9097f; intercom-session-mqlef7yz=; jr-site-tour-default=completed; __stripe_mid=1f326e89-6d32-436a-aca4-107fa6585a232446de; jr-sidebar-group-training-collapsed=0; jr-sidebar-mode=FULL; javarush.user.id=2496069; JSESSIONID=3d655f8b-b927-47d3-be89-86d3188d4a91; javarush.internet.user.key=5361539; javarush.daynight=; _gid=GA1.2.1389844986.1610214788; jr-last-route=%2Fquests%2Flectures%2Fquestcore.level07.lecture01",userIp:"::ffff:10.100.20.20",isDeviceMobile:b,me:{id:2496069,key:"anonymous#2496070",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2496069\u002Foriginal.jpeg",displayName:"Fomin Dmitriy",prefferedLanguage:"RU",level:17,sublevel:9,blackMatter:608,rating:144,country:a,city:"Москва",isMailSet:c,isPasswordSet:c,email:"necronaft@mail.ru",phone:a,statusCode:"active",statusMessage:a,premiumStatus:"PREMIUM",roleStatus:"USER",userFeatures:["QUEST_JAVA_SYNTAX","QUEST_JAVA_SYNTAX_LOW","QUEST_JAVA_SYNTAX_HEIGHT","QUEST_JAVA_CORE","QUEST_JAVA_MULTITHREADING","QUEST_JAVA_COLLECTIONS","QUEST_GAMES","TASK_VALIDATION_INFO","TASK_VALIDATION_RECOMMENDATION_INFO","TASK_EXECUTION_INFO","TASK_COMPILATION_INFO","BONUS_TASKS","PRIORITY_VERIFICATION","FORUM_INVITATION","SMART_WEB_EDITOR","TASK_SAVING","QUEST_TUTORIAL"]},isCompact:b,colorTheme:"dark"}}(null,false,true))};var s=document.createElement("script");try{new Function("if(0)import('')")();s.src="/client/client.ce79b86b.js";s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@2.0.4.js";s.setAttribute("data-main","/client/client.ce79b86b.js")}document.head.appendChild(s)</script>  <title>Многопоточность: что делают методы класса Thread</title><meta name="description" content="Привет! Сегодня продолжаем говорить о многопоточности. Рассмотрим класс Thread и работу его нескольких методов. Раньше, когда мы изучали методы класса, чаще все" data-svelte="svelte-1cntlp0"><meta property="og:title" content="Многопоточность: что делают методы класса Thread" data-svelte="svelte-1cntlp0"><meta property="og:description" content="Привет! Сегодня продолжаем говорить о многопоточности. Рассмотрим класс Thread и работу его нескольких методов. Раньше, когда мы изучали методы класса, чаще все" data-svelte="svelte-1cntlp0"><meta property="og:url" content="/groups/posts/1993-mnogopotochnostjh-chto-delajut-metodih-klassa-thread" data-svelte="svelte-1cntlp0"><meta property="og:image" content="https://javarush.ru/images/article/a7b37e99-94fd-4795-b95b-cb659ac50939/original.png" data-svelte="svelte-1cntlp0"><meta property="og:site_name" content="JavaRush" data-svelte="svelte-1cntlp0"><meta property="og:type" content="website" data-svelte="svelte-1cntlp0"><link rel="canonical" href="https://javarush.ru/groups/posts/1993-mnogopotochnostjh-chto-delajut-metodih-klassa-thread" data-svelte="svelte-1cntlp0"><script type="application/ld+json">{
  "@context": "http://schema.org",
  "@type": "Article",
  "mainEntityOfPage"Введение
                    # Основные компоненты и используемые технологии
                    Для WF–системы была выбрана следующая общая архитектура (в целом соответствует архитектуре, предлагаемой коалицией WfMC):

                    Компоненты системы:

                    Ядро системы
                    Содержит набор определений бизнес-процессов
                    Содержит набор выполняющихся экземпляров бизнес–процессов
                    Компонент, "назначающий" исполнителей для действий
                    Клиент
                    Список заданий (набор графических форм, содержит очереди поступивших работ, сортировки и фильтры)
                    Проигрыватель форм (отображает формы, разработанные в Среде разработки)
                    Административный интерфейс
                    Показывает состояния процессов, позволяет фильтровать и останавливать процессы
                    Позволяет загружать-выгружать процессы
                    Позволяет заводить-удалять пользователей
                    Позволяет задавать различные права
                    Редактор назначения заместителей
                    Среда разработки
                    Конструктор графических форм
                    Бот станции, содержащие ботов (Боты - приложения специального вида, которые также как и обычные пользователи могут выполнять задания)
                    Подсистема управления правами доступа (авторизация и аутентификация)
                    # Платформа программирования и используемые программные средства
                    В качестве платформы программирования используется J2EE.

                    Используемые программные средства:

                    Сервер приложений - JBOSS (http://www.jboss.org).
                    Среда разработки - любая, например Eclipse от IBM (http://www.eclipse.org).
                    Система контроля версий - git
                    Сборщик приложений – maven.
                    Сервер баз данных – поддерживаются сервера БД:
                    MS SQL Server (http://www.microsoft.com/sql/evaluation/default.mspx)
                    HSQL (http://hsqldb.org)
                    Oracle (http://www.oracle.com)
                    PostgreSQL (http://postgresql.com)
                    Операционная система — поддерживаются следующие ОС:
                    Windows (Server 2000-2008, XP, Vista, 7)
                    ALTLinux
                    Mandriva Linux
                    Fedora
                    Debian/Ubuntu
                    # Описание проектов
                    Название проекта	Обязателен при сборке	Обязателен при работе	Зависимости	Описание
                    wfe-alfresco	нет	нет	runawfe-app	Интеграция с Alfresco
                    wfe-app	да	да	wfe-ear, wfe-cactus-it	Проект для организации сборки maven
                    wfe-appserver	нет	нет	 ?	Не используется
                    wfe-bots	да	да	wfe-service	Подсистема ботов
                    wfe-cactus-it	да	нет	wfe-service	Интеграционные тесты
                    wfe-core	да	да	-	Основные компоненты системы
                    wfe-ear	да	да	wfe-service, wfe-bots, wfe-office, wfe-web	Проект для сборки runawfe.ear
                    wfe-office	да	нет	wfe-core	Обработчики для работы с Word, Excel
                    wfe-service	да	да	wfe-core	Сервисы (EJB + WebServices), представляющие собой публичное API приложения
                    wfe-web	да	да	wfe-bots	Визуальная часть приложения
                    wfe-webservice-client	нет	нет	 ?	Авто-генерации клиентской библиотеки на основе WSDL серверных сервисов. В нем же есть примеры использования веб-служб из Java клиента.
                    # Описание слоев архитектуры системы
                    Каждый компонент состоит из нескольких уровней (слоев).

                    Список слоев:

                    delegate
                    service
                    logic
                    DAO
                    hibernate
                    # Слой Delegate
                    Delegate-классы, реализующие сервисные интерфейсы представляют собой pattern проектирования BusinessDelegate, упрощающий доступ к серверному API системы. Клиентское приложение взаимодействует с системой только через Delegate-классы. Delegate-классы получаются посредством запроса фабрики Delegates, которая в зависимости от конфигурации возвращает нужную реализацию. Классы Delegate являются частью клиентского API.

                    Список основных Delegate-классов:

                    AuthenticationServiceDelegate – содержит методы для аутентификации пользователей в системе (с использованием логина/пароля, Kerberos и т.п.)
                    AuthorizationServiceDelegate — содержит методы для работы с полномочиями пользователей (назначение полномочий, проверка на допустимость операции для пользователя и т.п.)
                    BotServiceDelegate — содержит методы для работы с бот станциями и ботами
                    ExecutorServiceDelegate — содержит методы для работы с исполнителями. Позволяет создавать/удалять/изменять исполнителей а так же включать их в группы
                    ProfileServiceDelegate — содержит методы для работы с профайлам пользователей
                    SubstitutionServiceDelegate — содержит методы для управления правилами замещения
                    SystemServiceDelegate — содержит методы для входа/выхода пользователя в систему
                    DefinitionServiceDelegate — содержит методы для работы с определениями процессов
                    ExecutionServiceDelegate — содержит методы для работы с исполняемыми экземплярами процессов
                    Все существующие в данный момент Delegate-классы реализуют требуемую функциональность при помощи технологии EJB.

                    # Слой Service
                    Слой service – это серверное API доступа к системе. Реализации Delegate интерфейсов обращаются именно к этому слою. Каждый Delegate работает с одним соответствующим классом Service. В настоящее время все разработанные service классы и интерфейсы ориентированы на EJB-технологию, однако в будущем возможны и другие реализации. Реализации классов Service являются Stateless Session Bean EJB, которые декларативно поддерживают транзакционность вызовов и запрашивают соответствующие классы из слоя Logic.

                    Таким образом, классы Delegate – Service - Logic образуют как бы «транспорт» между клиентом и сервером.

                    # Слой Logic
                    Слой Logic – это реализация бизнес логики работы системы. Слой работает с классами слоя DAO для доступа к постоянному хранилищу.

                    # Слой DAO
                    Слой DAO – это интерфейсы и классы, обеспечивающие доступ к данным, находящимся в постоянном хранилище (базе данных). В настоящее время все DAO-классы системы реализованы при помощи ORM-средства Hibernate.

                    # Использование Hibernate
                    Hibernate – ORM (Object/Relational Mapping) средство. Отображает объектную архитектуру на реляционную структуру данных. Допускает настройку (не меняя разработанного кода) на большинство существующих серверов реляционных баз данных.

                    Поддерживает работу с распределенными транзакциями, автоматически создает таблицы для новых классов и т.д. Вся работа с данными внутри системы ведется только через Hibernate.

                    Все компоненты, предоставляющие клиентское API построены с использованием описанных выше слоев. В целях оптимизации в некоторых компонентах применяется кеширование, которое может встречаться на уровне logic или DAO. Основная функциональность по управлению кешами находится в классах CachingLogic, CacheInterceptor и классах соответствующих кешей. Изменения в кешируемых объектах перехватываются и сообщаются посредством CachingLogic всем подписавшимся на изменения классам кешей. Транзакция, изменяющая кеш, считается закрытой по окончанию обработки ejb вызова.

                    # Обновление базы данных
                    см. описание системы патчей.

                    # API
                    Система представляет API для интеграции с другими системами:

                    # Java API
                    Реализация (снизу вверх): БД - Hibernate3 - EJB3

                    Документацию можно смотреть в исходном коде (javadocs в *Service.java).

                    # WebServices API
                    Реализация (снизу вверх): БД - Hibernate3 - JAX-WS

                    Документация: WebServicesDeveloperGuide

                    # Scripting API
                    Реализация (снизу вверх): БД - Hibernate3 - XML Script

                    Документация: AdminScriptGuide

                    # Процесс сборки из исходного кода
                    Исходный код системы доступен в открытом репозитории на github.

                    Сервер можно собирать как средствами maven используя командную строку, так и используя среду Eclipse IDE.

                    В результате сборки будет сформирован runawfe.ear, который теоретически можно запустить на любом сервере приложений. Начиная с версии 4.3.0 введена поддержка JAVA версии 8, и отказ от JAVA 6. В дальнейшем планируется отказ от java7, поэтому рекомендуется использовать сервер приложений wildfly.

                    # Процесс сборки на примере Eclipse IDE
                    # Необходимое программное обеспечение для сборки
                    В отличие от Среды разработки для сборки сервера можно использовать Eclipse IDE любой версии и редакции.

                    установите плагин m2eclipse
                    используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу: http://maven.apache.org/
                    добавьте путь к Apache Maven директории bin в переменную окружения Path
                    # Импорт проектов
                    Импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server.

                    Eclipse srv proj.png

                    # Установка maven артефактов
                    Выполните

                    ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                    ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                    или другим способом установите артефакты в локальный репозиторий

                    # Сборка
                    Заведите конфигурацию запуска на основе maven как показано на рисунке

                    Maven.build.configuration.png

                    Запустите конфигурацию.

                    Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\eclipse-workspace\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"

                    # Сборка из командной строки
                    используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу http://maven.apache.org/
                    добавьте путь к Apache Maven директории bin в переменную окружения Path
                    импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server
                    выполните обновление зависимостей
                    ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                    ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                    откройте командную строку
                    перейдите в директорию ${wfe}/wfe-app/
                    выполните команду для сборки
                    mvn clean package -Dmaven.test.skip=true
                    Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"


                    Для установки артефактов в локальный репозиторий используйте команду

                    mvn clean install -Dmaven.test.skip=true
                    # Использование ear на сервере приложений
                    cкачайте текущую версию RunaWFE в виде файл-архива исполняемых java файлов runawfe-wildfly-java8-*.zip (на базе wildfly, java8)
                    распакуйте архив
                    обновите runawfe.ear на версию полученную в результате сборки
                    # Расширение функциональности
                    # Точки расширения системы
                    Обработчики позволяют исполнить код в процессах (элементы "Обработчик", "Задача сценария") и ботах
                    Форматы переменных определяют тип переменных и правила преобразования значений к текстовому представлению и обратно
                    Организационные функции используются при назначении ролей и в правилах замещения для определения заместителя
                    Критерии замещения используются в подсистеме замещения для определения заместителя при построении списка заданий
                    Валидаторы обеспечивают проверку переменных при выполнении задания (в т.ч. введенные значения форм)
                    Freemarker теги форм генерируют html код для отображения на форме
                    Ajax команды предоставляют доступ к функциональности сервера из JavaScript
                    # Процесс разработки расширений
                    Создайте новый java-проект и подключите необходимые зависимости (wfe-core, wfe-service).

                    Реализуйте в нем требуемые расширения и соберите его в виде jar-файла.

                    Замечание. Использование maven облегчит процесс управления зависимостями.

                    Разместить собранный jar на сервере вы можете:

                    положив его в runawfe.ear!/lib
                    положив его в директорию deploy (только для jboss4)
                    положив его в ${jboss.server.base.dir}/wfe.custom (только для jboss7)
                    положив его в ${jboss.server.base.dir}/${jboss.server.name}/wfe.custom (только для jboss4)
                    # Обработчики
                    Обработчик в процессе – компонент процесса (элементы "Обработчик", "Задача сценария"), использующийся для выполнения каких-либо действий при возникновении определенных событий (проход по определенному переходу в процессе, приход или уход управления из узла и т.п.).

                    Обработчик должен реализовывать интерфейс ru.runa.wfe.extension.ActionHandler. Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов Spring контекста (например с помощью аннотации @Autowired).

                    При написании нового обработчика рекомендуется наследовать его от абстрактного класса ru.runa.wfe.extension.handler.CommonHandler или ru.runa.wfe.extension.handler.CommonParamBasedHandler. В методе setConfiguration обработчик должен запомнить свои параметры (если обработчик их ожидает), а в методе execute происходит непосредственная обработка и выполнение требуемых действий.

                    В случае, если при выполнении обработчика произошла ошибка, произойдет откат транзакции и состояние процесса будет возвращено к заданию, исполнение которого повлекло вызов обработчика. В интерфейсе обработчика для бота ru.runa.wfe.extension.TaskHandler предусмотрен метод onRollback для работы с не-транзакционными ресурсами.

                    Эти обработчики удобно использовать для простых операций (например для отправки оповещений в виде SMS-сообщений если процесс попал в определенное состояние). Но у них есть несколько ограничений. Прежде всего у них нет соответствующего объекта контекста безопасности (security context). Это означает, что в них нельзя выполнять защищенные методы (запуск процессов, выполнение задач, создание пользователей и т.п.) Ошибочным решением в них будет блокирование выполнения процесса (например с Thread::Sleep(...)). Например, если в обработчике отправляется e-mail, а SMTP сервер недоступен, обработчику нельзя "задерживать" свое выполнение.

                    Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                    # Специфика обработчиков для ботов
                    Бот - это сокращение от робот. В системе боты - это особый тип исполнителей. Система не отличает ботов от людей. У каждого бота есть свои права на вход в систему, он периодически просыпается, проверяет свой список задачи и выполняет обнаруженные там задачи.

                    Каждая задача бота обрабатывается при помощи соответствующего обработчика. Чтобы написать новый обработчик нужно реализовать интерфейс ru.runa.wfe.extension.TaskHandler.

                    Обратите внимание, что этот вид обработчиков выполняется в контексте безопасности (security context) пользователя-бота, и здесь может выполнятся любая операция (если у бота есть на это права).

                    Обработчики задач ботов могут блокировать выполнение процесса.

                    Например, обработчик задач, отправляющий e-mail может блокировать выполнение бизнес процесса до тех пор, пока обработчик не удостоверится, что SMTP сервер принял сообщение для последующей доставки.

                    Обработчики задач вызываются периодически, когда боты проверяют свои списки задач.

                    # Специфика обработчика для элемента ветвление
                    Обработчик для Decision является java-классом, реализующим интерфейс ru.runa.wfe.extension.DecisionHandler. Интерфейс содержит один метод decide(ExecutionContext executionContext), который возвращает имя выбранного перехода (одного из выходящих из данного ветвления). Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов контекста спринга (например с помощью аннотации @Autowired).

                    Обработчик принимает ExecutionContext в качестве входящего параметра и должен сделать выбор перехода исходя из значений переменных бизнес процесса и условий, указанных в конфигурации обработчика. Точно также как обработчики действия (action handler) обработчики выбора (decision handlers) не могут использовать защищенные (secured) методы, не могут обрабатывать ошибки и откладывать выбор перехода до лучших времен.

                    По умолчанию используется ru.runa.wfe.extension.decision.GroovyDecisionHandler.

                    # Использование ru.runa.wfe.extension.handler.CommonParamBasedHandler в качестве базового класса
                    Этот класс инкапсулирует в себе парсинг XML конфигурации определенного формата. Его удобно использовать если обработчик имеет фиксированное число параметров. Пример конфигурации:

                    <?xml version="1.0" encoding="UTF-8"?>
                    <config>
                     <input>
                       <param name="typeName" variable="тип отсутствия" />
                       <param name="employee" variable="сотрудник" />
                       <param name="requester" variable="подавший заявку" />
                       <param name="from" variable="дата с" />
                       <param name="to" variable="дата по" />
                       <param name="cause" variable="причина" />
                       <param name="comment" variable="комментарий" />
                       <param name="confirmation" variable="дата подтверждения" />
                       <param name="firmCode" value="111" />
                       <param name="firmPositionCode" variable="код должности" />
                       <param name="firmDepartmentCode" variable="код подразделения" />
                     </input>
                     <output>
                       <param name="uuid" variable="идентификатор объекта" />
                     </output>
                    </config>
                    Использование обработчика Groovy
                    См. соответствующий раздел в руководстве по работе с Groovy.

                    # Как написать функцию над организационной структурой
                    Функции над организационной структурой в системе применяются, например, при инициализации Ролей-Дорожек и в правилах замещения.

                    Класс, соответствующий функции над организационной структурой, должен реализовывать интерфейс ru.runa.wfe.extension.OrgFunction.

                    Интерфейс содержит один метод

                    List<? extends Executor> getExecutors(Object... parameters)
                    Этот метод должен возвращать список исполнителей.

                    В бизнес-процессе обработчик функции над оргструктурой используются при определении Ролей-Дорожек: указывается внутри тега swimlane, в теле тега <assignment>.В качестве параметра class тега <assignment> указывается класс-обработчик для инициализации swimlane: ru.runa.wfe.extension.AssignmentHandler. Внутри тега <assignment> содержится конфигурация для этого класса, которая представляет собой имя класса-наследника интерфейса OrgFunction и список параметров в скобках. В качестве параметра может выступать конкретное значение или имя переменной бизнес процесса в фигурных скобках, перед которым стоит значок $

                    Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                    Если есть планы по использованию функции в подсистеме замещений - её можно зарегистрировать в substitutions.xml.

                    # Как написать критерий замещения
                    Критерии замещения в системе применяются в правилах замещения. Класс, соответствующий критерию замещения, должен наследоваться от ru.runa.wfe.ss.SubstitutionCriteria.

                    Для создания на основе него конечных критериев замещения с конфигурациями - его нужно зарегистрировать в substitution.criterias.xml.

                    Как реализовать класс-формат для переменных бизнес-процесса
                    См. соответствующий раздел в руководстве по работе с переменными.

                    # Как реализовать валидатор переменных
                    Классы, расширяющие абстрактный класс ru.runa.wfe.validation.FieldValidator, в системе применяются для проверки переменных при выполнении задания или старте процесса.

                    Пример:

                    public class OvertimeWorkRequestTimeCheck extends FieldValidator {
                       @Override
                       public void validate() {
                           Date date = (Date) getFieldValue();
                           if (date == null) {
                               return;
                           }
                           boolean testMode = getVariableProvider().getValueNotNull(boolean.class, "тестовый режим");
                           if (testMode) {
                               return;
                           }
                           Calendar calendar = CalendarUtil.dateToCalendar(date);
                           if (calendar.before(Calendar.getInstance())) {
                               addError("Заявка не может быть оформлена задним числом");
                               return;
                           }
                           CalendarUtil.setTimeFromCalendar(calendar, DemoProperties.getOvertimeWorkRequestMaximumStartTime());
                           Utils.adjustCalendarForHolidaysInOvertimwWork(calendar);
                           if (calendar.before(Calendar.getInstance())) {
                               addError("Заявка на этот день не может быть подана, время подачи истекло " + CalendarUtil.formatDateTime(calendar));
                           }
                       }
                    }

                    Связь между Средой разработки и сервером осуществляется по имени валидатора, регистрация требуется на стороне сервера в файле validators.xml, а в среде разработки - в plugin.xml.

                    # Как реализовать FreeMarker тег для формы
                    FreemarkerForms#Components

                    # Как реализовать Ajax команду
                    Классы, расширяющие абстрактный класс ru.runa.wfe.commons.web.JsonAjaxCommand, (или реализующие ru.runa.wfe.commons.web.AjaxCommand) в системе применяются для доступа к функциональности сервера из JavaScript, например при отображении форм задания.

                    Регистрация команды происходит любым из двух способов:

                    в файле ajax.commands.xml, ей присваивается определенное имя
                    в контексте приложения, именем является id spring-бина
                    Затем по этому имени её можно выполнить используя JavaScript.

                    Пример команды

                    public class GetOrganizationNamesCommand extends JsonAjaxCommand {
                       @Autowired
                       private OrganizationDAO organizationDAO;
                       @Override
                       protected JSONAware execute(User user, HttpServletRequest request) throws Exception {
                           String term = request.getParameter("term");
                           if (term == null) {
                               term = "";
                           }
                           List<Organization> organizations = organizationDAO.getAll();
                           JSONArray array = new JSONArray();
                           for (Organization organization : organizations) {
                               if (organization.getName().startsWith(term)) {
                                   array.add(organization.getName());
                               }
                           }
                           return array;
                       }
                    }
                    Регистрация в wfe.custom.ajax.commands.xml

                    <?xml version="1.0" encoding="UTF-8" ?>
                    <configuration xmlns="http://runa.ru/xml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://runa.ru/xml">
                     <command name="getOrganizationNames" class="ru.runa.rkdemo.web.ajax.GetOrganizationNamesCommand" />
                    </configuration>
                    Её использование со скрипта формы (autocomplete input)

                    $(document).ready(function() {
                     $('#editLinkedLists').on("onRowAdded", function(event, rowIndex) {
                      $("input[name='названия организаций["+rowIndex+"]']").autocomplete( {
                       delay: 300,
                       minLength: 0,
                       source: "/wfe/ajaxcmd?command=getOrganizationNames"
                      });
                      $("input[name='названия организаций["+rowIndex+"]']").focus(function() {
                       $(this).autocomplete("search", $(this).val());
                      });
                     });
                    });Введение
                       # Основные компоненты и используемые технологии
                       Для WF–системы была выбрана следующая общая архитектура (в целом соответствует архитектуре, предлагаемой коалицией WfMC):

                       Компоненты системы:

                       Ядро системы
                       Содержит набор определений бизнес-процессов
                       Содержит набор выполняющихся экземпляров бизнес–процессов
                       Компонент, "назначающий" исполнителей для действий
                       Клиент
                       Список заданий (набор графических форм, содержит очереди поступивших работ, сортировки и фильтры)
                       Проигрыватель форм (отображает формы, разработанные в Среде разработки)
                       Административный интерфейс
                       Показывает состояния процессов, позволяет фильтровать и останавливать процессы
                       Позволяет загружать-выгружать процессы
                       Позволяет заводить-удалять пользователей
                       Позволяет задавать различные права
                       Редактор назначения заместителей
                       Среда разработки
                       Конструктор графических форм
                       Бот станции, содержащие ботов (Боты - приложения специального вида, которые также как и обычные пользователи могут выполнять задания)
                       Подсистема управления правами доступа (авторизация и аутентификация)
                       # Платформа программирования и используемые программные средства
                       В качестве платформы программирования используется J2EE.

                       Используемые программные средства:

                       Сервер приложений - JBOSS (http://www.jboss.org).
                       Среда разработки - любая, например Eclipse от IBM (http://www.eclipse.org).
                       Система контроля версий - git
                       Сборщик приложений – maven.
                       Сервер баз данных – поддерживаются сервера БД:
                       MS SQL Server (http://www.microsoft.com/sql/evaluation/default.mspx)
                       HSQL (http://hsqldb.org)
                       Oracle (http://www.oracle.com)
                       PostgreSQL (http://postgresql.com)
                       Операционная система — поддерживаются следующие ОС:
                       Windows (Server 2000-2008, XP, Vista, 7)
                       ALTLinux
                       Mandriva Linux
                       Fedora
                       Debian/Ubuntu
                       # Описание проектов
                       Название проекта	Обязателен при сборке	Обязателен при работе	Зависимости	Описание
                       wfe-alfresco	нет	нет	runawfe-app	Интеграция с Alfresco
                       wfe-app	да	да	wfe-ear, wfe-cactus-it	Проект для организации сборки maven
                       wfe-appserver	нет	нет	 ?	Не используется
                       wfe-bots	да	да	wfe-service	Подсистема ботов
                       wfe-cactus-it	да	нет	wfe-service	Интеграционные тесты
                       wfe-core	да	да	-	Основные компоненты системы
                       wfe-ear	да	да	wfe-service, wfe-bots, wfe-office, wfe-web	Проект для сборки runawfe.ear
                       wfe-office	да	нет	wfe-core	Обработчики для работы с Word, Excel
                       wfe-service	да	да	wfe-core	Сервисы (EJB + WebServices), представляющие собой публичное API приложения
                       wfe-web	да	да	wfe-bots	Визуальная часть приложения
                       wfe-webservice-client	нет	нет	 ?	Авто-генерации клиентской библиотеки на основе WSDL серверных сервисов. В нем же есть примеры использования веб-служб из Java клиента.
                       # Описание слоев архитектуры системы
                       Каждый компонент состоит из нескольких уровней (слоев).

                       Список слоев:

                       delegate
                       service
                       logic
                       DAO
                       hibernate
                       # Слой Delegate
                       Delegate-классы, реализующие сервисные интерфейсы представляют собой pattern проектирования BusinessDelegate, упрощающий доступ к серверному API системы. Клиентское приложение взаимодействует с системой только через Delegate-классы. Delegate-классы получаются посредством запроса фабрики Delegates, которая в зависимости от конфигурации возвращает нужную реализацию. Классы Delegate являются частью клиентского API.

                       Список основных Delegate-классов:

                       AuthenticationServiceDelegate – содержит методы для аутентификации пользователей в системе (с использованием логина/пароля, Kerberos и т.п.)
                       AuthorizationServiceDelegate — содержит методы для работы с полномочиями пользователей (назначение полномочий, проверка на допустимость операции для пользователя и т.п.)
                       BotServiceDelegate — содержит методы для работы с бот станциями и ботами
                       ExecutorServiceDelegate — содержит методы для работы с исполнителями. Позволяет создавать/удалять/изменять исполнителей а так же включать их в группы
                       ProfileServiceDelegate — содержит методы для работы с профайлам пользователей
                       SubstitutionServiceDelegate — содержит методы для управления правилами замещения
                       SystemServiceDelegate — содержит методы для входа/выхода пользователя в систему
                       DefinitionServiceDelegate — содержит методы для работы с определениями процессов
                       ExecutionServiceDelegate — содержит методы для работы с исполняемыми экземплярами процессов
                       Все существующие в данный момент Delegate-классы реализуют требуемую функциональность при помощи технологии EJB.

                       # Слой Service
                       Слой service – это серверное API доступа к системе. Реализации Delegate интерфейсов обращаются именно к этому слою. Каждый Delegate работает с одним соответствующим классом Service. В настоящее время все разработанные service классы и интерфейсы ориентированы на EJB-технологию, однако в будущем возможны и другие реализации. Реализации классов Service являются Stateless Session Bean EJB, которые декларативно поддерживают транзакционность вызовов и запрашивают соответствующие классы из слоя Logic.

                       Таким образом, классы Delegate – Service - Logic образуют как бы «транспорт» между клиентом и сервером.

                       # Слой Logic
                       Слой Logic – это реализация бизнес логики работы системы. Слой работает с классами слоя DAO для доступа к постоянному хранилищу.

                       # Слой DAO
                       Слой DAO – это интерфейсы и классы, обеспечивающие доступ к данным, находящимся в постоянном хранилище (базе данных). В настоящее время все DAO-классы системы реализованы при помощи ORM-средства Hibernate.

                       # Использование Hibernate
                       Hibernate – ORM (Object/Relational Mapping) средство. Отображает объектную архитектуру на реляционную структуру данных. Допускает настройку (не меняя разработанного кода) на большинство существующих серверов реляционных баз данных.

                       Поддерживает работу с распределенными транзакциями, автоматически создает таблицы для новых классов и т.д. Вся работа с данными внутри системы ведется только через Hibernate.

                       Все компоненты, предоставляющие клиентское API построены с использованием описанных выше слоев. В целях оптимизации в некоторых компонентах применяется кеширование, которое может встречаться на уровне logic или DAO. Основная функциональность по управлению кешами находится в классах CachingLogic, CacheInterceptor и классах соответствующих кешей. Изменения в кешируемых объектах перехватываются и сообщаются посредством CachingLogic всем подписавшимся на изменения классам кешей. Транзакция, изменяющая кеш, считается закрытой по окончанию обработки ejb вызова.

                       # Обновление базы данных
                       см. описание системы патчей.

                       # API
                       Система представляет API для интеграции с другими системами:

                       # Java API
                       Реализация (снизу вверх): БД - Hibernate3 - EJB3

                       Документацию можно смотреть в исходном коде (javadocs в *Service.java).

                       # WebServices API
                       Реализация (снизу вверх): БД - Hibernate3 - JAX-WS

                       Документация: WebServicesDeveloperGuide

                       # Scripting API
                       Реализация (снизу вверх): БД - Hibernate3 - XML Script

                       Документация: AdminScriptGuide

                       # Процесс сборки из исходного кода
                       Исходный код системы доступен в открытом репозитории на github.

                       Сервер можно собирать как средствами maven используя командную строку, так и используя среду Eclipse IDE.

                       В результате сборки будет сформирован runawfe.ear, который теоретически можно запустить на любом сервере приложений. Начиная с версии 4.3.0 введена поддержка JAVA версии 8, и отказ от JAVA 6. В дальнейшем планируется отказ от java7, поэтому рекомендуется использовать сервер приложений wildfly.

                       # Процесс сборки на примере Eclipse IDE
                       # Необходимое программное обеспечение для сборки
                       В отличие от Среды разработки для сборки сервера можно использовать Eclipse IDE любой версии и редакции.

                       установите плагин m2eclipse
                       используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу: http://maven.apache.org/
                       добавьте путь к Apache Maven директории bin в переменную окружения Path
                       # Импорт проектов
                       Импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server.

                       Eclipse srv proj.png

                       # Установка maven артефактов
                       Выполните

                       ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                       ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                       или другим способом установите артефакты в локальный репозиторий

                       # Сборка
                       Заведите конфигурацию запуска на основе maven как показано на рисунке

                       Maven.build.configuration.png

                       Запустите конфигурацию.

                       Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\eclipse-workspace\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"

                       # Сборка из командной строки
                       используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу http://maven.apache.org/
                       добавьте путь к Apache Maven директории bin в переменную окружения Path
                       импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server
                       выполните обновление зависимостей
                       ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                       ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                       откройте командную строку
                       перейдите в директорию ${wfe}/wfe-app/
                       выполните команду для сборки
                       mvn clean package -Dmaven.test.skip=true
                       Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"


                       Для установки артефактов в локальный репозиторий используйте команду

                       mvn clean install -Dmaven.test.skip=true
                       # Использование ear на сервере приложений
                       cкачайте текущую версию RunaWFE в виде файл-архива исполняемых java файлов runawfe-wildfly-java8-*.zip (на базе wildfly, java8)
                       распакуйте архив
                       обновите runawfe.ear на версию полученную в результате сборки
                       # Расширение функциональности
                       # Точки расширения системы
                       Обработчики позволяют исполнить код в процессах (элементы "Обработчик", "Задача сценария") и ботах
                       Форматы переменных определяют тип переменных и правила преобразования значений к текстовому представлению и обратно
                       Организационные функции используются при назначении ролей и в правилах замещения для определения заместителя
                       Критерии замещения используются в подсистеме замещения для определения заместителя при построении списка заданий
                       Валидаторы обеспечивают проверку переменных при выполнении задания (в т.ч. введенные значения форм)
                       Freemarker теги форм генерируют html код для отображения на форме
                       Ajax команды предоставляют доступ к функциональности сервера из JavaScript
                       # Процесс разработки расширений
                       Создайте новый java-проект и подключите необходимые зависимости (wfe-core, wfe-service).

                       Реализуйте в нем требуемые расширения и соберите его в виде jar-файла.

                       Замечание. Использование maven облегчит процесс управления зависимостями.

                       Разместить собранный jar на сервере вы можете:

                       положив его в runawfe.ear!/lib
                       положив его в директорию deploy (только для jboss4)
                       положив его в ${jboss.server.base.dir}/wfe.custom (только для jboss7)
                       положив его в ${jboss.server.base.dir}/${jboss.server.name}/wfe.custom (только для jboss4)
                       # Обработчики
                       Обработчик в процессе – компонент процесса (элементы "Обработчик", "Задача сценария"), использующийся для выполнения каких-либо действий при возникновении определенных событий (проход по определенному переходу в процессе, приход или уход управления из узла и т.п.).

                       Обработчик должен реализовывать интерфейс ru.runa.wfe.extension.ActionHandler. Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов Spring контекста (например с помощью аннотации @Autowired).

                       При написании нового обработчика рекомендуется наследовать его от абстрактного класса ru.runa.wfe.extension.handler.CommonHandler или ru.runa.wfe.extension.handler.CommonParamBasedHandler. В методе setConfiguration обработчик должен запомнить свои параметры (если обработчик их ожидает), а в методе execute происходит непосредственная обработка и выполнение требуемых действий.

                       В случае, если при выполнении обработчика произошла ошибка, произойдет откат транзакции и состояние процесса будет возвращено к заданию, исполнение которого повлекло вызов обработчика. В интерфейсе обработчика для бота ru.runa.wfe.extension.TaskHandler предусмотрен метод onRollback для работы с не-транзакционными ресурсами.

                       Эти обработчики удобно использовать для простых операций (например для отправки оповещений в виде SMS-сообщений если процесс попал в определенное состояние). Но у них есть несколько ограничений. Прежде всего у них нет соответствующего объекта контекста безопасности (security context). Это означает, что в них нельзя выполнять защищенные методы (запуск процессов, выполнение задач, создание пользователей и т.п.) Ошибочным решением в них будет блокирование выполнения процесса (например с Thread::Sleep(...)). Например, если в обработчике отправляется e-mail, а SMTP сервер недоступен, обработчику нельзя "задерживать" свое выполнение.

                       Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                       # Специфика обработчиков для ботов
                       Бот - это сокращение от робот. В системе боты - это особый тип исполнителей. Система не отличает ботов от людей. У каждого бота есть свои права на вход в систему, он периодически просыпается, проверяет свой список задачи и выполняет обнаруженные там задачи.

                       Каждая задача бота обрабатывается при помощи соответствующего обработчика. Чтобы написать новый обработчик нужно реализовать интерфейс ru.runa.wfe.extension.TaskHandler.

                       Обратите внимание, что этот вид обработчиков выполняется в контексте безопасности (security context) пользователя-бота, и здесь может выполнятся любая операция (если у бота есть на это права).

                       Обработчики задач ботов могут блокировать выполнение процесса.

                       Например, обработчик задач, отправляющий e-mail может блокировать выполнение бизнес процесса до тех пор, пока обработчик не удостоверится, что SMTP сервер принял сообщение для последующей доставки.

                       Обработчики задач вызываются периодически, когда боты проверяют свои списки задач.

                       # Специфика обработчика для элемента ветвление
                       Обработчик для Decision является java-классом, реализующим интерфейс ru.runa.wfe.extension.DecisionHandler. Интерфейс содержит один метод decide(ExecutionContext executionContext), который возвращает имя выбранного перехода (одного из выходящих из данного ветвления). Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов контекста спринга (например с помощью аннотации @Autowired).

                       Обработчик принимает ExecutionContext в качестве входящего параметра и должен сделать выбор перехода исходя из значений переменных бизнес процесса и условий, указанных в конфигурации обработчика. Точно также как обработчики действия (action handler) обработчики выбора (decision handlers) не могут использовать защищенные (secured) методы, не могут обрабатывать ошибки и откладывать выбор перехода до лучших времен.

                       По умолчанию используется ru.runa.wfe.extension.decision.GroovyDecisionHandler.

                       # Использование ru.runa.wfe.extension.handler.CommonParamBasedHandler в качестве базового класса
                       Этот класс инкапсулирует в себе парсинг XML конфигурации определенного формата. Его удобно использовать если обработчик имеет фиксированное число параметров. Пример конфигурации:

                       <?xml version="1.0" encoding="UTF-8"?>
                       <config>
                        <input>
                          <param name="typeName" variable="тип отсутствия" />
                          <param name="employee" variable="сотрудник" />
                          <param name="requester" variable="подавший заявку" />
                          <param name="from" variable="дата с" />
                          <param name="to" variable="дата по" />
                          <param name="cause" variable="причина" />
                          <param name="comment" variable="комментарий" />
                          <param name="confirmation" variable="дата подтверждения" />
                          <param name="firmCode" value="111" />
                          <param name="firmPositionCode" variable="код должности" />
                          <param name="firmDepartmentCode" variable="код подразделения" />
                        </input>
                        <output>
                          <param name="uuid" variable="идентификатор объекта" />
                        </output>
                       </config>
                       Использование обработчика Groovy
                       См. соответствующий раздел в руководстве по работе с Groovy.

                       # Как написать функцию над организационной структурой
                       Функции над организационной структурой в системе применяются, например, при инициализации Ролей-Дорожек и в правилах замещения.

                       Класс, соответствующий функции над организационной структурой, должен реализовывать интерфейс ru.runa.wfe.extension.OrgFunction.

                       Интерфейс содержит один метод

                       List<? extends Executor> getExecutors(Object... parameters)
                       Этот метод должен возвращать список исполнителей.

                       В бизнес-процессе обработчик функции над оргструктурой используются при определении Ролей-Дорожек: указывается внутри тега swimlane, в теле тега <assignment>.В качестве параметра class тега <assignment> указывается класс-обработчик для инициализации swimlane: ru.runa.wfe.extension.AssignmentHandler. Внутри тега <assignment> содержится конфигурация для этого класса, которая представляет собой имя класса-наследника интерфейса OrgFunction и список параметров в скобках. В качестве параметра может выступать конкретное значение или имя переменной бизнес процесса в фигурных скобках, перед которым стоит значок $

                       Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                       Если есть планы по использованию функции в подсистеме замещений - её можно зарегистрировать в substitutions.xml.

                       # Как написать критерий замещения
                       Критерии замещения в системе применяются в правилах замещения. Класс, соответствующий критерию замещения, должен наследоваться от ru.runa.wfe.ss.SubstitutionCriteria.

                       Для создания на основе него конечных критериев замещения с конфигурациями - его нужно зарегистрировать в substitution.criterias.xml.

                       Как реализовать класс-формат для переменных бизнес-процесса
                       См. соответствующий раздел в руководстве по работе с переменными.

                       # Как реализовать валидатор переменных
                       Классы, расширяющие абстрактный класс ru.runa.wfe.validation.FieldValidator, в системе применяются для проверки переменных при выполнении задания или старте процесса.

                       Пример:

                       public class OvertimeWorkRequestTimeCheck extends FieldValidator {
                          @Override
                          public void validate() {
                              Date date = (Date) getFieldValue();
                              if (date == null) {
                                  return;
                              }
                              boolean testMode = getVariableProvider().getValueNotNull(boolean.class, "тестовый режим");
                              if (testMode) {
                                  return;
                              }
                              Calendar calendar = CalendarUtil.dateToCalendar(date);
                              if (calendar.before(Calendar.getInstance())) {
                                  addError("Заявка не может быть оформлена задним числом");
                                  return;
                              }
                              CalendarUtil.setTimeFromCalendar(calendar, DemoProperties.getOvertimeWorkRequestMaximumStartTime());
                              Utils.adjustCalendarForHolidaysInOvertimwWork(calendar);
                              if (calendar.before(Calendar.getInstance())) {
                                  addError("Заявка на этот день не может быть подана, время подачи истекло " + CalendarUtil.formatDateTime(calendar));
                              }
                          }
                       }

                       Связь между Средой разработки и сервером осуществляется по имени валидатора, регистрация требуется на стороне сервера в файле validators.xml, а в среде разработки - в plugin.xml.

                       # Как реализовать FreeMarker тег для формы
                       FreemarkerForms#Components

                       # Как реализовать Ajax команду
                       Классы, расширяющие абстрактный класс ru.runa.wfe.commons.web.JsonAjaxCommand, (или реализующие ru.runa.wfe.commons.web.AjaxCommand) в системе применяются для доступа к функциональности сервера из JavaScript, например при отображении форм задания.

                       Регистрация команды происходит любым из двух способов:

                       в файле ajax.commands.xml, ей присваивается определенное имя
                       в контексте приложения, именем является id spring-бина
                       Затем по этому имени её можно выполнить используя JavaScript.

                       Пример команды

                       public class GetOrganizationNamesCommand extends JsonAjaxCommand {
                          @Autowired
                          private OrganizationDAO organizationDAO;
                          @Override
                          protected JSONAware execute(User user, HttpServletRequest request) throws Exception {
                              String term = request.getParameter("term");
                              if (term == null) {
                                  term = "";
                              }
                              List<Organization> organizations = organizationDAO.getAll();
                              JSONArray array = new JSONArray();
                              for (Organization organization : organizations) {
                                  if (organization.getName().startsWith(term)) {
                                      array.add(organization.getName());
                                  }
                              }
                              return array;
                          }
                       }
                       Регистрация в wfe.custom.ajax.commands.xml

                       <?xml version="1.0" encoding="UTF-8" ?>
                       <configuration xmlns="http://runa.ru/xml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://runa.ru/xml">
                        <command name="getOrganizationNames" class="ru.runa.rkdemo.web.ajax.GetOrganizationNamesCommand" />
                       </configuration>
                       Её использование со скрипта формы (autocomplete input)

                       $(document).ready(function() {
                        $('#editLinkedLists').on("onRowAdded", function(event, rowIndex) {
                         $("input[name='названия организаций["+rowIndex+"]']").autocomplete( {
                          delay: 300,
                          minLength: 0,
                          source: "/wfe/ajaxcmd?command=getOrganizationNames"
                         });
                         $("input[name='названия организаций["+rowIndex+"]']").focus(function() {
                          $(this).autocomplete("search", $(this).val());
                         });
                        });
                       });Введение
                          # Основные компоненты и используемые технологии
                          Для WF–системы была выбрана следующая общая архитектура (в целом соответствует архитектуре, предлагаемой коалицией WfMC):

                          Компоненты системы:

                          Ядро системы
                          Содержит набор определений бизнес-процессов
                          Содержит набор выполняющихся экземпляров бизнес–процессов
                          Компонент, "назначающий" исполнителей для действий
                          Клиент
                          Список заданий (набор графических форм, содержит очереди поступивших работ, сортировки и фильтры)
                          Проигрыватель форм (отображает формы, разработанные в Среде разработки)
                          Административный интерфейс
                          Показывает состояния процессов, позволяет фильтровать и останавливать процессы
                          Позволяет загружать-выгружать процессы
                          Позволяет заводить-удалять пользователей
                          Позволяет задавать различные права
                          Редактор назначения заместителей
                          Среда разработки
                          Конструктор графических форм
                          Бот станции, содержащие ботов (Боты - приложения специального вида, которые также как и обычные пользователи могут выполнять задания)
                          Подсистема управления правами доступа (авторизация и аутентификация)
                          # Платформа программирования и используемые программные средства
                          В качестве платформы программирования используется J2EE.

                          Используемые программные средства:

                          Сервер приложений - JBOSS (http://www.jboss.org).
                          Среда разработки - любая, например Eclipse от IBM (http://www.eclipse.org).
                          Система контроля версий - git
                          Сборщик приложений – maven.
                          Сервер баз данных – поддерживаются сервера БД:
                          MS SQL Server (http://www.microsoft.com/sql/evaluation/default.mspx)
                          HSQL (http://hsqldb.org)
                          Oracle (http://www.oracle.com)
                          PostgreSQL (http://postgresql.com)
                          Операционная система — поддерживаются следующие ОС:
                          Windows (Server 2000-2008, XP, Vista, 7)
                          ALTLinux
                          Mandriva Linux
                          Fedora
                          Debian/Ubuntu
                          # Описание проектов
                          Название проекта	Обязателен при сборке	Обязателен при работе	Зависимости	Описание
                          wfe-alfresco	нет	нет	runawfe-app	Интеграция с Alfresco
                          wfe-app	да	да	wfe-ear, wfe-cactus-it	Проект для организации сборки maven
                          wfe-appserver	нет	нет	 ?	Не используется
                          wfe-bots	да	да	wfe-service	Подсистема ботов
                          wfe-cactus-it	да	нет	wfe-service	Интеграционные тесты
                          wfe-core	да	да	-	Основные компоненты системы
                          wfe-ear	да	да	wfe-service, wfe-bots, wfe-office, wfe-web	Проект для сборки runawfe.ear
                          wfe-office	да	нет	wfe-core	Обработчики для работы с Word, Excel
                          wfe-service	да	да	wfe-core	Сервисы (EJB + WebServices), представляющие собой публичное API приложения
                          wfe-web	да	да	wfe-bots	Визуальная часть приложения
                          wfe-webservice-client	нет	нет	 ?	Авто-генерации клиентской библиотеки на основе WSDL серверных сервисов. В нем же есть примеры использования веб-служб из Java клиента.
                          # Описание слоев архитектуры системы
                          Каждый компонент состоит из нескольких уровней (слоев).

                          Список слоев:

                          delegate
                          service
                          logic
                          DAO
                          hibernate
                          # Слой Delegate
                          Delegate-классы, реализующие сервисные интерфейсы представляют собой pattern проектирования BusinessDelegate, упрощающий доступ к серверному API системы. Клиентское приложение взаимодействует с системой только через Delegate-классы. Delegate-классы получаются посредством запроса фабрики Delegates, которая в зависимости от конфигурации возвращает нужную реализацию. Классы Delegate являются частью клиентского API.

                          Список основных Delegate-классов:

                          AuthenticationServiceDelegate – содержит методы для аутентификации пользователей в системе (с использованием логина/пароля, Kerberos и т.п.)
                          AuthorizationServiceDelegate — содержит методы для работы с полномочиями пользователей (назначение полномочий, проверка на допустимость операции для пользователя и т.п.)
                          BotServiceDelegate — содержит методы для работы с бот станциями и ботами
                          ExecutorServiceDelegate — содержит методы для работы с исполнителями. Позволяет создавать/удалять/изменять исполнителей а так же включать их в группы
                          ProfileServiceDelegate — содержит методы для работы с профайлам пользователей
                          SubstitutionServiceDelegate — содержит методы для управления правилами замещения
                          SystemServiceDelegate — содержит методы для входа/выхода пользователя в систему
                          DefinitionServiceDelegate — содержит методы для работы с определениями процессов
                          ExecutionServiceDelegate — содержит методы для работы с исполняемыми экземплярами процессов
                          Все существующие в данный момент Delegate-классы реализуют требуемую функциональность при помощи технологии EJB.

                          # Слой Service
                          Слой service – это серверное API доступа к системе. Реализации Delegate интерфейсов обращаются именно к этому слою. Каждый Delegate работает с одним соответствующим классом Service. В настоящее время все разработанные service классы и интерфейсы ориентированы на EJB-технологию, однако в будущем возможны и другие реализации. Реализации классов Service являются Stateless Session Bean EJB, которые декларативно поддерживают транзакционность вызовов и запрашивают соответствующие классы из слоя Logic.

                          Таким образом, классы Delegate – Service - Logic образуют как бы «транспорт» между клиентом и сервером.

                          # Слой Logic
                          Слой Logic – это реализация бизнес логики работы системы. Слой работает с классами слоя DAO для доступа к постоянному хранилищу.

                          # Слой DAO
                          Слой DAO – это интерфейсы и классы, обеспечивающие доступ к данным, находящимся в постоянном хранилище (базе данных). В настоящее время все DAO-классы системы реализованы при помощи ORM-средства Hibernate.

                          # Использование Hibernate
                          Hibernate – ORM (Object/Relational Mapping) средство. Отображает объектную архитектуру на реляционную структуру данных. Допускает настройку (не меняя разработанного кода) на большинство существующих серверов реляционных баз данных.

                          Поддерживает работу с распределенными транзакциями, автоматически создает таблицы для новых классов и т.д. Вся работа с данными внутри системы ведется только через Hibernate.

                          Все компоненты, предоставляющие клиентское API построены с использованием описанных выше слоев. В целях оптимизации в некоторых компонентах применяется кеширование, которое может встречаться на уровне logic или DAO. Основная функциональность по управлению кешами находится в классах CachingLogic, CacheInterceptor и классах соответствующих кешей. Изменения в кешируемых объектах перехватываются и сообщаются посредством CachingLogic всем подписавшимся на изменения классам кешей. Транзакция, изменяющая кеш, считается закрытой по окончанию обработки ejb вызова.

                          # Обновление базы данных
                          см. описание системы патчей.

                          # API
                          Система представляет API для интеграции с другими системами:

                          # Java API
                          Реализация (снизу вверх): БД - Hibernate3 - EJB3

                          Документацию можно смотреть в исходном коде (javadocs в *Service.java).

                          # WebServices API
                          Реализация (снизу вверх): БД - Hibernate3 - JAX-WS

                          Документация: WebServicesDeveloperGuide

                          # Scripting API
                          Реализация (снизу вверх): БД - Hibernate3 - XML Script

                          Документация: AdminScriptGuide

                          # Процесс сборки из исходного кода
                          Исходный код системы доступен в открытом репозитории на github.

                          Сервер можно собирать как средствами maven используя командную строку, так и используя среду Eclipse IDE.

                          В результате сборки будет сформирован runawfe.ear, который теоретически можно запустить на любом сервере приложений. Начиная с версии 4.3.0 введена поддержка JAVA версии 8, и отказ от JAVA 6. В дальнейшем планируется отказ от java7, поэтому рекомендуется использовать сервер приложений wildfly.

                          # Процесс сборки на примере Eclipse IDE
                          # Необходимое программное обеспечение для сборки
                          В отличие от Среды разработки для сборки сервера можно использовать Eclipse IDE любой версии и редакции.

                          установите плагин m2eclipse
                          используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу: http://maven.apache.org/
                          добавьте путь к Apache Maven директории bin в переменную окружения Path
                          # Импорт проектов
                          Импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server.

                          Eclipse srv proj.png

                          # Установка maven артефактов
                          Выполните

                          ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                          ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                          или другим способом установите артефакты в локальный репозиторий

                          # Сборка
                          Заведите конфигурацию запуска на основе maven как показано на рисунке

                          Maven.build.configuration.png

                          Запустите конфигурацию.

                          Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\eclipse-workspace\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"

                          # Сборка из командной строки
                          используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу http://maven.apache.org/
                          добавьте путь к Apache Maven директории bin в переменную окружения Path
                          импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server
                          выполните обновление зависимостей
                          ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                          ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                          откройте командную строку
                          перейдите в директорию ${wfe}/wfe-app/
                          выполните команду для сборки
                          mvn clean package -Dmaven.test.skip=true
                          Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"


                          Для установки артефактов в локальный репозиторий используйте команду

                          mvn clean install -Dmaven.test.skip=true
                          # Использование ear на сервере приложений
                          cкачайте текущую версию RunaWFE в виде файл-архива исполняемых java файлов runawfe-wildfly-java8-*.zip (на базе wildfly, java8)
                          распакуйте архив
                          обновите runawfe.ear на версию полученную в результате сборки
                          # Расширение функциональности
                          # Точки расширения системы
                          Обработчики позволяют исполнить код в процессах (элементы "Обработчик", "Задача сценария") и ботах
                          Форматы переменных определяют тип переменных и правила преобразования значений к текстовому представлению и обратно
                          Организационные функции используются при назначении ролей и в правилах замещения для определения заместителя
                          Критерии замещения используются в подсистеме замещения для определения заместителя при построении списка заданий
                          Валидаторы обеспечивают проверку переменных при выполнении задания (в т.ч. введенные значения форм)
                          Freemarker теги форм генерируют html код для отображения на форме
                          Ajax команды предоставляют доступ к функциональности сервера из JavaScript
                          # Процесс разработки расширений
                          Создайте новый java-проект и подключите необходимые зависимости (wfe-core, wfe-service).

                          Реализуйте в нем требуемые расширения и соберите его в виде jar-файла.

                          Замечание. Использование maven облегчит процесс управления зависимостями.

                          Разместить собранный jar на сервере вы можете:

                          положив его в runawfe.ear!/lib
                          положив его в директорию deploy (только для jboss4)
                          положив его в ${jboss.server.base.dir}/wfe.custom (только для jboss7)
                          положив его в ${jboss.server.base.dir}/${jboss.server.name}/wfe.custom (только для jboss4)
                          # Обработчики
                          Обработчик в процессе – компонент процесса (элементы "Обработчик", "Задача сценария"), использующийся для выполнения каких-либо действий при возникновении определенных событий (проход по определенному переходу в процессе, приход или уход управления из узла и т.п.).

                          Обработчик должен реализовывать интерфейс ru.runa.wfe.extension.ActionHandler. Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов Spring контекста (например с помощью аннотации @Autowired).

                          При написании нового обработчика рекомендуется наследовать его от абстрактного класса ru.runa.wfe.extension.handler.CommonHandler или ru.runa.wfe.extension.handler.CommonParamBasedHandler. В методе setConfiguration обработчик должен запомнить свои параметры (если обработчик их ожидает), а в методе execute происходит непосредственная обработка и выполнение требуемых действий.

                          В случае, если при выполнении обработчика произошла ошибка, произойдет откат транзакции и состояние процесса будет возвращено к заданию, исполнение которого повлекло вызов обработчика. В интерфейсе обработчика для бота ru.runa.wfe.extension.TaskHandler предусмотрен метод onRollback для работы с не-транзакционными ресурсами.

                          Эти обработчики удобно использовать для простых операций (например для отправки оповещений в виде SMS-сообщений если процесс попал в определенное состояние). Но у них есть несколько ограничений. Прежде всего у них нет соответствующего объекта контекста безопасности (security context). Это означает, что в них нельзя выполнять защищенные методы (запуск процессов, выполнение задач, создание пользователей и т.п.) Ошибочным решением в них будет блокирование выполнения процесса (например с Thread::Sleep(...)). Например, если в обработчике отправляется e-mail, а SMTP сервер недоступен, обработчику нельзя "задерживать" свое выполнение.

                          Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                          # Специфика обработчиков для ботов
                          Бот - это сокращение от робот. В системе боты - это особый тип исполнителей. Система не отличает ботов от людей. У каждого бота есть свои права на вход в систему, он периодически просыпается, проверяет свой список задачи и выполняет обнаруженные там задачи.

                          Каждая задача бота обрабатывается при помощи соответствующего обработчика. Чтобы написать новый обработчик нужно реализовать интерфейс ru.runa.wfe.extension.TaskHandler.

                          Обратите внимание, что этот вид обработчиков выполняется в контексте безопасности (security context) пользователя-бота, и здесь может выполнятся любая операция (если у бота есть на это права).

                          Обработчики задач ботов могут блокировать выполнение процесса.

                          Например, обработчик задач, отправляющий e-mail может блокировать выполнение бизнес процесса до тех пор, пока обработчик не удостоверится, что SMTP сервер принял сообщение для последующей доставки.

                          Обработчики задач вызываются периодически, когда боты проверяют свои списки задач.

                          # Специфика обработчика для элемента ветвление
                          Обработчик для Decision является java-классом, реализующим интерфейс ru.runa.wfe.extension.DecisionHandler. Интерфейс содержит один метод decide(ExecutionContext executionContext), который возвращает имя выбранного перехода (одного из выходящих из данного ветвления). Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов контекста спринга (например с помощью аннотации @Autowired).

                          Обработчик принимает ExecutionContext в качестве входящего параметра и должен сделать выбор перехода исходя из значений переменных бизнес процесса и условий, указанных в конфигурации обработчика. Точно также как обработчики действия (action handler) обработчики выбора (decision handlers) не могут использовать защищенные (secured) методы, не могут обрабатывать ошибки и откладывать выбор перехода до лучших времен.

                          По умолчанию используется ru.runa.wfe.extension.decision.GroovyDecisionHandler.

                          # Использование ru.runa.wfe.extension.handler.CommonParamBasedHandler в качестве базового класса
                          Этот класс инкапсулирует в себе парсинг XML конфигурации определенного формата. Его удобно использовать если обработчик имеет фиксированное число параметров. Пример конфигурации:

                          <?xml version="1.0" encoding="UTF-8"?>
                          <config>
                           <input>
                             <param name="typeName" variable="тип отсутствия" />
                             <param name="employee" variable="сотрудник" />
                             <param name="requester" variable="подавший заявку" />
                             <param name="from" variable="дата с" />
                             <param name="to" variable="дата по" />
                             <param name="cause" variable="причина" />
                             <param name="comment" variable="комментарий" />
                             <param name="confirmation" variable="дата подтверждения" />
                             <param name="firmCode" value="111" />
                             <param name="firmPositionCode" variable="код должности" />
                             <param name="firmDepartmentCode" variable="код подразделения" />
                           </input>
                           <output>
                             <param name="uuid" variable="идентификатор объекта" />
                           </output>
                          </config>
                          Использование обработчика Groovy
                          См. соответствующий раздел в руководстве по работе с Groovy.

                          # Как написать функцию над организационной структурой
                          Функции над организационной структурой в системе применяются, например, при инициализации Ролей-Дорожек и в правилах замещения.

                          Класс, соответствующий функции над организационной структурой, должен реализовывать интерфейс ru.runa.wfe.extension.OrgFunction.

                          Интерфейс содержит один метод

                          List<? extends Executor> getExecutors(Object... parameters)
                          Этот метод должен возвращать список исполнителей.

                          В бизнес-процессе обработчик функции над оргструктурой используются при определении Ролей-Дорожек: указывается внутри тега swimlane, в теле тега <assignment>.В качестве параметра class тега <assignment> указывается класс-обработчик для инициализации swimlane: ru.runa.wfe.extension.AssignmentHandler. Внутри тега <assignment> содержится конфигурация для этого класса, которая представляет собой имя класса-наследника интерфейса OrgFunction и список параметров в скобках. В качестве параметра может выступать конкретное значение или имя переменной бизнес процесса в фигурных скобках, перед которым стоит значок $

                          Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                          Если есть планы по использованию функции в подсистеме замещений - её можно зарегистрировать в substitutions.xml.

                          # Как написать критерий замещения
                          Критерии замещения в системе применяются в правилах замещения. Класс, соответствующий критерию замещения, должен наследоваться от ru.runa.wfe.ss.SubstitutionCriteria.

                          Для создания на основе него конечных критериев замещения с конфигурациями - его нужно зарегистрировать в substitution.criterias.xml.

                          Как реализовать класс-формат для переменных бизнес-процесса
                          См. соответствующий раздел в руководстве по работе с переменными.

                          # Как реализовать валидатор переменных
                          Классы, расширяющие абстрактный класс ru.runa.wfe.validation.FieldValidator, в системе применяются для проверки переменных при выполнении задания или старте процесса.

                          Пример:

                          public class OvertimeWorkRequestTimeCheck extends FieldValidator {
                             @Override
                             public void validate() {
                                 Date date = (Date) getFieldValue();
                                 if (date == null) {
                                     return;
                                 }
                                 boolean testMode = getVariableProvider().getValueNotNull(boolean.class, "тестовый режим");
                                 if (testMode) {
                                     return;
                                 }
                                 Calendar calendar = CalendarUtil.dateToCalendar(date);
                                 if (calendar.before(Calendar.getInstance())) {
                                     addError("Заявка не может быть оформлена задним числом");
                                     return;
                                 }
                                 CalendarUtil.setTimeFromCalendar(calendar, DemoProperties.getOvertimeWorkRequestMaximumStartTime());
                                 Utils.adjustCalendarForHolidaysInOvertimwWork(calendar);
                                 if (calendar.before(Calendar.getInstance())) {
                                     addError("Заявка на этот день не может быть подана, время подачи истекло " + CalendarUtil.formatDateTime(calendar));
                                 }
                             }
                          }

                          Связь между Средой разработки и сервером осуществляется по имени валидатора, регистрация требуется на стороне сервера в файле validators.xml, а в среде разработки - в plugin.xml.

                          # Как реализовать FreeMarker тег для формы
                          FreemarkerForms#Components

                          # Как реализовать Ajax команду
                          Классы, расширяющие абстрактный класс ru.runa.wfe.commons.web.JsonAjaxCommand, (или реализующие ru.runa.wfe.commons.web.AjaxCommand) в системе применяются для доступа к функциональности сервера из JavaScript, например при отображении форм задания.

                          Регистрация команды происходит любым из двух способов:

                          в файле ajax.commands.xml, ей присваивается определенное имя
                          в контексте приложения, именем является id spring-бина
                          Затем по этому имени её можно выполнить используя JavaScript.

                          Пример команды

                          public class GetOrganizationNamesCommand extends JsonAjaxCommand {
                             @Autowired
                             private OrganizationDAO organizationDAO;
                             @Override
                             protected JSONAware execute(User user, HttpServletRequest request) throws Exception {
                                 String term = request.getParameter("term");
                                 if (term == null) {
                                     term = "";
                                 }
                                 List<Organization> organizations = organizationDAO.getAll();
                                 JSONArray array = new JSONArray();
                                 for (Organization organization : organizations) {
                                     if (organization.getName().startsWith(term)) {
                                         array.add(organization.getName());
                                     }
                                 }
                                 return array;
                             }
                          }
                          Регистрация в wfe.custom.ajax.commands.xml

                          <?xml version="1.0" encoding="UTF-8" ?>
                          <configuration xmlns="http://runa.ru/xml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://runa.ru/xml">
                           <command name="getOrganizationNames" class="ru.runa.rkdemo.web.ajax.GetOrganizationNamesCommand" />
                          </configuration>
                          Её использование со скрипта формы (autocomplete input)

                          $(document).ready(function() {
                           $('#editLinkedLists').on("onRowAdded", function(event, rowIndex) {
                            $("input[name='названия организаций["+rowIndex+"]']").autocomplete( {
                             delay: 300,
                             minLength: 0,
                             source: "/wfe/ajaxcmd?command=getOrganizationNames"
                            });
                            $("input[name='названия организаций["+rowIndex+"]']").focus(function() {
                             $(this).autocomplete("search", $(this).val());
                            });
                           });
                          });Введение
                             # Основные компоненты и используемые технологии
                             Для WF–системы была выбрана следующая общая архитектура (в целом соответствует архитектуре, предлагаемой коалицией WfMC):

                             Компоненты системы:

                             Ядро системы
                             Содержит набор определений бизнес-процессов
                             Содержит набор выполняющихся экземпляров бизнес–процессов
                             Компонент, "назначающий" исполнителей для действий
                             Клиент
                             Список заданий (набор графических форм, содержит очереди поступивших работ, сортировки и фильтры)
                             Проигрыватель форм (отображает формы, разработанные в Среде разработки)
                             Административный интерфейс
                             Показывает состояния процессов, позволяет фильтровать и останавливать процессы
                             Позволяет загружать-выгружать процессы
                             Позволяет заводить-удалять пользователей
                             Позволяет задавать различные права
                             Редактор назначения заместителей
                             Среда разработки
                             Конструктор графических форм
                             Бот станции, содержащие ботов (Боты - приложения специального вида, которые также как и обычные пользователи могут выполнять задания)
                             Подсистема управления правами доступа (авторизация и аутентификация)
                             # Платформа программирования и используемые программные средства
                             В качестве платформы программирования используется J2EE.

                             Используемые программные средства:

                             Сервер приложений - JBOSS (http://www.jboss.org).
                             Среда разработки - любая, например Eclipse от IBM (http://www.eclipse.org).
                             Система контроля версий - git
                             Сборщик приложений – maven.
                             Сервер баз данных – поддерживаются сервера БД:
                             MS SQL Server (http://www.microsoft.com/sql/evaluation/default.mspx)
                             HSQL (http://hsqldb.org)
                             Oracle (http://www.oracle.com)
                             PostgreSQL (http://postgresql.com)
                             Операционная система — поддерживаются следующие ОС:
                             Windows (Server 2000-2008, XP, Vista, 7)
                             ALTLinux
                             Mandriva Linux
                             Fedora
                             Debian/Ubuntu
                             # Описание проектов
                             Название проекта	Обязателен при сборке	Обязателен при работе	Зависимости	Описание
                             wfe-alfresco	нет	нет	runawfe-app	Интеграция с Alfresco
                             wfe-app	да	да	wfe-ear, wfe-cactus-it	Проект для организации сборки maven
                             wfe-appserver	нет	нет	 ?	Не используется
                             wfe-bots	да	да	wfe-service	Подсистема ботов
                             wfe-cactus-it	да	нет	wfe-service	Интеграционные тесты
                             wfe-core	да	да	-	Основные компоненты системы
                             wfe-ear	да	да	wfe-service, wfe-bots, wfe-office, wfe-web	Проект для сборки runawfe.ear
                             wfe-office	да	нет	wfe-core	Обработчики для работы с Word, Excel
                             wfe-service	да	да	wfe-core	Сервисы (EJB + WebServices), представляющие собой публичное API приложения
                             wfe-web	да	да	wfe-bots	Визуальная часть приложения
                             wfe-webservice-client	нет	нет	 ?	Авто-генерации клиентской библиотеки на основе WSDL серверных сервисов. В нем же есть примеры использования веб-служб из Java клиента.
                             # Описание слоев архитектуры системы
                             Каждый компонент состоит из нескольких уровней (слоев).

                             Список слоев:

                             delegate
                             service
                             logic
                             DAO
                             hibernate
                             # Слой Delegate
                             Delegate-классы, реализующие сервисные интерфейсы представляют собой pattern проектирования BusinessDelegate, упрощающий доступ к серверному API системы. Клиентское приложение взаимодействует с системой только через Delegate-классы. Delegate-классы получаются посредством запроса фабрики Delegates, которая в зависимости от конфигурации возвращает нужную реализацию. Классы Delegate являются частью клиентского API.

                             Список основных Delegate-классов:

                             AuthenticationServiceDelegate – содержит методы для аутентификации пользователей в системе (с использованием логина/пароля, Kerberos и т.п.)
                             AuthorizationServiceDelegate — содержит методы для работы с полномочиями пользователей (назначение полномочий, проверка на допустимость операции для пользователя и т.п.)
                             BotServiceDelegate — содержит методы для работы с бот станциями и ботами
                             ExecutorServiceDelegate — содержит методы для работы с исполнителями. Позволяет создавать/удалять/изменять исполнителей а так же включать их в группы
                             ProfileServiceDelegate — содержит методы для работы с профайлам пользователей
                             SubstitutionServiceDelegate — содержит методы для управления правилами замещения
                             SystemServiceDelegate — содержит методы для входа/выхода пользователя в систему
                             DefinitionServiceDelegate — содержит методы для работы с определениями процессов
                             ExecutionServiceDelegate — содержит методы для работы с исполняемыми экземплярами процессов
                             Все существующие в данный момент Delegate-классы реализуют требуемую функциональность при помощи технологии EJB.

                             # Слой Service
                             Слой service – это серверное API доступа к системе. Реализации Delegate интерфейсов обращаются именно к этому слою. Каждый Delegate работает с одним соответствующим классом Service. В настоящее время все разработанные service классы и интерфейсы ориентированы на EJB-технологию, однако в будущем возможны и другие реализации. Реализации классов Service являются Stateless Session Bean EJB, которые декларативно поддерживают транзакционность вызовов и запрашивают соответствующие классы из слоя Logic.

                             Таким образом, классы Delegate – Service - Logic образуют как бы «транспорт» между клиентом и сервером.

                             # Слой Logic
                             Слой Logic – это реализация бизнес логики работы системы. Слой работает с классами слоя DAO для доступа к постоянному хранилищу.

                             # Слой DAO
                             Слой DAO – это интерфейсы и классы, обеспечивающие доступ к данным, находящимся в постоянном хранилище (базе данных). В настоящее время все DAO-классы системы реализованы при помощи ORM-средства Hibernate.

                             # Использование Hibernate
                             Hibernate – ORM (Object/Relational Mapping) средство. Отображает объектную архитектуру на реляционную структуру данных. Допускает настройку (не меняя разработанного кода) на большинство существующих серверов реляционных баз данных.

                             Поддерживает работу с распределенными транзакциями, автоматически создает таблицы для новых классов и т.д. Вся работа с данными внутри системы ведется только через Hibernate.

                             Все компоненты, предоставляющие клиентское API построены с использованием описанных выше слоев. В целях оптимизации в некоторых компонентах применяется кеширование, которое может встречаться на уровне logic или DAO. Основная функциональность по управлению кешами находится в классах CachingLogic, CacheInterceptor и классах соответствующих кешей. Изменения в кешируемых объектах перехватываются и сообщаются посредством CachingLogic всем подписавшимся на изменения классам кешей. Транзакция, изменяющая кеш, считается закрытой по окончанию обработки ejb вызова.

                             # Обновление базы данных
                             см. описание системы патчей.

                             # API
                             Система представляет API для интеграции с другими системами:

                             # Java API
                             Реализация (снизу вверх): БД - Hibernate3 - EJB3

                             Документацию можно смотреть в исходном коде (javadocs в *Service.java).

                             # WebServices API
                             Реализация (снизу вверх): БД - Hibernate3 - JAX-WS

                             Документация: WebServicesDeveloperGuide

                             # Scripting API
                             Реализация (снизу вверх): БД - Hibernate3 - XML Script

                             Документация: AdminScriptGuide

                             # Процесс сборки из исходного кода
                             Исходный код системы доступен в открытом репозитории на github.

                             Сервер можно собирать как средствами maven используя командную строку, так и используя среду Eclipse IDE.

                             В результате сборки будет сформирован runawfe.ear, который теоретически можно запустить на любом сервере приложений. Начиная с версии 4.3.0 введена поддержка JAVA версии 8, и отказ от JAVA 6. В дальнейшем планируется отказ от java7, поэтому рекомендуется использовать сервер приложений wildfly.

                             # Процесс сборки на примере Eclipse IDE
                             # Необходимое программное обеспечение для сборки
                             В отличие от Среды разработки для сборки сервера можно использовать Eclipse IDE любой версии и редакции.

                             установите плагин m2eclipse
                             используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу: http://maven.apache.org/
                             добавьте путь к Apache Maven директории bin в переменную окружения Path
                             # Импорт проектов
                             Импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server.

                             Eclipse srv proj.png

                             # Установка maven артефактов
                             Выполните

                             ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                             ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                             или другим способом установите артефакты в локальный репозиторий

                             # Сборка
                             Заведите конфигурацию запуска на основе maven как показано на рисунке

                             Maven.build.configuration.png

                             Запустите конфигурацию.

                             Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\eclipse-workspace\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"

                             # Сборка из командной строки
                             используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу http://maven.apache.org/
                             добавьте путь к Apache Maven директории bin в переменную окружения Path
                             импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server
                             выполните обновление зависимостей
                             ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                             ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                             откройте командную строку
                             перейдите в директорию ${wfe}/wfe-app/
                             выполните команду для сборки
                             mvn clean package -Dmaven.test.skip=true
                             Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"


                             Для установки артефактов в локальный репозиторий используйте команду

                             mvn clean install -Dmaven.test.skip=true
                             # Использование ear на сервере приложений
                             cкачайте текущую версию RunaWFE в виде файл-архива исполняемых java файлов runawfe-wildfly-java8-*.zip (на базе wildfly, java8)
                             распакуйте архив
                             обновите runawfe.ear на версию полученную в результате сборки
                             # Расширение функциональности
                             # Точки расширения системы
                             Обработчики позволяют исполнить код в процессах (элементы "Обработчик", "Задача сценария") и ботах
                             Форматы переменных определяют тип переменных и правила преобразования значений к текстовому представлению и обратно
                             Организационные функции используются при назначении ролей и в правилах замещения для определения заместителя
                             Критерии замещения используются в подсистеме замещения для определения заместителя при построении списка заданий
                             Валидаторы обеспечивают проверку переменных при выполнении задания (в т.ч. введенные значения форм)
                             Freemarker теги форм генерируют html код для отображения на форме
                             Ajax команды предоставляют доступ к функциональности сервера из JavaScript
                             # Процесс разработки расширений
                             Создайте новый java-проект и подключите необходимые зависимости (wfe-core, wfe-service).

                             Реализуйте в нем требуемые расширения и соберите его в виде jar-файла.

                             Замечание. Использование maven облегчит процесс управления зависимостями.

                             Разместить собранный jar на сервере вы можете:

                             положив его в runawfe.ear!/lib
                             положив его в директорию deploy (только для jboss4)
                             положив его в ${jboss.server.base.dir}/wfe.custom (только для jboss7)
                             положив его в ${jboss.server.base.dir}/${jboss.server.name}/wfe.custom (только для jboss4)
                             # Обработчики
                             Обработчик в процессе – компонент процесса (элементы "Обработчик", "Задача сценария"), использующийся для выполнения каких-либо действий при возникновении определенных событий (проход по определенному переходу в процессе, приход или уход управления из узла и т.п.).

                             Обработчик должен реализовывать интерфейс ru.runa.wfe.extension.ActionHandler. Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов Spring контекста (например с помощью аннотации @Autowired).

                             При написании нового обработчика рекомендуется наследовать его от абстрактного класса ru.runa.wfe.extension.handler.CommonHandler или ru.runa.wfe.extension.handler.CommonParamBasedHandler. В методе setConfiguration обработчик должен запомнить свои параметры (если обработчик их ожидает), а в методе execute происходит непосредственная обработка и выполнение требуемых действий.

                             В случае, если при выполнении обработчика произошла ошибка, произойдет откат транзакции и состояние процесса будет возвращено к заданию, исполнение которого повлекло вызов обработчика. В интерфейсе обработчика для бота ru.runa.wfe.extension.TaskHandler предусмотрен метод onRollback для работы с не-транзакционными ресурсами.

                             Эти обработчики удобно использовать для простых операций (например для отправки оповещений в виде SMS-сообщений если процесс попал в определенное состояние). Но у них есть несколько ограничений. Прежде всего у них нет соответствующего объекта контекста безопасности (security context). Это означает, что в них нельзя выполнять защищенные методы (запуск процессов, выполнение задач, создание пользователей и т.п.) Ошибочным решением в них будет блокирование выполнения процесса (например с Thread::Sleep(...)). Например, если в обработчике отправляется e-mail, а SMTP сервер недоступен, обработчику нельзя "задерживать" свое выполнение.

                             Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                             # Специфика обработчиков для ботов
                             Бот - это сокращение от робот. В системе боты - это особый тип исполнителей. Система не отличает ботов от людей. У каждого бота есть свои права на вход в систему, он периодически просыпается, проверяет свой список задачи и выполняет обнаруженные там задачи.

                             Каждая задача бота обрабатывается при помощи соответствующего обработчика. Чтобы написать новый обработчик нужно реализовать интерфейс ru.runa.wfe.extension.TaskHandler.

                             Обратите внимание, что этот вид обработчиков выполняется в контексте безопасности (security context) пользователя-бота, и здесь может выполнятся любая операция (если у бота есть на это права).

                             Обработчики задач ботов могут блокировать выполнение процесса.

                             Например, обработчик задач, отправляющий e-mail может блокировать выполнение бизнес процесса до тех пор, пока обработчик не удостоверится, что SMTP сервер принял сообщение для последующей доставки.

                             Обработчики задач вызываются периодически, когда боты проверяют свои списки задач.

                             # Специфика обработчика для элемента ветвление
                             Обработчик для Decision является java-классом, реализующим интерфейс ru.runa.wfe.extension.DecisionHandler. Интерфейс содержит один метод decide(ExecutionContext executionContext), который возвращает имя выбранного перехода (одного из выходящих из данного ветвления). Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов контекста спринга (например с помощью аннотации @Autowired).

                             Обработчик принимает ExecutionContext в качестве входящего параметра и должен сделать выбор перехода исходя из значений переменных бизнес процесса и условий, указанных в конфигурации обработчика. Точно также как обработчики действия (action handler) обработчики выбора (decision handlers) не могут использовать защищенные (secured) методы, не могут обрабатывать ошибки и откладывать выбор перехода до лучших времен.

                             По умолчанию используется ru.runa.wfe.extension.decision.GroovyDecisionHandler.

                             # Использование ru.runa.wfe.extension.handler.CommonParamBasedHandler в качестве базового класса
                             Этот класс инкапсулирует в себе парсинг XML конфигурации определенного формата. Его удобно использовать если обработчик имеет фиксированное число параметров. Пример конфигурации:

                             <?xml version="1.0" encoding="UTF-8"?>
                             <config>
                              <input>
                                <param name="typeName" variable="тип отсутствия" />
                                <param name="employee" variable="сотрудник" />
                                <param name="requester" variable="подавший заявку" />
                                <param name="from" variable="дата с" />
                                <param name="to" variable="дата по" />
                                <param name="cause" variable="причина" />
                                <param name="comment" variable="комментарий" />
                                <param name="confirmation" variable="дата подтверждения" />
                                <param name="firmCode" value="111" />
                                <param name="firmPositionCode" variable="код должности" />
                                <param name="firmDepartmentCode" variable="код подразделения" />
                              </input>
                              <output>
                                <param name="uuid" variable="идентификатор объекта" />
                              </output>
                             </config>
                             Использование обработчика Groovy
                             См. соответствующий раздел в руководстве по работе с Groovy.

                             # Как написать функцию над организационной структурой
                             Функции над организационной структурой в системе применяются, например, при инициализации Ролей-Дорожек и в правилах замещения.

                             Класс, соответствующий функции над организационной структурой, должен реализовывать интерфейс ru.runa.wfe.extension.OrgFunction.

                             Интерфейс содержит один метод

                             List<? extends Executor> getExecutors(Object... parameters)
                             Этот метод должен возвращать список исполнителей.

                             В бизнес-процессе обработчик функции над оргструктурой используются при определении Ролей-Дорожек: указывается внутри тега swimlane, в теле тега <assignment>.В качестве параметра class тега <assignment> указывается класс-обработчик для инициализации swimlane: ru.runa.wfe.extension.AssignmentHandler. Внутри тега <assignment> содержится конфигурация для этого класса, которая представляет собой имя класса-наследника интерфейса OrgFunction и список параметров в скобках. В качестве параметра может выступать конкретное значение или имя переменной бизнес процесса в фигурных скобках, перед которым стоит значок $

                             Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                             Если есть планы по использованию функции в подсистеме замещений - её можно зарегистрировать в substitutions.xml.

                             # Как написать критерий замещения
                             Критерии замещения в системе применяются в правилах замещения. Класс, соответствующий критерию замещения, должен наследоваться от ru.runa.wfe.ss.SubstitutionCriteria.

                             Для создания на основе него конечных критериев замещения с конфигурациями - его нужно зарегистрировать в substitution.criterias.xml.

                             Как реализовать класс-формат для переменных бизнес-процесса
                             См. соответствующий раздел в руководстве по работе с переменными.

                             # Как реализовать валидатор переменных
                             Классы, расширяющие абстрактный класс ru.runa.wfe.validation.FieldValidator, в системе применяются для проверки переменных при выполнении задания или старте процесса.

                             Пример:

                             public class OvertimeWorkRequestTimeCheck extends FieldValidator {
                                @Override
                                public void validate() {
                                    Date date = (Date) getFieldValue();
                                    if (date == null) {
                                        return;
                                    }
                                    boolean testMode = getVariableProvider().getValueNotNull(boolean.class, "тестовый режим");
                                    if (testMode) {
                                        return;
                                    }
                                    Calendar calendar = CalendarUtil.dateToCalendar(date);
                                    if (calendar.before(Calendar.getInstance())) {
                                        addError("Заявка не может быть оформлена задним числом");
                                        return;
                                    }
                                    CalendarUtil.setTimeFromCalendar(calendar, DemoProperties.getOvertimeWorkRequestMaximumStartTime());
                                    Utils.adjustCalendarForHolidaysInOvertimwWork(calendar);
                                    if (calendar.before(Calendar.getInstance())) {
                                        addError("Заявка на этот день не может быть подана, время подачи истекло " + CalendarUtil.formatDateTime(calendar));
                                    }
                                }
                             }

                             Связь между Средой разработки и сервером осуществляется по имени валидатора, регистрация требуется на стороне сервера в файле validators.xml, а в среде разработки - в plugin.xml.

                             # Как реализовать FreeMarker тег для формы
                             FreemarkerForms#Components

                             # Как реализовать Ajax команду
                             Классы, расширяющие абстрактный класс ru.runa.wfe.commons.web.JsonAjaxCommand, (или реализующие ru.runa.wfe.commons.web.AjaxCommand) в системе применяются для доступа к функциональности сервера из JavaScript, например при отображении форм задания.

                             Регистрация команды происходит любым из двух способов:

                             в файле ajax.commands.xml, ей присваивается определенное имя
                             в контексте приложения, именем является id spring-бина
                             Затем по этому имени её можно выполнить используя JavaScript.

                             Пример команды

                             public class GetOrganizationNamesCommand extends JsonAjaxCommand {
                                @Autowired
                                private OrganizationDAO organizationDAO;
                                @Override
                                protected JSONAware execute(User user, HttpServletRequest request) throws Exception {
                                    String term = request.getParameter("term");
                                    if (term == null) {
                                        term = "";
                                    }
                                    List<Organization> organizations = organizationDAO.getAll();
                                    JSONArray array = new JSONArray();
                                    for (Organization organization : organizations) {
                                        if (organization.getName().startsWith(term)) {
                                            array.add(organization.getName());
                                        }
                                    }
                                    return array;
                                }
                             }
                             Регистрация в wfe.custom.ajax.commands.xml

                             <?xml version="1.0" encoding="UTF-8" ?>
                             <configuration xmlns="http://runa.ru/xml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://runa.ru/xml">
                              <command name="getOrganizationNames" class="ru.runa.rkdemo.web.ajax.GetOrganizationNamesCommand" />
                             </configuration>
                             Её использование со скрипта формы (autocomplete input)

                             $(document).ready(function() {
                              $('#editLinkedLists').on("onRowAdded", function(event, rowIndex) {
                               $("input[name='названия организаций["+rowIndex+"]']").autocomplete( {
                                delay: 300,
                                minLength: 0,
                                source: "/wfe/ajaxcmd?command=getOrganizationNames"
                               });
                               $("input[name='названия организаций["+rowIndex+"]']").focus(function() {
                                $(this).autocomplete("search", $(this).val());
                               });
                              });
                             });Введение
                                # Основные компоненты и используемые технологии
                                Для WF–системы была выбрана следующая общая архитектура (в целом соответствует архитектуре, предлагаемой коалицией WfMC):

                                Компоненты системы:

                                Ядро системы
                                Содержит набор определений бизнес-процессов
                                Содержит набор выполняющихся экземпляров бизнес–процессов
                                Компонент, "назначающий" исполнителей для действий
                                Клиент
                                Список заданий (набор графических форм, содержит очереди поступивших работ, сортировки и фильтры)
                                Проигрыватель форм (отображает формы, разработанные в Среде разработки)
                                Административный интерфейс
                                Показывает состояния процессов, позволяет фильтровать и останавливать процессы
                                Позволяет загружать-выгружать процессы
                                Позволяет заводить-удалять пользователей
                                Позволяет задавать различные права
                                Редактор назначения заместителей
                                Среда разработки
                                Конструктор графических форм
                                Бот станции, содержащие ботов (Боты - приложения специального вида, которые также как и обычные пользователи могут выполнять задания)
                                Подсистема управления правами доступа (авторизация и аутентификация)
                                # Платформа программирования и используемые программные средства
                                В качестве платформы программирования используется J2EE.

                                Используемые программные средства:

                                Сервер приложений - JBOSS (http://www.jboss.org).
                                Среда разработки - любая, например Eclipse от IBM (http://www.eclipse.org).
                                Система контроля версий - git
                                Сборщик приложений – maven.
                                Сервер баз данных – поддерживаются сервера БД:
                                MS SQL Server (http://www.microsoft.com/sql/evaluation/default.mspx)
                                HSQL (http://hsqldb.org)
                                Oracle (http://www.oracle.com)
                                PostgreSQL (http://postgresql.com)
                                Операционная система — поддерживаются следующие ОС:
                                Windows (Server 2000-2008, XP, Vista, 7)
                                ALTLinux
                                Mandriva Linux
                                Fedora
                                Debian/Ubuntu
                                # Описание проектов
                                Название проекта	Обязателен при сборке	Обязателен при работе	Зависимости	Описание
                                wfe-alfresco	нет	нет	runawfe-app	Интеграция с Alfresco
                                wfe-app	да	да	wfe-ear, wfe-cactus-it	Проект для организации сборки maven
                                wfe-appserver	нет	нет	 ?	Не используется
                                wfe-bots	да	да	wfe-service	Подсистема ботов
                                wfe-cactus-it	да	нет	wfe-service	Интеграционные тесты
                                wfe-core	да	да	-	Основные компоненты системы
                                wfe-ear	да	да	wfe-service, wfe-bots, wfe-office, wfe-web	Проект для сборки runawfe.ear
                                wfe-office	да	нет	wfe-core	Обработчики для работы с Word, Excel
                                wfe-service	да	да	wfe-core	Сервисы (EJB + WebServices), представляющие собой публичное API приложения
                                wfe-web	да	да	wfe-bots	Визуальная часть приложения
                                wfe-webservice-client	нет	нет	 ?	Авто-генерации клиентской библиотеки на основе WSDL серверных сервисов. В нем же есть примеры использования веб-служб из Java клиента.
                                # Описание слоев архитектуры системы
                                Каждый компонент состоит из нескольких уровней (слоев).

                                Список слоев:

                                delegate
                                service
                                logic
                                DAO
                                hibernate
                                # Слой Delegate
                                Delegate-классы, реализующие сервисные интерфейсы представляют собой pattern проектирования BusinessDelegate, упрощающий доступ к серверному API системы. Клиентское приложение взаимодействует с системой только через Delegate-классы. Delegate-классы получаются посредством запроса фабрики Delegates, которая в зависимости от конфигурации возвращает нужную реализацию. Классы Delegate являются частью клиентского API.

                                Список основных Delegate-классов:

                                AuthenticationServiceDelegate – содержит методы для аутентификации пользователей в системе (с использованием логина/пароля, Kerberos и т.п.)
                                AuthorizationServiceDelegate — содержит методы для работы с полномочиями пользователей (назначение полномочий, проверка на допустимость операции для пользователя и т.п.)
                                BotServiceDelegate — содержит методы для работы с бот станциями и ботами
                                ExecutorServiceDelegate — содержит методы для работы с исполнителями. Позволяет создавать/удалять/изменять исполнителей а так же включать их в группы
                                ProfileServiceDelegate — содержит методы для работы с профайлам пользователей
                                SubstitutionServiceDelegate — содержит методы для управления правилами замещения
                                SystemServiceDelegate — содержит методы для входа/выхода пользователя в систему
                                DefinitionServiceDelegate — содержит методы для работы с определениями процессов
                                ExecutionServiceDelegate — содержит методы для работы с исполняемыми экземплярами процессов
                                Все существующие в данный момент Delegate-классы реализуют требуемую функциональность при помощи технологии EJB.

                                # Слой Service
                                Слой service – это серверное API доступа к системе. Реализации Delegate интерфейсов обращаются именно к этому слою. Каждый Delegate работает с одним соответствующим классом Service. В настоящее время все разработанные service классы и интерфейсы ориентированы на EJB-технологию, однако в будущем возможны и другие реализации. Реализации классов Service являются Stateless Session Bean EJB, которые декларативно поддерживают транзакционность вызовов и запрашивают соответствующие классы из слоя Logic.

                                Таким образом, классы Delegate – Service - Logic образуют как бы «транспорт» между клиентом и сервером.

                                # Слой Logic
                                Слой Logic – это реализация бизнес логики работы системы. Слой работает с классами слоя DAO для доступа к постоянному хранилищу.

                                # Слой DAO
                                Слой DAO – это интерфейсы и классы, обеспечивающие доступ к данным, находящимся в постоянном хранилище (базе данных). В настоящее время все DAO-классы системы реализованы при помощи ORM-средства Hibernate.

                                # Использование Hibernate
                                Hibernate – ORM (Object/Relational Mapping) средство. Отображает объектную архитектуру на реляционную структуру данных. Допускает настройку (не меняя разработанного кода) на большинство существующих серверов реляционных баз данных.

                                Поддерживает работу с распределенными транзакциями, автоматически создает таблицы для новых классов и т.д. Вся работа с данными внутри системы ведется только через Hibernate.

                                Все компоненты, предоставляющие клиентское API построены с использованием описанных выше слоев. В целях оптимизации в некоторых компонентах применяется кеширование, которое может встречаться на уровне logic или DAO. Основная функциональность по управлению кешами находится в классах CachingLogic, CacheInterceptor и классах соответствующих кешей. Изменения в кешируемых объектах перехватываются и сообщаются посредством CachingLogic всем подписавшимся на изменения классам кешей. Транзакция, изменяющая кеш, считается закрытой по окончанию обработки ejb вызова.

                                # Обновление базы данных
                                см. описание системы патчей.

                                # API
                                Система представляет API для интеграции с другими системами:

                                # Java API
                                Реализация (снизу вверх): БД - Hibernate3 - EJB3

                                Документацию можно смотреть в исходном коде (javadocs в *Service.java).

                                # WebServices API
                                Реализация (снизу вверх): БД - Hibernate3 - JAX-WS

                                Документация: WebServicesDeveloperGuide

                                # Scripting API
                                Реализация (снизу вверх): БД - Hibernate3 - XML Script

                                Документация: AdminScriptGuide

                                # Процесс сборки из исходного кода
                                Исходный код системы доступен в открытом репозитории на github.

                                Сервер можно собирать как средствами maven используя командную строку, так и используя среду Eclipse IDE.

                                В результате сборки будет сформирован runawfe.ear, который теоретически можно запустить на любом сервере приложений. Начиная с версии 4.3.0 введена поддержка JAVA версии 8, и отказ от JAVA 6. В дальнейшем планируется отказ от java7, поэтому рекомендуется использовать сервер приложений wildfly.

                                # Процесс сборки на примере Eclipse IDE
                                # Необходимое программное обеспечение для сборки
                                В отличие от Среды разработки для сборки сервера можно использовать Eclipse IDE любой версии и редакции.

                                установите плагин m2eclipse
                                используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу: http://maven.apache.org/
                                добавьте путь к Apache Maven директории bin в переменную окружения Path
                                # Импорт проектов
                                Импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server.

                                Eclipse srv proj.png

                                # Установка maven артефактов
                                Выполните

                                ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                                ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                                или другим способом установите артефакты в локальный репозиторий

                                # Сборка
                                Заведите конфигурацию запуска на основе maven как показано на рисунке

                                Maven.build.configuration.png

                                Запустите конфигурацию.

                                Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\eclipse-workspace\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"

                                # Сборка из командной строки
                                используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу http://maven.apache.org/
                                добавьте путь к Apache Maven директории bin в переменную окружения Path
                                импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server
                                выполните обновление зависимостей
                                ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                                ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                                откройте командную строку
                                перейдите в директорию ${wfe}/wfe-app/
                                выполните команду для сборки
                                mvn clean package -Dmaven.test.skip=true
                                Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"


                                Для установки артефактов в локальный репозиторий используйте команду

                                mvn clean install -Dmaven.test.skip=true
                                # Использование ear на сервере приложений
                                cкачайте текущую версию RunaWFE в виде файл-архива исполняемых java файлов runawfe-wildfly-java8-*.zip (на базе wildfly, java8)
                                распакуйте архив
                                обновите runawfe.ear на версию полученную в результате сборки
                                # Расширение функциональности
                                # Точки расширения системы
                                Обработчики позволяют исполнить код в процессах (элементы "Обработчик", "Задача сценария") и ботах
                                Форматы переменных определяют тип переменных и правила преобразования значений к текстовому представлению и обратно
                                Организационные функции используются при назначении ролей и в правилах замещения для определения заместителя
                                Критерии замещения используются в подсистеме замещения для определения заместителя при построении списка заданий
                                Валидаторы обеспечивают проверку переменных при выполнении задания (в т.ч. введенные значения форм)
                                Freemarker теги форм генерируют html код для отображения на форме
                                Ajax команды предоставляют доступ к функциональности сервера из JavaScript
                                # Процесс разработки расширений
                                Создайте новый java-проект и подключите необходимые зависимости (wfe-core, wfe-service).

                                Реализуйте в нем требуемые расширения и соберите его в виде jar-файла.

                                Замечание. Использование maven облегчит процесс управления зависимостями.

                                Разместить собранный jar на сервере вы можете:

                                положив его в runawfe.ear!/lib
                                положив его в директорию deploy (только для jboss4)
                                положив его в ${jboss.server.base.dir}/wfe.custom (только для jboss7)
                                положив его в ${jboss.server.base.dir}/${jboss.server.name}/wfe.custom (только для jboss4)
                                # Обработчики
                                Обработчик в процессе – компонент процесса (элементы "Обработчик", "Задача сценария"), использующийся для выполнения каких-либо действий при возникновении определенных событий (проход по определенному переходу в процессе, приход или уход управления из узла и т.п.).

                                Обработчик должен реализовывать интерфейс ru.runa.wfe.extension.ActionHandler. Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов Spring контекста (например с помощью аннотации @Autowired).

                                При написании нового обработчика рекомендуется наследовать его от абстрактного класса ru.runa.wfe.extension.handler.CommonHandler или ru.runa.wfe.extension.handler.CommonParamBasedHandler. В методе setConfiguration обработчик должен запомнить свои параметры (если обработчик их ожидает), а в методе execute происходит непосредственная обработка и выполнение требуемых действий.

                                В случае, если при выполнении обработчика произошла ошибка, произойдет откат транзакции и состояние процесса будет возвращено к заданию, исполнение которого повлекло вызов обработчика. В интерфейсе обработчика для бота ru.runa.wfe.extension.TaskHandler предусмотрен метод onRollback для работы с не-транзакционными ресурсами.

                                Эти обработчики удобно использовать для простых операций (например для отправки оповещений в виде SMS-сообщений если процесс попал в определенное состояние). Но у них есть несколько ограничений. Прежде всего у них нет соответствующего объекта контекста безопасности (security context). Это означает, что в них нельзя выполнять защищенные методы (запуск процессов, выполнение задач, создание пользователей и т.п.) Ошибочным решением в них будет блокирование выполнения процесса (например с Thread::Sleep(...)). Например, если в обработчике отправляется e-mail, а SMTP сервер недоступен, обработчику нельзя "задерживать" свое выполнение.

                                Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                                # Специфика обработчиков для ботов
                                Бот - это сокращение от робот. В системе боты - это особый тип исполнителей. Система не отличает ботов от людей. У каждого бота есть свои права на вход в систему, он периодически просыпается, проверяет свой список задачи и выполняет обнаруженные там задачи.

                                Каждая задача бота обрабатывается при помощи соответствующего обработчика. Чтобы написать новый обработчик нужно реализовать интерфейс ru.runa.wfe.extension.TaskHandler.

                                Обратите внимание, что этот вид обработчиков выполняется в контексте безопасности (security context) пользователя-бота, и здесь может выполнятся любая операция (если у бота есть на это права).

                                Обработчики задач ботов могут блокировать выполнение процесса.

                                Например, обработчик задач, отправляющий e-mail может блокировать выполнение бизнес процесса до тех пор, пока обработчик не удостоверится, что SMTP сервер принял сообщение для последующей доставки.

                                Обработчики задач вызываются периодически, когда боты проверяют свои списки задач.

                                # Специфика обработчика для элемента ветвление
                                Обработчик для Decision является java-классом, реализующим интерфейс ru.runa.wfe.extension.DecisionHandler. Интерфейс содержит один метод decide(ExecutionContext executionContext), который возвращает имя выбранного перехода (одного из выходящих из данного ветвления). Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов контекста спринга (например с помощью аннотации @Autowired).

                                Обработчик принимает ExecutionContext в качестве входящего параметра и должен сделать выбор перехода исходя из значений переменных бизнес процесса и условий, указанных в конфигурации обработчика. Точно также как обработчики действия (action handler) обработчики выбора (decision handlers) не могут использовать защищенные (secured) методы, не могут обрабатывать ошибки и откладывать выбор перехода до лучших времен.

                                По умолчанию используется ru.runa.wfe.extension.decision.GroovyDecisionHandler.

                                # Использование ru.runa.wfe.extension.handler.CommonParamBasedHandler в качестве базового класса
                                Этот класс инкапсулирует в себе парсинг XML конфигурации определенного формата. Его удобно использовать если обработчик имеет фиксированное число параметров. Пример конфигурации:

                                <?xml version="1.0" encoding="UTF-8"?>
                                <config>
                                 <input>
                                   <param name="typeName" variable="тип отсутствия" />
                                   <param name="employee" variable="сотрудник" />
                                   <param name="requester" variable="подавший заявку" />
                                   <param name="from" variable="дата с" />
                                   <param name="to" variable="дата по" />
                                   <param name="cause" variable="причина" />
                                   <param name="comment" variable="комментарий" />
                                   <param name="confirmation" variable="дата подтверждения" />
                                   <param name="firmCode" value="111" />
                                   <param name="firmPositionCode" variable="код должности" />
                                   <param name="firmDepartmentCode" variable="код подразделения" />
                                 </input>
                                 <output>
                                   <param name="uuid" variable="идентификатор объекта" />
                                 </output>
                                </config>
                                Использование обработчика Groovy
                                См. соответствующий раздел в руководстве по работе с Groovy.

                                # Как написать функцию над организационной структурой
                                Функции над организационной структурой в системе применяются, например, при инициализации Ролей-Дорожек и в правилах замещения.

                                Класс, соответствующий функции над организационной структурой, должен реализовывать интерфейс ru.runa.wfe.extension.OrgFunction.

                                Интерфейс содержит один метод

                                List<? extends Executor> getExecutors(Object... parameters)
                                Этот метод должен возвращать список исполнителей.

                                В бизнес-процессе обработчик функции над оргструктурой используются при определении Ролей-Дорожек: указывается внутри тега swimlane, в теле тега <assignment>.В качестве параметра class тега <assignment> указывается класс-обработчик для инициализации swimlane: ru.runa.wfe.extension.AssignmentHandler. Внутри тега <assignment> содержится конфигурация для этого класса, которая представляет собой имя класса-наследника интерфейса OrgFunction и список параметров в скобках. В качестве параметра может выступать конкретное значение или имя переменной бизнес процесса в фигурных скобках, перед которым стоит значок $

                                Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                                Если есть планы по использованию функции в подсистеме замещений - её можно зарегистрировать в substitutions.xml.

                                # Как написать критерий замещения
                                Критерии замещения в системе применяются в правилах замещения. Класс, соответствующий критерию замещения, должен наследоваться от ru.runa.wfe.ss.SubstitutionCriteria.

                                Для создания на основе него конечных критериев замещения с конфигурациями - его нужно зарегистрировать в substitution.criterias.xml.

                                Как реализовать класс-формат для переменных бизнес-процесса
                                См. соответствующий раздел в руководстве по работе с переменными.

                                # Как реализовать валидатор переменных
                                Классы, расширяющие абстрактный класс ru.runa.wfe.validation.FieldValidator, в системе применяются для проверки переменных при выполнении задания или старте процесса.

                                Пример:

                                public class OvertimeWorkRequestTimeCheck extends FieldValidator {
                                   @Override
                                   public void validate() {
                                       Date date = (Date) getFieldValue();
                                       if (date == null) {
                                           return;
                                       }
                                       boolean testMode = getVariableProvider().getValueNotNull(boolean.class, "тестовый режим");
                                       if (testMode) {
                                           return;
                                       }
                                       Calendar calendar = CalendarUtil.dateToCalendar(date);
                                       if (calendar.before(Calendar.getInstance())) {
                                           addError("Заявка не может быть оформлена задним числом");
                                           return;
                                       }
                                       CalendarUtil.setTimeFromCalendar(calendar, DemoProperties.getOvertimeWorkRequestMaximumStartTime());
                                       Utils.adjustCalendarForHolidaysInOvertimwWork(calendar);
                                       if (calendar.before(Calendar.getInstance())) {
                                           addError("Заявка на этот день не может быть подана, время подачи истекло " + CalendarUtil.formatDateTime(calendar));
                                       }
                                   }
                                }

                                Связь между Средой разработки и сервером осуществляется по имени валидатора, регистрация требуется на стороне сервера в файле validators.xml, а в среде разработки - в plugin.xml.

                                # Как реализовать FreeMarker тег для формы
                                FreemarkerForms#Components

                                # Как реализовать Ajax команду
                                Классы, расширяющие абстрактный класс ru.runa.wfe.commons.web.JsonAjaxCommand, (или реализующие ru.runa.wfe.commons.web.AjaxCommand) в системе применяются для доступа к функциональности сервера из JavaScript, например при отображении форм задания.

                                Регистрация команды происходит любым из двух способов:

                                в файле ajax.commands.xml, ей присваивается определенное имя
                                в контексте приложения, именем является id spring-бина
                                Затем по этому имени её можно выполнить используя JavaScript.

                                Пример команды

                                public class GetOrganizationNamesCommand extends JsonAjaxCommand {
                                   @Autowired
                                   private OrganizationDAO organizationDAO;
                                   @Override
                                   protected JSONAware execute(User user, HttpServletRequest request) throws Exception {
                                       String term = request.getParameter("term");
                                       if (term == null) {
                                           term = "";
                                       }
                                       List<Organization> organizations = organizationDAO.getAll();
                                       JSONArray array = new JSONArray();
                                       for (Organization organization : organizations) {
                                           if (organization.getName().startsWith(term)) {
                                               array.add(organization.getName());
                                           }
                                       }
                                       return array;
                                   }
                                }
                                Регистрация в wfe.custom.ajax.commands.xml

                                <?xml version="1.0" encoding="UTF-8" ?>
                                <configuration xmlns="http://runa.ru/xml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://runa.ru/xml">
                                 <command name="getOrganizationNames" class="ru.runa.rkdemo.web.ajax.GetOrganizationNamesCommand" />
                                </configuration>
                                Её использование со скрипта формы (autocomplete input)

                                $(document).ready(function() {
                                 $('#editLinkedLists').on("onRowAdded", function(event, rowIndex) {
                                  $("input[name='названия организаций["+rowIndex+"]']").autocomplete( {
                                   delay: 300,
                                   minLength: 0,
                                   source: "/wfe/ajaxcmd?command=getOrganizationNames"
                                  });
                                  $("input[name='названия организаций["+rowIndex+"]']").focus(function() {
                                   $(this).autocomplete("search", $(this).val());
                                  });
                                 });
                                });Введение
                                   # Основные компоненты и используемые технологии
                                   Для WF–системы была выбрана следующая общая архитектура (в целом соответствует архитектуре, предлагаемой коалицией WfMC):

                                   Компоненты системы:

                                   Ядро системы
                                   Содержит набор определений бизнес-процессов
                                   Содержит набор выполняющихся экземпляров бизнес–процессов
                                   Компонент, "назначающий" исполнителей для действий
                                   Клиент
                                   Список заданий (набор графических форм, содержит очереди поступивших работ, сортировки и фильтры)
                                   Проигрыватель форм (отображает формы, разработанные в Среде разработки)
                                   Административный интерфейс
                                   Показывает состояния процессов, позволяет фильтровать и останавливать процессы
                                   Позволяет загружать-выгружать процессы
                                   Позволяет заводить-удалять пользователей
                                   Позволяет задавать различные права
                                   Редактор назначения заместителей
                                   Среда разработки
                                   Конструктор графических форм
                                   Бот станции, содержащие ботов (Боты - приложения специального вида, которые также как и обычные пользователи могут выполнять задания)
                                   Подсистема управления правами доступа (авторизация и аутентификация)
                                   # Платформа программирования и используемые программные средства
                                   В качестве платформы программирования используется J2EE.

                                   Используемые программные средства:

                                   Сервер приложений - JBOSS (http://www.jboss.org).
                                   Среда разработки - любая, например Eclipse от IBM (http://www.eclipse.org).
                                   Система контроля версий - git
                                   Сборщик приложений – maven.
                                   Сервер баз данных – поддерживаются сервера БД:
                                   MS SQL Server (http://www.microsoft.com/sql/evaluation/default.mspx)
                                   HSQL (http://hsqldb.org)
                                   Oracle (http://www.oracle.com)
                                   PostgreSQL (http://postgresql.com)
                                   Операционная система — поддерживаются следующие ОС:
                                   Windows (Server 2000-2008, XP, Vista, 7)
                                   ALTLinux
                                   Mandriva Linux
                                   Fedora
                                   Debian/Ubuntu
                                   # Описание проектов
                                   Название проекта	Обязателен при сборке	Обязателен при работе	Зависимости	Описание
                                   wfe-alfresco	нет	нет	runawfe-app	Интеграция с Alfresco
                                   wfe-app	да	да	wfe-ear, wfe-cactus-it	Проект для организации сборки maven
                                   wfe-appserver	нет	нет	 ?	Не используется
                                   wfe-bots	да	да	wfe-service	Подсистема ботов
                                   wfe-cactus-it	да	нет	wfe-service	Интеграционные тесты
                                   wfe-core	да	да	-	Основные компоненты системы
                                   wfe-ear	да	да	wfe-service, wfe-bots, wfe-office, wfe-web	Проект для сборки runawfe.ear
                                   wfe-office	да	нет	wfe-core	Обработчики для работы с Word, Excel
                                   wfe-service	да	да	wfe-core	Сервисы (EJB + WebServices), представляющие собой публичное API приложения
                                   wfe-web	да	да	wfe-bots	Визуальная часть приложения
                                   wfe-webservice-client	нет	нет	 ?	Авто-генерации клиентской библиотеки на основе WSDL серверных сервисов. В нем же есть примеры использования веб-служб из Java клиента.
                                   # Описание слоев архитектуры системы
                                   Каждый компонент состоит из нескольких уровней (слоев).

                                   Список слоев:

                                   delegate
                                   service
                                   logic
                                   DAO
                                   hibernate
                                   # Слой Delegate
                                   Delegate-классы, реализующие сервисные интерфейсы представляют собой pattern проектирования BusinessDelegate, упрощающий доступ к серверному API системы. Клиентское приложение взаимодействует с системой только через Delegate-классы. Delegate-классы получаются посредством запроса фабрики Delegates, которая в зависимости от конфигурации возвращает нужную реализацию. Классы Delegate являются частью клиентского API.

                                   Список основных Delegate-классов:

                                   AuthenticationServiceDelegate – содержит методы для аутентификации пользователей в системе (с использованием логина/пароля, Kerberos и т.п.)
                                   AuthorizationServiceDelegate — содержит методы для работы с полномочиями пользователей (назначение полномочий, проверка на допустимость операции для пользователя и т.п.)
                                   BotServiceDelegate — содержит методы для работы с бот станциями и ботами
                                   ExecutorServiceDelegate — содержит методы для работы с исполнителями. Позволяет создавать/удалять/изменять исполнителей а так же включать их в группы
                                   ProfileServiceDelegate — содержит методы для работы с профайлам пользователей
                                   SubstitutionServiceDelegate — содержит методы для управления правилами замещения
                                   SystemServiceDelegate — содержит методы для входа/выхода пользователя в систему
                                   DefinitionServiceDelegate — содержит методы для работы с определениями процессов
                                   ExecutionServiceDelegate — содержит методы для работы с исполняемыми экземплярами процессов
                                   Все существующие в данный момент Delegate-классы реализуют требуемую функциональность при помощи технологии EJB.

                                   # Слой Service
                                   Слой service – это серверное API доступа к системе. Реализации Delegate интерфейсов обращаются именно к этому слою. Каждый Delegate работает с одним соответствующим классом Service. В настоящее время все разработанные service классы и интерфейсы ориентированы на EJB-технологию, однако в будущем возможны и другие реализации. Реализации классов Service являются Stateless Session Bean EJB, которые декларативно поддерживают транзакционность вызовов и запрашивают соответствующие классы из слоя Logic.

                                   Таким образом, классы Delegate – Service - Logic образуют как бы «транспорт» между клиентом и сервером.

                                   # Слой Logic
                                   Слой Logic – это реализация бизнес логики работы системы. Слой работает с классами слоя DAO для доступа к постоянному хранилищу.

                                   # Слой DAO
                                   Слой DAO – это интерфейсы и классы, обеспечивающие доступ к данным, находящимся в постоянном хранилище (базе данных). В настоящее время все DAO-классы системы реализованы при помощи ORM-средства Hibernate.

                                   # Использование Hibernate
                                   Hibernate – ORM (Object/Relational Mapping) средство. Отображает объектную архитектуру на реляционную структуру данных. Допускает настройку (не меняя разработанного кода) на большинство существующих серверов реляционных баз данных.

                                   Поддерживает работу с распределенными транзакциями, автоматически создает таблицы для новых классов и т.д. Вся работа с данными внутри системы ведется только через Hibernate.

                                   Все компоненты, предоставляющие клиентское API построены с использованием описанных выше слоев. В целях оптимизации в некоторых компонентах применяется кеширование, которое может встречаться на уровне logic или DAO. Основная функциональность по управлению кешами находится в классах CachingLogic, CacheInterceptor и классах соответствующих кешей. Изменения в кешируемых объектах перехватываются и сообщаются посредством CachingLogic всем подписавшимся на изменения классам кешей. Транзакция, изменяющая кеш, считается закрытой по окончанию обработки ejb вызова.

                                   # Обновление базы данных
                                   см. описание системы патчей.

                                   # API
                                   Система представляет API для интеграции с другими системами:

                                   # Java API
                                   Реализация (снизу вверх): БД - Hibernate3 - EJB3

                                   Документацию можно смотреть в исходном коде (javadocs в *Service.java).

                                   # WebServices API
                                   Реализация (снизу вверх): БД - Hibernate3 - JAX-WS

                                   Документация: WebServicesDeveloperGuide

                                   # Scripting API
                                   Реализация (снизу вверх): БД - Hibernate3 - XML Script

                                   Документация: AdminScriptGuide

                                   # Процесс сборки из исходного кода
                                   Исходный код системы доступен в открытом репозитории на github.

                                   Сервер можно собирать как средствами maven используя командную строку, так и используя среду Eclipse IDE.

                                   В результате сборки будет сформирован runawfe.ear, который теоретически можно запустить на любом сервере приложений. Начиная с версии 4.3.0 введена поддержка JAVA версии 8, и отказ от JAVA 6. В дальнейшем планируется отказ от java7, поэтому рекомендуется использовать сервер приложений wildfly.

                                   # Процесс сборки на примере Eclipse IDE
                                   # Необходимое программное обеспечение для сборки
                                   В отличие от Среды разработки для сборки сервера можно использовать Eclipse IDE любой версии и редакции.

                                   установите плагин m2eclipse
                                   используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу: http://maven.apache.org/
                                   добавьте путь к Apache Maven директории bin в переменную окружения Path
                                   # Импорт проектов
                                   Импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server.

                                   Eclipse srv proj.png

                                   # Установка maven артефактов
                                   Выполните

                                   ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                                   ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                                   или другим способом установите артефакты в локальный репозиторий

                                   # Сборка
                                   Заведите конфигурацию запуска на основе maven как показано на рисунке

                                   Maven.build.configuration.png

                                   Запустите конфигурацию.

                                   Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\eclipse-workspace\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"

                                   # Сборка из командной строки
                                   используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу http://maven.apache.org/
                                   добавьте путь к Apache Maven директории bin в переменную окружения Path
                                   импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server
                                   выполните обновление зависимостей
                                   ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                                   ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                                   откройте командную строку
                                   перейдите в директорию ${wfe}/wfe-app/
                                   выполните команду для сборки
                                   mvn clean package -Dmaven.test.skip=true
                                   Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"


                                   Для установки артефактов в локальный репозиторий используйте команду

                                   mvn clean install -Dmaven.test.skip=true
                                   # Использование ear на сервере приложений
                                   cкачайте текущую версию RunaWFE в виде файл-архива исполняемых java файлов runawfe-wildfly-java8-*.zip (на базе wildfly, java8)
                                   распакуйте архив
                                   обновите runawfe.ear на версию полученную в результате сборки
                                   # Расширение функциональности
                                   # Точки расширения системы
                                   Обработчики позволяют исполнить код в процессах (элементы "Обработчик", "Задача сценария") и ботах
                                   Форматы переменных определяют тип переменных и правила преобразования значений к текстовому представлению и обратно
                                   Организационные функции используются при назначении ролей и в правилах замещения для определения заместителя
                                   Критерии замещения используются в подсистеме замещения для определения заместителя при построении списка заданий
                                   Валидаторы обеспечивают проверку переменных при выполнении задания (в т.ч. введенные значения форм)
                                   Freemarker теги форм генерируют html код для отображения на форме
                                   Ajax команды предоставляют доступ к функциональности сервера из JavaScript
                                   # Процесс разработки расширений
                                   Создайте новый java-проект и подключите необходимые зависимости (wfe-core, wfe-service).

                                   Реализуйте в нем требуемые расширения и соберите его в виде jar-файла.

                                   Замечание. Использование maven облегчит процесс управления зависимостями.

                                   Разместить собранный jar на сервере вы можете:

                                   положив его в runawfe.ear!/lib
                                   положив его в директорию deploy (только для jboss4)
                                   положив его в ${jboss.server.base.dir}/wfe.custom (только для jboss7)
                                   положив его в ${jboss.server.base.dir}/${jboss.server.name}/wfe.custom (только для jboss4)
                                   # Обработчики
                                   Обработчик в процессе – компонент процесса (элементы "Обработчик", "Задача сценария"), использующийся для выполнения каких-либо действий при возникновении определенных событий (проход по определенному переходу в процессе, приход или уход управления из узла и т.п.).

                                   Обработчик должен реализовывать интерфейс ru.runa.wfe.extension.ActionHandler. Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов Spring контекста (например с помощью аннотации @Autowired).

                                   При написании нового обработчика рекомендуется наследовать его от абстрактного класса ru.runa.wfe.extension.handler.CommonHandler или ru.runa.wfe.extension.handler.CommonParamBasedHandler. В методе setConfiguration обработчик должен запомнить свои параметры (если обработчик их ожидает), а в методе execute происходит непосредственная обработка и выполнение требуемых действий.

                                   В случае, если при выполнении обработчика произошла ошибка, произойдет откат транзакции и состояние процесса будет возвращено к заданию, исполнение которого повлекло вызов обработчика. В интерфейсе обработчика для бота ru.runa.wfe.extension.TaskHandler предусмотрен метод onRollback для работы с не-транзакционными ресурсами.

                                   Эти обработчики удобно использовать для простых операций (например для отправки оповещений в виде SMS-сообщений если процесс попал в определенное состояние). Но у них есть несколько ограничений. Прежде всего у них нет соответствующего объекта контекста безопасности (security context). Это означает, что в них нельзя выполнять защищенные методы (запуск процессов, выполнение задач, создание пользователей и т.п.) Ошибочным решением в них будет блокирование выполнения процесса (например с Thread::Sleep(...)). Например, если в обработчике отправляется e-mail, а SMTP сервер недоступен, обработчику нельзя "задерживать" свое выполнение.

                                   Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                                   # Специфика обработчиков для ботов
                                   Бот - это сокращение от робот. В системе боты - это особый тип исполнителей. Система не отличает ботов от людей. У каждого бота есть свои права на вход в систему, он периодически просыпается, проверяет свой список задачи и выполняет обнаруженные там задачи.

                                   Каждая задача бота обрабатывается при помощи соответствующего обработчика. Чтобы написать новый обработчик нужно реализовать интерфейс ru.runa.wfe.extension.TaskHandler.

                                   Обратите внимание, что этот вид обработчиков выполняется в контексте безопасности (security context) пользователя-бота, и здесь может выполнятся любая операция (если у бота есть на это права).

                                   Обработчики задач ботов могут блокировать выполнение процесса.

                                   Например, обработчик задач, отправляющий e-mail может блокировать выполнение бизнес процесса до тех пор, пока обработчик не удостоверится, что SMTP сервер принял сообщение для последующей доставки.

                                   Обработчики задач вызываются периодически, когда боты проверяют свои списки задач.

                                   # Специфика обработчика для элемента ветвление
                                   Обработчик для Decision является java-классом, реализующим интерфейс ru.runa.wfe.extension.DecisionHandler. Интерфейс содержит один метод decide(ExecutionContext executionContext), который возвращает имя выбранного перехода (одного из выходящих из данного ветвления). Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов контекста спринга (например с помощью аннотации @Autowired).

                                   Обработчик принимает ExecutionContext в качестве входящего параметра и должен сделать выбор перехода исходя из значений переменных бизнес процесса и условий, указанных в конфигурации обработчика. Точно также как обработчики действия (action handler) обработчики выбора (decision handlers) не могут использовать защищенные (secured) методы, не могут обрабатывать ошибки и откладывать выбор перехода до лучших времен.

                                   По умолчанию используется ru.runa.wfe.extension.decision.GroovyDecisionHandler.

                                   # Использование ru.runa.wfe.extension.handler.CommonParamBasedHandler в качестве базового класса
                                   Этот класс инкапсулирует в себе парсинг XML конфигурации определенного формата. Его удобно использовать если обработчик имеет фиксированное число параметров. Пример конфигурации:

                                   <?xml version="1.0" encoding="UTF-8"?>
                                   <config>
                                    <input>
                                      <param name="typeName" variable="тип отсутствия" />
                                      <param name="employee" variable="сотрудник" />
                                      <param name="requester" variable="подавший заявку" />
                                      <param name="from" variable="дата с" />
                                      <param name="to" variable="дата по" />
                                      <param name="cause" variable="причина" />
                                      <param name="comment" variable="комментарий" />
                                      <param name="confirmation" variable="дата подтверждения" />
                                      <param name="firmCode" value="111" />
                                      <param name="firmPositionCode" variable="код должности" />
                                      <param name="firmDepartmentCode" variable="код подразделения" />
                                    </input>
                                    <output>
                                      <param name="uuid" variable="идентификатор объекта" />
                                    </output>
                                   </config>
                                   Использование обработчика Groovy
                                   См. соответствующий раздел в руководстве по работе с Groovy.

                                   # Как написать функцию над организационной структурой
                                   Функции над организационной структурой в системе применяются, например, при инициализации Ролей-Дорожек и в правилах замещения.

                                   Класс, соответствующий функции над организационной структурой, должен реализовывать интерфейс ru.runa.wfe.extension.OrgFunction.

                                   Интерфейс содержит один метод

                                   List<? extends Executor> getExecutors(Object... parameters)
                                   Этот метод должен возвращать список исполнителей.

                                   В бизнес-процессе обработчик функции над оргструктурой используются при определении Ролей-Дорожек: указывается внутри тега swimlane, в теле тега <assignment>.В качестве параметра class тега <assignment> указывается класс-обработчик для инициализации swimlane: ru.runa.wfe.extension.AssignmentHandler. Внутри тега <assignment> содержится конфигурация для этого класса, которая представляет собой имя класса-наследника интерфейса OrgFunction и список параметров в скобках. В качестве параметра может выступать конкретное значение или имя переменной бизнес процесса в фигурных скобках, перед которым стоит значок $

                                   Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                                   Если есть планы по использованию функции в подсистеме замещений - её можно зарегистрировать в substitutions.xml.

                                   # Как написать критерий замещения
                                   Критерии замещения в системе применяются в правилах замещения. Класс, соответствующий критерию замещения, должен наследоваться от ru.runa.wfe.ss.SubstitutionCriteria.

                                   Для создания на основе него конечных критериев замещения с конфигурациями - его нужно зарегистрировать в substitution.criterias.xml.

                                   Как реализовать класс-формат для переменных бизнес-процесса
                                   См. соответствующий раздел в руководстве по работе с переменными.

                                   # Как реализовать валидатор переменных
                                   Классы, расширяющие абстрактный класс ru.runa.wfe.validation.FieldValidator, в системе применяются для проверки переменных при выполнении задания или старте процесса.

                                   Пример:

                                   public class OvertimeWorkRequestTimeCheck extends FieldValidator {
                                      @Override
                                      public void validate() {
                                          Date date = (Date) getFieldValue();
                                          if (date == null) {
                                              return;
                                          }
                                          boolean testMode = getVariableProvider().getValueNotNull(boolean.class, "тестовый режим");
                                          if (testMode) {
                                              return;
                                          }
                                          Calendar calendar = CalendarUtil.dateToCalendar(date);
                                          if (calendar.before(Calendar.getInstance())) {
                                              addError("Заявка не может быть оформлена задним числом");
                                              return;
                                          }
                                          CalendarUtil.setTimeFromCalendar(calendar, DemoProperties.getOvertimeWorkRequestMaximumStartTime());
                                          Utils.adjustCalendarForHolidaysInOvertimwWork(calendar);
                                          if (calendar.before(Calendar.getInstance())) {
                                              addError("Заявка на этот день не может быть подана, время подачи истекло " + CalendarUtil.formatDateTime(calendar));
                                          }
                                      }
                                   }

                                   Связь между Средой разработки и сервером осуществляется по имени валидатора, регистрация требуется на стороне сервера в файле validators.xml, а в среде разработки - в plugin.xml.

                                   # Как реализовать FreeMarker тег для формы
                                   FreemarkerForms#Components

                                   # Как реализовать Ajax команду
                                   Классы, расширяющие абстрактный класс ru.runa.wfe.commons.web.JsonAjaxCommand, (или реализующие ru.runa.wfe.commons.web.AjaxCommand) в системе применяются для доступа к функциональности сервера из JavaScript, например при отображении форм задания.

                                   Регистрация команды происходит любым из двух способов:

                                   в файле ajax.commands.xml, ей присваивается определенное имя
                                   в контексте приложения, именем является id spring-бина
                                   Затем по этому имени её можно выполнить используя JavaScript.

                                   Пример команды

                                   public class GetOrganizationNamesCommand extends JsonAjaxCommand {
                                      @Autowired
                                      private OrganizationDAO organizationDAO;
                                      @Override
                                      protected JSONAware execute(User user, HttpServletRequest request) throws Exception {
                                          String term = request.getParameter("term");
                                          if (term == null) {
                                              term = "";
                                          }
                                          List<Organization> organizations = organizationDAO.getAll();
                                          JSONArray array = new JSONArray();
                                          for (Organization organization : organizations) {
                                              if (organization.getName().startsWith(term)) {
                                                  array.add(organization.getName());
                                              }
                                          }
                                          return array;
                                      }
                                   }
                                   Регистрация в wfe.custom.ajax.commands.xml

                                   <?xml version="1.0" encoding="UTF-8" ?>
                                   <configuration xmlns="http://runa.ru/xml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://runa.ru/xml">
                                    <command name="getOrganizationNames" class="ru.runa.rkdemo.web.ajax.GetOrganizationNamesCommand" />
                                   </configuration>
                                   Её использование со скрипта формы (autocomplete input)

                                   $(document).ready(function() {
                                    $('#editLinkedLists').on("onRowAdded", function(event, rowIndex) {
                                     $("input[name='названия организаций["+rowIndex+"]']").autocomplete( {
                                      delay: 300,
                                      minLength: 0,
                                      source: "/wfe/ajaxcmd?command=getOrganizationNames"
                                     });
                                     $("input[name='названия организаций["+rowIndex+"]']").focus(function() {
                                      $(this).autocomplete("search", $(this).val());
                                     });
                                    });
                                   });Введение
                                      # Основные компоненты и используемые технологии
                                      Для WF–системы была выбрана следующая общая архитектура (в целом соответствует архитектуре, предлагаемой коалицией WfMC):

                                      Компоненты системы:

                                      Ядро системы
                                      Содержит набор определений бизнес-процессов
                                      Содержит набор выполняющихся экземпляров бизнес–процессов
                                      Компонент, "назначающий" исполнителей для действий
                                      Клиент
                                      Список заданий (набор графических форм, содержит очереди поступивших работ, сортировки и фильтры)
                                      Проигрыватель форм (отображает формы, разработанные в Среде разработки)
                                      Административный интерфейс
                                      Показывает состояния процессов, позволяет фильтровать и останавливать процессы
                                      Позволяет загружать-выгружать процессы
                                      Позволяет заводить-удалять пользователей
                                      Позволяет задавать различные права
                                      Редактор назначения заместителей
                                      Среда разработки
                                      Конструктор графических форм
                                      Бот станции, содержащие ботов (Боты - приложения специального вида, которые также как и обычные пользователи могут выполнять задания)
                                      Подсистема управления правами доступа (авторизация и аутентификация)
                                      # Платформа программирования и используемые программные средства
                                      В качестве платформы программирования используется J2EE.

                                      Используемые программные средства:

                                      Сервер приложений - JBOSS (http://www.jboss.org).
                                      Среда разработки - любая, например Eclipse от IBM (http://www.eclipse.org).
                                      Система контроля версий - git
                                      Сборщик приложений – maven.
                                      Сервер баз данных – поддерживаются сервера БД:
                                      MS SQL Server (http://www.microsoft.com/sql/evaluation/default.mspx)
                                      HSQL (http://hsqldb.org)
                                      Oracle (http://www.oracle.com)
                                      PostgreSQL (http://postgresql.com)
                                      Операционная система — поддерживаются следующие ОС:
                                      Windows (Server 2000-2008, XP, Vista, 7)
                                      ALTLinux
                                      Mandriva Linux
                                      Fedora
                                      Debian/Ubuntu
                                      # Описание проектов
                                      Название проекта	Обязателен при сборке	Обязателен при работе	Зависимости	Описание
                                      wfe-alfresco	нет	нет	runawfe-app	Интеграция с Alfresco
                                      wfe-app	да	да	wfe-ear, wfe-cactus-it	Проект для организации сборки maven
                                      wfe-appserver	нет	нет	 ?	Не используется
                                      wfe-bots	да	да	wfe-service	Подсистема ботов
                                      wfe-cactus-it	да	нет	wfe-service	Интеграционные тесты
                                      wfe-core	да	да	-	Основные компоненты системы
                                      wfe-ear	да	да	wfe-service, wfe-bots, wfe-office, wfe-web	Проект для сборки runawfe.ear
                                      wfe-office	да	нет	wfe-core	Обработчики для работы с Word, Excel
                                      wfe-service	да	да	wfe-core	Сервисы (EJB + WebServices), представляющие собой публичное API приложения
                                      wfe-web	да	да	wfe-bots	Визуальная часть приложения
                                      wfe-webservice-client	нет	нет	 ?	Авто-генерации клиентской библиотеки на основе WSDL серверных сервисов. В нем же есть примеры использования веб-служб из Java клиента.
                                      # Описание слоев архитектуры системы
                                      Каждый компонент состоит из нескольких уровней (слоев).

                                      Список слоев:

                                      delegate
                                      service
                                      logic
                                      DAO
                                      hibernate
                                      # Слой Delegate
                                      Delegate-классы, реализующие сервисные интерфейсы представляют собой pattern проектирования BusinessDelegate, упрощающий доступ к серверному API системы. Клиентское приложение взаимодействует с системой только через Delegate-классы. Delegate-классы получаются посредством запроса фабрики Delegates, которая в зависимости от конфигурации возвращает нужную реализацию. Классы Delegate являются частью клиентского API.

                                      Список основных Delegate-классов:

                                      AuthenticationServiceDelegate – содержит методы для аутентификации пользователей в системе (с использованием логина/пароля, Kerberos и т.п.)
                                      AuthorizationServiceDelegate — содержит методы для работы с полномочиями пользователей (назначение полномочий, проверка на допустимость операции для пользователя и т.п.)
                                      BotServiceDelegate — содержит методы для работы с бот станциями и ботами
                                      ExecutorServiceDelegate — содержит методы для работы с исполнителями. Позволяет создавать/удалять/изменять исполнителей а так же включать их в группы
                                      ProfileServiceDelegate — содержит методы для работы с профайлам пользователей
                                      SubstitutionServiceDelegate — содержит методы для управления правилами замещения
                                      SystemServiceDelegate — содержит методы для входа/выхода пользователя в систему
                                      DefinitionServiceDelegate — содержит методы для работы с определениями процессов
                                      ExecutionServiceDelegate — содержит методы для работы с исполняемыми экземплярами процессов
                                      Все существующие в данный момент Delegate-классы реализуют требуемую функциональность при помощи технологии EJB.

                                      # Слой Service
                                      Слой service – это серверное API доступа к системе. Реализации Delegate интерфейсов обращаются именно к этому слою. Каждый Delegate работает с одним соответствующим классом Service. В настоящее время все разработанные service классы и интерфейсы ориентированы на EJB-технологию, однако в будущем возможны и другие реализации. Реализации классов Service являются Stateless Session Bean EJB, которые декларативно поддерживают транзакционность вызовов и запрашивают соответствующие классы из слоя Logic.

                                      Таким образом, классы Delegate – Service - Logic образуют как бы «транспорт» между клиентом и сервером.

                                      # Слой Logic
                                      Слой Logic – это реализация бизнес логики работы системы. Слой работает с классами слоя DAO для доступа к постоянному хранилищу.

                                      # Слой DAO
                                      Слой DAO – это интерфейсы и классы, обеспечивающие доступ к данным, находящимся в постоянном хранилище (базе данных). В настоящее время все DAO-классы системы реализованы при помощи ORM-средства Hibernate.

                                      # Использование Hibernate
                                      Hibernate – ORM (Object/Relational Mapping) средство. Отображает объектную архитектуру на реляционную структуру данных. Допускает настройку (не меняя разработанного кода) на большинство существующих серверов реляционных баз данных.

                                      Поддерживает работу с распределенными транзакциями, автоматически создает таблицы для новых классов и т.д. Вся работа с данными внутри системы ведется только через Hibernate.

                                      Все компоненты, предоставляющие клиентское API построены с использованием описанных выше слоев. В целях оптимизации в некоторых компонентах применяется кеширование, которое может встречаться на уровне logic или DAO. Основная функциональность по управлению кешами находится в классах CachingLogic, CacheInterceptor и классах соответствующих кешей. Изменения в кешируемых объектах перехватываются и сообщаются посредством CachingLogic всем подписавшимся на изменения классам кешей. Транзакция, изменяющая кеш, считается закрытой по окончанию обработки ejb вызова.

                                      # Обновление базы данных
                                      см. описание системы патчей.

                                      # API
                                      Система представляет API для интеграции с другими системами:

                                      # Java API
                                      Реализация (снизу вверх): БД - Hibernate3 - EJB3

                                      Документацию можно смотреть в исходном коде (javadocs в *Service.java).

                                      # WebServices API
                                      Реализация (снизу вверх): БД - Hibernate3 - JAX-WS

                                      Документация: WebServicesDeveloperGuide

                                      # Scripting API
                                      Реализация (снизу вверх): БД - Hibernate3 - XML Script

                                      Документация: AdminScriptGuide

                                      # Процесс сборки из исходного кода
                                      Исходный код системы доступен в открытом репозитории на github.

                                      Сервер можно собирать как средствами maven используя командную строку, так и используя среду Eclipse IDE.

                                      В результате сборки будет сформирован runawfe.ear, который теоретически можно запустить на любом сервере приложений. Начиная с версии 4.3.0 введена поддержка JAVA версии 8, и отказ от JAVA 6. В дальнейшем планируется отказ от java7, поэтому рекомендуется использовать сервер приложений wildfly.

                                      # Процесс сборки на примере Eclipse IDE
                                      # Необходимое программное обеспечение для сборки
                                      В отличие от Среды разработки для сборки сервера можно использовать Eclipse IDE любой версии и редакции.

                                      установите плагин m2eclipse
                                      используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу: http://maven.apache.org/
                                      добавьте путь к Apache Maven директории bin в переменную окружения Path
                                      # Импорт проектов
                                      Импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server.

                                      Eclipse srv proj.png

                                      # Установка maven артефактов
                                      Выполните

                                      ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                                      ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                                      или другим способом установите артефакты в локальный репозиторий

                                      # Сборка
                                      Заведите конфигурацию запуска на основе maven как показано на рисунке

                                      Maven.build.configuration.png

                                      Запустите конфигурацию.

                                      Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\eclipse-workspace\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"

                                      # Сборка из командной строки
                                      используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу http://maven.apache.org/
                                      добавьте путь к Apache Maven директории bin в переменную окружения Path
                                      импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server
                                      выполните обновление зависимостей
                                      ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                                      ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                                      откройте командную строку
                                      перейдите в директорию ${wfe}/wfe-app/
                                      выполните команду для сборки
                                      mvn clean package -Dmaven.test.skip=true
                                      Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"


                                      Для установки артефактов в локальный репозиторий используйте команду

                                      mvn clean install -Dmaven.test.skip=true
                                      # Использование ear на сервере приложений
                                      cкачайте текущую версию RunaWFE в виде файл-архива исполняемых java файлов runawfe-wildfly-java8-*.zip (на базе wildfly, java8)
                                      распакуйте архив
                                      обновите runawfe.ear на версию полученную в результате сборки
                                      # Расширение функциональности
                                      # Точки расширения системы
                                      Обработчики позволяют исполнить код в процессах (элементы "Обработчик", "Задача сценария") и ботах
                                      Форматы переменных определяют тип переменных и правила преобразования значений к текстовому представлению и обратно
                                      Организационные функции используются при назначении ролей и в правилах замещения для определения заместителя
                                      Критерии замещения используются в подсистеме замещения для определения заместителя при построении списка заданий
                                      Валидаторы обеспечивают проверку переменных при выполнении задания (в т.ч. введенные значения форм)
                                      Freemarker теги форм генерируют html код для отображения на форме
                                      Ajax команды предоставляют доступ к функциональности сервера из JavaScript
                                      # Процесс разработки расширений
                                      Создайте новый java-проект и подключите необходимые зависимости (wfe-core, wfe-service).

                                      Реализуйте в нем требуемые расширения и соберите его в виде jar-файла.

                                      Замечание. Использование maven облегчит процесс управления зависимостями.

                                      Разместить собранный jar на сервере вы можете:

                                      положив его в runawfe.ear!/lib
                                      положив его в директорию deploy (только для jboss4)
                                      положив его в ${jboss.server.base.dir}/wfe.custom (только для jboss7)
                                      положив его в ${jboss.server.base.dir}/${jboss.server.name}/wfe.custom (только для jboss4)
                                      # Обработчики
                                      Обработчик в процессе – компонент процесса (элементы "Обработчик", "Задача сценария"), использующийся для выполнения каких-либо действий при возникновении определенных событий (проход по определенному переходу в процессе, приход или уход управления из узла и т.п.).

                                      Обработчик должен реализовывать интерфейс ru.runa.wfe.extension.ActionHandler. Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов Spring контекста (например с помощью аннотации @Autowired).

                                      При написании нового обработчика рекомендуется наследовать его от абстрактного класса ru.runa.wfe.extension.handler.CommonHandler или ru.runa.wfe.extension.handler.CommonParamBasedHandler. В методе setConfiguration обработчик должен запомнить свои параметры (если обработчик их ожидает), а в методе execute происходит непосредственная обработка и выполнение требуемых действий.

                                      В случае, если при выполнении обработчика произошла ошибка, произойдет откат транзакции и состояние процесса будет возвращено к заданию, исполнение которого повлекло вызов обработчика. В интерфейсе обработчика для бота ru.runa.wfe.extension.TaskHandler предусмотрен метод onRollback для работы с не-транзакционными ресурсами.

                                      Эти обработчики удобно использовать для простых операций (например для отправки оповещений в виде SMS-сообщений если процесс попал в определенное состояние). Но у них есть несколько ограничений. Прежде всего у них нет соответствующего объекта контекста безопасности (security context). Это означает, что в них нельзя выполнять защищенные методы (запуск процессов, выполнение задач, создание пользователей и т.п.) Ошибочным решением в них будет блокирование выполнения процесса (например с Thread::Sleep(...)). Например, если в обработчике отправляется e-mail, а SMTP сервер недоступен, обработчику нельзя "задерживать" свое выполнение.

                                      Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                                      # Специфика обработчиков для ботов
                                      Бот - это сокращение от робот. В системе боты - это особый тип исполнителей. Система не отличает ботов от людей. У каждого бота есть свои права на вход в систему, он периодически просыпается, проверяет свой список задачи и выполняет обнаруженные там задачи.

                                      Каждая задача бота обрабатывается при помощи соответствующего обработчика. Чтобы написать новый обработчик нужно реализовать интерфейс ru.runa.wfe.extension.TaskHandler.

                                      Обратите внимание, что этот вид обработчиков выполняется в контексте безопасности (security context) пользователя-бота, и здесь может выполнятся любая операция (если у бота есть на это права).

                                      Обработчики задач ботов могут блокировать выполнение процесса.

                                      Например, обработчик задач, отправляющий e-mail может блокировать выполнение бизнес процесса до тех пор, пока обработчик не удостоверится, что SMTP сервер принял сообщение для последующей доставки.

                                      Обработчики задач вызываются периодически, когда боты проверяют свои списки задач.

                                      # Специфика обработчика для элемента ветвление
                                      Обработчик для Decision является java-классом, реализующим интерфейс ru.runa.wfe.extension.DecisionHandler. Интерфейс содержит один метод decide(ExecutionContext executionContext), который возвращает имя выбранного перехода (одного из выходящих из данного ветвления). Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов контекста спринга (например с помощью аннотации @Autowired).

                                      Обработчик принимает ExecutionContext в качестве входящего параметра и должен сделать выбор перехода исходя из значений переменных бизнес процесса и условий, указанных в конфигурации обработчика. Точно также как обработчики действия (action handler) обработчики выбора (decision handlers) не могут использовать защищенные (secured) методы, не могут обрабатывать ошибки и откладывать выбор перехода до лучших времен.

                                      По умолчанию используется ru.runa.wfe.extension.decision.GroovyDecisionHandler.

                                      # Использование ru.runa.wfe.extension.handler.CommonParamBasedHandler в качестве базового класса
                                      Этот класс инкапсулирует в себе парсинг XML конфигурации определенного формата. Его удобно использовать если обработчик имеет фиксированное число параметров. Пример конфигурации:

                                      <?xml version="1.0" encoding="UTF-8"?>
                                      <config>
                                       <input>
                                         <param name="typeName" variable="тип отсутствия" />
                                         <param name="employee" variable="сотрудник" />
                                         <param name="requester" variable="подавший заявку" />
                                         <param name="from" variable="дата с" />
                                         <param name="to" variable="дата по" />
                                         <param name="cause" variable="причина" />
                                         <param name="comment" variable="комментарий" />
                                         <param name="confirmation" variable="дата подтверждения" />
                                         <param name="firmCode" value="111" />
                                         <param name="firmPositionCode" variable="код должности" />
                                         <param name="firmDepartmentCode" variable="код подразделения" />
                                       </input>
                                       <output>
                                         <param name="uuid" variable="идентификатор объекта" />
                                       </output>
                                      </config>
                                      Использование обработчика Groovy
                                      См. соответствующий раздел в руководстве по работе с Groovy.

                                      # Как написать функцию над организационной структурой
                                      Функции над организационной структурой в системе применяются, например, при инициализации Ролей-Дорожек и в правилах замещения.

                                      Класс, соответствующий функции над организационной структурой, должен реализовывать интерфейс ru.runa.wfe.extension.OrgFunction.

                                      Интерфейс содержит один метод

                                      List<? extends Executor> getExecutors(Object... parameters)
                                      Этот метод должен возвращать список исполнителей.

                                      В бизнес-процессе обработчик функции над оргструктурой используются при определении Ролей-Дорожек: указывается внутри тега swimlane, в теле тега <assignment>.В качестве параметра class тега <assignment> указывается класс-обработчик для инициализации swimlane: ru.runa.wfe.extension.AssignmentHandler. Внутри тега <assignment> содержится конфигурация для этого класса, которая представляет собой имя класса-наследника интерфейса OrgFunction и список параметров в скобках. В качестве параметра может выступать конкретное значение или имя переменной бизнес процесса в фигурных скобках, перед которым стоит значок $

                                      Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                                      Если есть планы по использованию функции в подсистеме замещений - её можно зарегистрировать в substitutions.xml.

                                      # Как написать критерий замещения
                                      Критерии замещения в системе применяются в правилах замещения. Класс, соответствующий критерию замещения, должен наследоваться от ru.runa.wfe.ss.SubstitutionCriteria.

                                      Для создания на основе него конечных критериев замещения с конфигурациями - его нужно зарегистрировать в substitution.criterias.xml.

                                      Как реализовать класс-формат для переменных бизнес-процесса
                                      См. соответствующий раздел в руководстве по работе с переменными.

                                      # Как реализовать валидатор переменных
                                      Классы, расширяющие абстрактный класс ru.runa.wfe.validation.FieldValidator, в системе применяются для проверки переменных при выполнении задания или старте процесса.

                                      Пример:

                                      public class OvertimeWorkRequestTimeCheck extends FieldValidator {
                                         @Override
                                         public void validate() {
                                             Date date = (Date) getFieldValue();
                                             if (date == null) {
                                                 return;
                                             }
                                             boolean testMode = getVariableProvider().getValueNotNull(boolean.class, "тестовый режим");
                                             if (testMode) {
                                                 return;
                                             }
                                             Calendar calendar = CalendarUtil.dateToCalendar(date);
                                             if (calendar.before(Calendar.getInstance())) {
                                                 addError("Заявка не может быть оформлена задним числом");
                                                 return;
                                             }
                                             CalendarUtil.setTimeFromCalendar(calendar, DemoProperties.getOvertimeWorkRequestMaximumStartTime());
                                             Utils.adjustCalendarForHolidaysInOvertimwWork(calendar);
                                             if (calendar.before(Calendar.getInstance())) {
                                                 addError("Заявка на этот день не может быть подана, время подачи истекло " + CalendarUtil.formatDateTime(calendar));
                                             }
                                         }
                                      }

                                      Связь между Средой разработки и сервером осуществляется по имени валидатора, регистрация требуется на стороне сервера в файле validators.xml, а в среде разработки - в plugin.xml.

                                      # Как реализовать FreeMarker тег для формы
                                      FreemarkerForms#Components

                                      # Как реализовать Ajax команду
                                      Классы, расширяющие абстрактный класс ru.runa.wfe.commons.web.JsonAjaxCommand, (или реализующие ru.runa.wfe.commons.web.AjaxCommand) в системе применяются для доступа к функциональности сервера из JavaScript, например при отображении форм задания.

                                      Регистрация команды происходит любым из двух способов:

                                      в файле ajax.commands.xml, ей присваивается определенное имя
                                      в контексте приложения, именем является id spring-бина
                                      Затем по этому имени её можно выполнить используя JavaScript.

                                      Пример команды

                                      public class GetOrganizationNamesCommand extends JsonAjaxCommand {
                                         @Autowired
                                         private OrganizationDAO organizationDAO;
                                         @Override
                                         protected JSONAware execute(User user, HttpServletRequest request) throws Exception {
                                             String term = request.getParameter("term");
                                             if (term == null) {
                                                 term = "";
                                             }
                                             List<Organization> organizations = organizationDAO.getAll();
                                             JSONArray array = new JSONArray();
                                             for (Organization organization : organizations) {
                                                 if (organization.getName().startsWith(term)) {
                                                     array.add(organization.getName());
                                                 }
                                             }
                                             return array;
                                         }
                                      }
                                      Регистрация в wfe.custom.ajax.commands.xml

                                      <?xml version="1.0" encoding="UTF-8" ?>
                                      <configuration xmlns="http://runa.ru/xml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://runa.ru/xml">
                                       <command name="getOrganizationNames" class="ru.runa.rkdemo.web.ajax.GetOrganizationNamesCommand" />
                                      </configuration>
                                      Её использование со скрипта формы (autocomplete input)

                                      $(document).ready(function() {
                                       $('#editLinkedLists').on("onRowAdded", function(event, rowIndex) {
                                        $("input[name='названия организаций["+rowIndex+"]']").autocomplete( {
                                         delay: 300,
                                         minLength: 0,
                                         source: "/wfe/ajaxcmd?command=getOrganizationNames"
                                        });
                                        $("input[name='названия организаций["+rowIndex+"]']").focus(function() {
                                         $(this).autocomplete("search", $(this).val());
                                        });
                                       });
                                      });Введение
                                         # Основные компоненты и используемые технологии
                                         Для WF–системы была выбрана следующая общая архитектура (в целом соответствует архитектуре, предлагаемой коалицией WfMC):

                                         Компоненты системы:

                                         Ядро системы
                                         Содержит набор определений бизнес-процессов
                                         Содержит набор выполняющихся экземпляров бизнес–процессов
                                         Компонент, "назначающий" исполнителей для действий
                                         Клиент
                                         Список заданий (набор графических форм, содержит очереди поступивших работ, сортировки и фильтры)
                                         Проигрыватель форм (отображает формы, разработанные в Среде разработки)
                                         Административный интерфейс
                                         Показывает состояния процессов, позволяет фильтровать и останавливать процессы
                                         Позволяет загружать-выгружать процессы
                                         Позволяет заводить-удалять пользователей
                                         Позволяет задавать различные права
                                         Редактор назначения заместителей
                                         Среда разработки
                                         Конструктор графических форм
                                         Бот станции, содержащие ботов (Боты - приложения специального вида, которые также как и обычные пользователи могут выполнять задания)
                                         Подсистема управления правами доступа (авторизация и аутентификация)
                                         # Платформа программирования и используемые программные средства
                                         В качестве платформы программирования используется J2EE.

                                         Используемые программные средства:

                                         Сервер приложений - JBOSS (http://www.jboss.org).
                                         Среда разработки - любая, например Eclipse от IBM (http://www.eclipse.org).
                                         Система контроля версий - git
                                         Сборщик приложений – maven.
                                         Сервер баз данных – поддерживаются сервера БД:
                                         MS SQL Server (http://www.microsoft.com/sql/evaluation/default.mspx)
                                         HSQL (http://hsqldb.org)
                                         Oracle (http://www.oracle.com)
                                         PostgreSQL (http://postgresql.com)
                                         Операционная система — поддерживаются следующие ОС:
                                         Windows (Server 2000-2008, XP, Vista, 7)
                                         ALTLinux
                                         Mandriva Linux
                                         Fedora
                                         Debian/Ubuntu
                                         # Описание проектов
                                         Название проекта	Обязателен при сборке	Обязателен при работе	Зависимости	Описание
                                         wfe-alfresco	нет	нет	runawfe-app	Интеграция с Alfresco
                                         wfe-app	да	да	wfe-ear, wfe-cactus-it	Проект для организации сборки maven
                                         wfe-appserver	нет	нет	 ?	Не используется
                                         wfe-bots	да	да	wfe-service	Подсистема ботов
                                         wfe-cactus-it	да	нет	wfe-service	Интеграционные тесты
                                         wfe-core	да	да	-	Основные компоненты системы
                                         wfe-ear	да	да	wfe-service, wfe-bots, wfe-office, wfe-web	Проект для сборки runawfe.ear
                                         wfe-office	да	нет	wfe-core	Обработчики для работы с Word, Excel
                                         wfe-service	да	да	wfe-core	Сервисы (EJB + WebServices), представляющие собой публичное API приложения
                                         wfe-web	да	да	wfe-bots	Визуальная часть приложения
                                         wfe-webservice-client	нет	нет	 ?	Авто-генерации клиентской библиотеки на основе WSDL серверных сервисов. В нем же есть примеры использования веб-служб из Java клиента.
                                         # Описание слоев архитектуры системы
                                         Каждый компонент состоит из нескольких уровней (слоев).

                                         Список слоев:

                                         delegate
                                         service
                                         logic
                                         DAO
                                         hibernate
                                         # Слой Delegate
                                         Delegate-классы, реализующие сервисные интерфейсы представляют собой pattern проектирования BusinessDelegate, упрощающий доступ к серверному API системы. Клиентское приложение взаимодействует с системой только через Delegate-классы. Delegate-классы получаются посредством запроса фабрики Delegates, которая в зависимости от конфигурации возвращает нужную реализацию. Классы Delegate являются частью клиентского API.

                                         Список основных Delegate-классов:

                                         AuthenticationServiceDelegate – содержит методы для аутентификации пользователей в системе (с использованием логина/пароля, Kerberos и т.п.)
                                         AuthorizationServiceDelegate — содержит методы для работы с полномочиями пользователей (назначение полномочий, проверка на допустимость операции для пользователя и т.п.)
                                         BotServiceDelegate — содержит методы для работы с бот станциями и ботами
                                         ExecutorServiceDelegate — содержит методы для работы с исполнителями. Позволяет создавать/удалять/изменять исполнителей а так же включать их в группы
                                         ProfileServiceDelegate — содержит методы для работы с профайлам пользователей
                                         SubstitutionServiceDelegate — содержит методы для управления правилами замещения
                                         SystemServiceDelegate — содержит методы для входа/выхода пользователя в систему
                                         DefinitionServiceDelegate — содержит методы для работы с определениями процессов
                                         ExecutionServiceDelegate — содержит методы для работы с исполняемыми экземплярами процессов
                                         Все существующие в данный момент Delegate-классы реализуют требуемую функциональность при помощи технологии EJB.

                                         # Слой Service
                                         Слой service – это серверное API доступа к системе. Реализации Delegate интерфейсов обращаются именно к этому слою. Каждый Delegate работает с одним соответствующим классом Service. В настоящее время все разработанные service классы и интерфейсы ориентированы на EJB-технологию, однако в будущем возможны и другие реализации. Реализации классов Service являются Stateless Session Bean EJB, которые декларативно поддерживают транзакционность вызовов и запрашивают соответствующие классы из слоя Logic.

                                         Таким образом, классы Delegate – Service - Logic образуют как бы «транспорт» между клиентом и сервером.

                                         # Слой Logic
                                         Слой Logic – это реализация бизнес логики работы системы. Слой работает с классами слоя DAO для доступа к постоянному хранилищу.

                                         # Слой DAO
                                         Слой DAO – это интерфейсы и классы, обеспечивающие доступ к данным, находящимся в постоянном хранилище (базе данных). В настоящее время все DAO-классы системы реализованы при помощи ORM-средства Hibernate.

                                         # Использование Hibernate
                                         Hibernate – ORM (Object/Relational Mapping) средство. Отображает объектную архитектуру на реляционную структуру данных. Допускает настройку (не меняя разработанного кода) на большинство существующих серверов реляционных баз данных.

                                         Поддерживает работу с распределенными транзакциями, автоматически создает таблицы для новых классов и т.д. Вся работа с данными внутри системы ведется только через Hibernate.

                                         Все компоненты, предоставляющие клиентское API построены с использованием описанных выше слоев. В целях оптимизации в некоторых компонентах применяется кеширование, которое может встречаться на уровне logic или DAO. Основная функциональность по управлению кешами находится в классах CachingLogic, CacheInterceptor и классах соответствующих кешей. Изменения в кешируемых объектах перехватываются и сообщаются посредством CachingLogic всем подписавшимся на изменения классам кешей. Транзакция, изменяющая кеш, считается закрытой по окончанию обработки ejb вызова.

                                         # Обновление базы данных
                                         см. описание системы патчей.

                                         # API
                                         Система представляет API для интеграции с другими системами:

                                         # Java API
                                         Реализация (снизу вверх): БД - Hibernate3 - EJB3

                                         Документацию можно смотреть в исходном коде (javadocs в *Service.java).

                                         # WebServices API
                                         Реализация (снизу вверх): БД - Hibernate3 - JAX-WS

                                         Документация: WebServicesDeveloperGuide

                                         # Scripting API
                                         Реализация (снизу вверх): БД - Hibernate3 - XML Script

                                         Документация: AdminScriptGuide

                                         # Процесс сборки из исходного кода
                                         Исходный код системы доступен в открытом репозитории на github.

                                         Сервер можно собирать как средствами maven используя командную строку, так и используя среду Eclipse IDE.

                                         В результате сборки будет сформирован runawfe.ear, который теоретически можно запустить на любом сервере приложений. Начиная с версии 4.3.0 введена поддержка JAVA версии 8, и отказ от JAVA 6. В дальнейшем планируется отказ от java7, поэтому рекомендуется использовать сервер приложений wildfly.

                                         # Процесс сборки на примере Eclipse IDE
                                         # Необходимое программное обеспечение для сборки
                                         В отличие от Среды разработки для сборки сервера можно использовать Eclipse IDE любой версии и редакции.

                                         установите плагин m2eclipse
                                         используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу: http://maven.apache.org/
                                         добавьте путь к Apache Maven директории bin в переменную окружения Path
                                         # Импорт проектов
                                         Импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server.

                                         Eclipse srv proj.png

                                         # Установка maven артефактов
                                         Выполните

                                         ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                                         ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                                         или другим способом установите артефакты в локальный репозиторий

                                         # Сборка
                                         Заведите конфигурацию запуска на основе maven как показано на рисунке

                                         Maven.build.configuration.png

                                         Запустите конфигурацию.

                                         Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\eclipse-workspace\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"

                                         # Сборка из командной строки
                                         используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу http://maven.apache.org/
                                         добавьте путь к Apache Maven директории bin в переменную окружения Path
                                         импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server
                                         выполните обновление зависимостей
                                         ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                                         ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                                         откройте командную строку
                                         перейдите в директорию ${wfe}/wfe-app/
                                         выполните команду для сборки
                                         mvn clean package -Dmaven.test.skip=true
                                         Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"


                                         Для установки артефактов в локальный репозиторий используйте команду

                                         mvn clean install -Dmaven.test.skip=true
                                         # Использование ear на сервере приложений
                                         cкачайте текущую версию RunaWFE в виде файл-архива исполняемых java файлов runawfe-wildfly-java8-*.zip (на базе wildfly, java8)
                                         распакуйте архив
                                         обновите runawfe.ear на версию полученную в результате сборки
                                         # Расширение функциональности
                                         # Точки расширения системы
                                         Обработчики позволяют исполнить код в процессах (элементы "Обработчик", "Задача сценария") и ботах
                                         Форматы переменных определяют тип переменных и правила преобразования значений к текстовому представлению и обратно
                                         Организационные функции используются при назначении ролей и в правилах замещения для определения заместителя
                                         Критерии замещения используются в подсистеме замещения для определения заместителя при построении списка заданий
                                         Валидаторы обеспечивают проверку переменных при выполнении задания (в т.ч. введенные значения форм)
                                         Freemarker теги форм генерируют html код для отображения на форме
                                         Ajax команды предоставляют доступ к функциональности сервера из JavaScript
                                         # Процесс разработки расширений
                                         Создайте новый java-проект и подключите необходимые зависимости (wfe-core, wfe-service).

                                         Реализуйте в нем требуемые расширения и соберите его в виде jar-файла.

                                         Замечание. Использование maven облегчит процесс управления зависимостями.

                                         Разместить собранный jar на сервере вы можете:

                                         положив его в runawfe.ear!/lib
                                         положив его в директорию deploy (только для jboss4)
                                         положив его в ${jboss.server.base.dir}/wfe.custom (только для jboss7)
                                         положив его в ${jboss.server.base.dir}/${jboss.server.name}/wfe.custom (только для jboss4)
                                         # Обработчики
                                         Обработчик в процессе – компонент процесса (элементы "Обработчик", "Задача сценария"), использующийся для выполнения каких-либо действий при возникновении определенных событий (проход по определенному переходу в процессе, приход или уход управления из узла и т.п.).

                                         Обработчик должен реализовывать интерфейс ru.runa.wfe.extension.ActionHandler. Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов Spring контекста (например с помощью аннотации @Autowired).

                                         При написании нового обработчика рекомендуется наследовать его от абстрактного класса ru.runa.wfe.extension.handler.CommonHandler или ru.runa.wfe.extension.handler.CommonParamBasedHandler. В методе setConfiguration обработчик должен запомнить свои параметры (если обработчик их ожидает), а в методе execute происходит непосредственная обработка и выполнение требуемых действий.

                                         В случае, если при выполнении обработчика произошла ошибка, произойдет откат транзакции и состояние процесса будет возвращено к заданию, исполнение которого повлекло вызов обработчика. В интерфейсе обработчика для бота ru.runa.wfe.extension.TaskHandler предусмотрен метод onRollback для работы с не-транзакционными ресурсами.

                                         Эти обработчики удобно использовать для простых операций (например для отправки оповещений в виде SMS-сообщений если процесс попал в определенное состояние). Но у них есть несколько ограничений. Прежде всего у них нет соответствующего объекта контекста безопасности (security context). Это означает, что в них нельзя выполнять защищенные методы (запуск процессов, выполнение задач, создание пользователей и т.п.) Ошибочным решением в них будет блокирование выполнения процесса (например с Thread::Sleep(...)). Например, если в обработчике отправляется e-mail, а SMTP сервер недоступен, обработчику нельзя "задерживать" свое выполнение.

                                         Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                                         # Специфика обработчиков для ботов
                                         Бот - это сокращение от робот. В системе боты - это особый тип исполнителей. Система не отличает ботов от людей. У каждого бота есть свои права на вход в систему, он периодически просыпается, проверяет свой список задачи и выполняет обнаруженные там задачи.

                                         Каждая задача бота обрабатывается при помощи соответствующего обработчика. Чтобы написать новый обработчик нужно реализовать интерфейс ru.runa.wfe.extension.TaskHandler.

                                         Обратите внимание, что этот вид обработчиков выполняется в контексте безопасности (security context) пользователя-бота, и здесь может выполнятся любая операция (если у бота есть на это права).

                                         Обработчики задач ботов могут блокировать выполнение процесса.

                                         Например, обработчик задач, отправляющий e-mail может блокировать выполнение бизнес процесса до тех пор, пока обработчик не удостоверится, что SMTP сервер принял сообщение для последующей доставки.

                                         Обработчики задач вызываются периодически, когда боты проверяют свои списки задач.

                                         # Специфика обработчика для элемента ветвление
                                         Обработчик для Decision является java-классом, реализующим интерфейс ru.runa.wfe.extension.DecisionHandler. Интерфейс содержит один метод decide(ExecutionContext executionContext), который возвращает имя выбранного перехода (одного из выходящих из данного ветвления). Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов контекста спринга (например с помощью аннотации @Autowired).

                                         Обработчик принимает ExecutionContext в качестве входящего параметра и должен сделать выбор перехода исходя из значений переменных бизнес процесса и условий, указанных в конфигурации обработчика. Точно также как обработчики действия (action handler) обработчики выбора (decision handlers) не могут использовать защищенные (secured) методы, не могут обрабатывать ошибки и откладывать выбор перехода до лучших времен.

                                         По умолчанию используется ru.runa.wfe.extension.decision.GroovyDecisionHandler.

                                         # Использование ru.runa.wfe.extension.handler.CommonParamBasedHandler в качестве базового класса
                                         Этот класс инкапсулирует в себе парсинг XML конфигурации определенного формата. Его удобно использовать если обработчик имеет фиксированное число параметров. Пример конфигурации:

                                         <?xml version="1.0" encoding="UTF-8"?>
                                         <config>
                                          <input>
                                            <param name="typeName" variable="тип отсутствия" />
                                            <param name="employee" variable="сотрудник" />
                                            <param name="requester" variable="подавший заявку" />
                                            <param name="from" variable="дата с" />
                                            <param name="to" variable="дата по" />
                                            <param name="cause" variable="причина" />
                                            <param name="comment" variable="комментарий" />
                                            <param name="confirmation" variable="дата подтверждения" />
                                            <param name="firmCode" value="111" />
                                            <param name="firmPositionCode" variable="код должности" />
                                            <param name="firmDepartmentCode" variable="код подразделения" />
                                          </input>
                                          <output>
                                            <param name="uuid" variable="идентификатор объекта" />
                                          </output>
                                         </config>
                                         Использование обработчика Groovy
                                         См. соответствующий раздел в руководстве по работе с Groovy.

                                         # Как написать функцию над организационной структурой
                                         Функции над организационной структурой в системе применяются, например, при инициализации Ролей-Дорожек и в правилах замещения.

                                         Класс, соответствующий функции над организационной структурой, должен реализовывать интерфейс ru.runa.wfe.extension.OrgFunction.

                                         Интерфейс содержит один метод

                                         List<? extends Executor> getExecutors(Object... parameters)
                                         Этот метод должен возвращать список исполнителей.

                                         В бизнес-процессе обработчик функции над оргструктурой используются при определении Ролей-Дорожек: указывается внутри тега swimlane, в теле тега <assignment>.В качестве параметра class тега <assignment> указывается класс-обработчик для инициализации swimlane: ru.runa.wfe.extension.AssignmentHandler. Внутри тега <assignment> содержится конфигурация для этого класса, которая представляет собой имя класса-наследника интерфейса OrgFunction и список параметров в скобках. В качестве параметра может выступать конкретное значение или имя переменной бизнес процесса в фигурных скобках, перед которым стоит значок $

                                         Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                                         Если есть планы по использованию функции в подсистеме замещений - её можно зарегистрировать в substitutions.xml.

                                         # Как написать критерий замещения
                                         Критерии замещения в системе применяются в правилах замещения. Класс, соответствующий критерию замещения, должен наследоваться от ru.runa.wfe.ss.SubstitutionCriteria.

                                         Для создания на основе него конечных критериев замещения с конфигурациями - его нужно зарегистрировать в substitution.criterias.xml.

                                         Как реализовать класс-формат для переменных бизнес-процесса
                                         См. соответствующий раздел в руководстве по работе с переменными.

                                         # Как реализовать валидатор переменных
                                         Классы, расширяющие абстрактный класс ru.runa.wfe.validation.FieldValidator, в системе применяются для проверки переменных при выполнении задания или старте процесса.

                                         Пример:

                                         public class OvertimeWorkRequestTimeCheck extends FieldValidator {
                                            @Override
                                            public void validate() {
                                                Date date = (Date) getFieldValue();
                                                if (date == null) {
                                                    return;
                                                }
                                                boolean testMode = getVariableProvider().getValueNotNull(boolean.class, "тестовый режим");
                                                if (testMode) {
                                                    return;
                                                }
                                                Calendar calendar = CalendarUtil.dateToCalendar(date);
                                                if (calendar.before(Calendar.getInstance())) {
                                                    addError("Заявка не может быть оформлена задним числом");
                                                    return;
                                                }
                                                CalendarUtil.setTimeFromCalendar(calendar, DemoProperties.getOvertimeWorkRequestMaximumStartTime());
                                                Utils.adjustCalendarForHolidaysInOvertimwWork(calendar);
                                                if (calendar.before(Calendar.getInstance())) {
                                                    addError("Заявка на этот день не может быть подана, время подачи истекло " + CalendarUtil.formatDateTime(calendar));
                                                }
                                            }
                                         }

                                         Связь между Средой разработки и сервером осуществляется по имени валидатора, регистрация требуется на стороне сервера в файле validators.xml, а в среде разработки - в plugin.xml.

                                         # Как реализовать FreeMarker тег для формы
                                         FreemarkerForms#Components

                                         # Как реализовать Ajax команду
                                         Классы, расширяющие абстрактный класс ru.runa.wfe.commons.web.JsonAjaxCommand, (или реализующие ru.runa.wfe.commons.web.AjaxCommand) в системе применяются для доступа к функциональности сервера из JavaScript, например при отображении форм задания.

                                         Регистрация команды происходит любым из двух способов:

                                         в файле ajax.commands.xml, ей присваивается определенное имя
                                         в контексте приложения, именем является id spring-бина
                                         Затем по этому имени её можно выполнить используя JavaScript.

                                         Пример команды

                                         public class GetOrganizationNamesCommand extends JsonAjaxCommand {
                                            @Autowired
                                            private OrganizationDAO organizationDAO;
                                            @Override
                                            protected JSONAware execute(User user, HttpServletRequest request) throws Exception {
                                                String term = request.getParameter("term");
                                                if (term == null) {
                                                    term = "";
                                                }
                                                List<Organization> organizations = organizationDAO.getAll();
                                                JSONArray array = new JSONArray();
                                                for (Organization organization : organizations) {
                                                    if (organization.getName().startsWith(term)) {
                                                        array.add(organization.getName());
                                                    }
                                                }
                                                return array;
                                            }
                                         }
                                         Регистрация в wfe.custom.ajax.commands.xml

                                         <?xml version="1.0" encoding="UTF-8" ?>
                                         <configuration xmlns="http://runa.ru/xml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://runa.ru/xml">
                                          <command name="getOrganizationNames" class="ru.runa.rkdemo.web.ajax.GetOrganizationNamesCommand" />
                                         </configuration>
                                         Её использование со скрипта формы (autocomplete input)

                                         $(document).ready(function() {
                                          $('#editLinkedLists').on("onRowAdded", function(event, rowIndex) {
                                           $("input[name='названия организаций["+rowIndex+"]']").autocomplete( {
                                            delay: 300,
                                            minLength: 0,
                                            source: "/wfe/ajaxcmd?command=getOrganizationNames"
                                           });
                                           $("input[name='названия организаций["+rowIndex+"]']").focus(function() {
                                            $(this).autocomplete("search", $(this).val());
                                           });
                                          });
                                         });Введение
                                            # Основные компоненты и используемые технологии
                                            Для WF–системы была выбрана следующая общая архитектура (в целом соответствует архитектуре, предлагаемой коалицией WfMC):

                                            Компоненты системы:

                                            Ядро системы
                                            Содержит набор определений бизнес-процессов
                                            Содержит набор выполняющихся экземпляров бизнес–процессов
                                            Компонент, "назначающий" исполнителей для действий
                                            Клиент
                                            Список заданий (набор графических форм, содержит очереди поступивших работ, сортировки и фильтры)
                                            Проигрыватель форм (отображает формы, разработанные в Среде разработки)
                                            Административный интерфейс
                                            Показывает состояния процессов, позволяет фильтровать и останавливать процессы
                                            Позволяет загружать-выгружать процессы
                                            Позволяет заводить-удалять пользователей
                                            Позволяет задавать различные права
                                            Редактор назначения заместителей
                                            Среда разработки
                                            Конструктор графических форм
                                            Бот станции, содержащие ботов (Боты - приложения специального вида, которые также как и обычные пользователи могут выполнять задания)
                                            Подсистема управления правами доступа (авторизация и аутентификация)
                                            # Платформа программирования и используемые программные средства
                                            В качестве платформы программирования используется J2EE.

                                            Используемые программные средства:

                                            Сервер приложений - JBOSS (http://www.jboss.org).
                                            Среда разработки - любая, например Eclipse от IBM (http://www.eclipse.org).
                                            Система контроля версий - git
                                            Сборщик приложений – maven.
                                            Сервер баз данных – поддерживаются сервера БД:
                                            MS SQL Server (http://www.microsoft.com/sql/evaluation/default.mspx)
                                            HSQL (http://hsqldb.org)
                                            Oracle (http://www.oracle.com)
                                            PostgreSQL (http://postgresql.com)
                                            Операционная система — поддерживаются следующие ОС:
                                            Windows (Server 2000-2008, XP, Vista, 7)
                                            ALTLinux
                                            Mandriva Linux
                                            Fedora
                                            Debian/Ubuntu
                                            # Описание проектов
                                            Название проекта	Обязателен при сборке	Обязателен при работе	Зависимости	Описание
                                            wfe-alfresco	нет	нет	runawfe-app	Интеграция с Alfresco
                                            wfe-app	да	да	wfe-ear, wfe-cactus-it	Проект для организации сборки maven
                                            wfe-appserver	нет	нет	 ?	Не используется
                                            wfe-bots	да	да	wfe-service	Подсистема ботов
                                            wfe-cactus-it	да	нет	wfe-service	Интеграционные тесты
                                            wfe-core	да	да	-	Основные компоненты системы
                                            wfe-ear	да	да	wfe-service, wfe-bots, wfe-office, wfe-web	Проект для сборки runawfe.ear
                                            wfe-office	да	нет	wfe-core	Обработчики для работы с Word, Excel
                                            wfe-service	да	да	wfe-core	Сервисы (EJB + WebServices), представляющие собой публичное API приложения
                                            wfe-web	да	да	wfe-bots	Визуальная часть приложения
                                            wfe-webservice-client	нет	нет	 ?	Авто-генерации клиентской библиотеки на основе WSDL серверных сервисов. В нем же есть примеры использования веб-служб из Java клиента.
                                            # Описание слоев архитектуры системы
                                            Каждый компонент состоит из нескольких уровней (слоев).

                                            Список слоев:

                                            delegate
                                            service
                                            logic
                                            DAO
                                            hibernate
                                            # Слой Delegate
                                            Delegate-классы, реализующие сервисные интерфейсы представляют собой pattern проектирования BusinessDelegate, упрощающий доступ к серверному API системы. Клиентское приложение взаимодействует с системой только через Delegate-классы. Delegate-классы получаются посредством запроса фабрики Delegates, которая в зависимости от конфигурации возвращает нужную реализацию. Классы Delegate являются частью клиентского API.

                                            Список основных Delegate-классов:

                                            AuthenticationServiceDelegate – содержит методы для аутентификации пользователей в системе (с использованием логина/пароля, Kerberos и т.п.)
                                            AuthorizationServiceDelegate — содержит методы для работы с полномочиями пользователей (назначение полномочий, проверка на допустимость операции для пользователя и т.п.)
                                            BotServiceDelegate — содержит методы для работы с бот станциями и ботами
                                            ExecutorServiceDelegate — содержит методы для работы с исполнителями. Позволяет создавать/удалять/изменять исполнителей а так же включать их в группы
                                            ProfileServiceDelegate — содержит методы для работы с профайлам пользователей
                                            SubstitutionServiceDelegate — содержит методы для управления правилами замещения
                                            SystemServiceDelegate — содержит методы для входа/выхода пользователя в систему
                                            DefinitionServiceDelegate — содержит методы для работы с определениями процессов
                                            ExecutionServiceDelegate — содержит методы для работы с исполняемыми экземплярами процессов
                                            Все существующие в данный момент Delegate-классы реализуют требуемую функциональность при помощи технологии EJB.

                                            # Слой Service
                                            Слой service – это серверное API доступа к системе. Реализации Delegate интерфейсов обращаются именно к этому слою. Каждый Delegate работает с одним соответствующим классом Service. В настоящее время все разработанные service классы и интерфейсы ориентированы на EJB-технологию, однако в будущем возможны и другие реализации. Реализации классов Service являются Stateless Session Bean EJB, которые декларативно поддерживают транзакционность вызовов и запрашивают соответствующие классы из слоя Logic.

                                            Таким образом, классы Delegate – Service - Logic образуют как бы «транспорт» между клиентом и сервером.

                                            # Слой Logic
                                            Слой Logic – это реализация бизнес логики работы системы. Слой работает с классами слоя DAO для доступа к постоянному хранилищу.

                                            # Слой DAO
                                            Слой DAO – это интерфейсы и классы, обеспечивающие доступ к данным, находящимся в постоянном хранилище (базе данных). В настоящее время все DAO-классы системы реализованы при помощи ORM-средства Hibernate.

                                            # Использование Hibernate
                                            Hibernate – ORM (Object/Relational Mapping) средство. Отображает объектную архитектуру на реляционную структуру данных. Допускает настройку (не меняя разработанного кода) на большинство существующих серверов реляционных баз данных.

                                            Поддерживает работу с распределенными транзакциями, автоматически создает таблицы для новых классов и т.д. Вся работа с данными внутри системы ведется только через Hibernate.

                                            Все компоненты, предоставляющие клиентское API построены с использованием описанных выше слоев. В целях оптимизации в некоторых компонентах применяется кеширование, которое может встречаться на уровне logic или DAO. Основная функциональность по управлению кешами находится в классах CachingLogic, CacheInterceptor и классах соответствующих кешей. Изменения в кешируемых объектах перехватываются и сообщаются посредством CachingLogic всем подписавшимся на изменения классам кешей. Транзакция, изменяющая кеш, считается закрытой по окончанию обработки ejb вызова.

                                            # Обновление базы данных
                                            см. описание системы патчей.

                                            # API
                                            Система представляет API для интеграции с другими системами:

                                            # Java API
                                            Реализация (снизу вверх): БД - Hibernate3 - EJB3

                                            Документацию можно смотреть в исходном коде (javadocs в *Service.java).

                                            # WebServices API
                                            Реализация (снизу вверх): БД - Hibernate3 - JAX-WS

                                            Документация: WebServicesDeveloperGuide

                                            # Scripting API
                                            Реализация (снизу вверх): БД - Hibernate3 - XML Script

                                            Документация: AdminScriptGuide

                                            # Процесс сборки из исходного кода
                                            Исходный код системы доступен в открытом репозитории на github.

                                            Сервер можно собирать как средствами maven используя командную строку, так и используя среду Eclipse IDE.

                                            В результате сборки будет сформирован runawfe.ear, который теоретически можно запустить на любом сервере приложений. Начиная с версии 4.3.0 введена поддержка JAVA версии 8, и отказ от JAVA 6. В дальнейшем планируется отказ от java7, поэтому рекомендуется использовать сервер приложений wildfly.

                                            # Процесс сборки на примере Eclipse IDE
                                            # Необходимое программное обеспечение для сборки
                                            В отличие от Среды разработки для сборки сервера можно использовать Eclipse IDE любой версии и редакции.

                                            установите плагин m2eclipse
                                            используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу: http://maven.apache.org/
                                            добавьте путь к Apache Maven директории bin в переменную окружения Path
                                            # Импорт проектов
                                            Импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server.

                                            Eclipse srv proj.png

                                            # Установка maven артефактов
                                            Выполните

                                            ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                                            ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                                            или другим способом установите артефакты в локальный репозиторий

                                            # Сборка
                                            Заведите конфигурацию запуска на основе maven как показано на рисунке

                                            Maven.build.configuration.png

                                            Запустите конфигурацию.

                                            Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\eclipse-workspace\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"

                                            # Сборка из командной строки
                                            используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу http://maven.apache.org/
                                            добавьте путь к Apache Maven директории bin в переменную окружения Path
                                            импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server
                                            выполните обновление зависимостей
                                            ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                                            ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                                            откройте командную строку
                                            перейдите в директорию ${wfe}/wfe-app/
                                            выполните команду для сборки
                                            mvn clean package -Dmaven.test.skip=true
                                            Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"


                                            Для установки артефактов в локальный репозиторий используйте команду

                                            mvn clean install -Dmaven.test.skip=true
                                            # Использование ear на сервере приложений
                                            cкачайте текущую версию RunaWFE в виде файл-архива исполняемых java файлов runawfe-wildfly-java8-*.zip (на базе wildfly, java8)
                                            распакуйте архив
                                            обновите runawfe.ear на версию полученную в результате сборки
                                            # Расширение функциональности
                                            # Точки расширения системы
                                            Обработчики позволяют исполнить код в процессах (элементы "Обработчик", "Задача сценария") и ботах
                                            Форматы переменных определяют тип переменных и правила преобразования значений к текстовому представлению и обратно
                                            Организационные функции используются при назначении ролей и в правилах замещения для определения заместителя
                                            Критерии замещения используются в подсистеме замещения для определения заместителя при построении списка заданий
                                            Валидаторы обеспечивают проверку переменных при выполнении задания (в т.ч. введенные значения форм)
                                            Freemarker теги форм генерируют html код для отображения на форме
                                            Ajax команды предоставляют доступ к функциональности сервера из JavaScript
                                            # Процесс разработки расширений
                                            Создайте новый java-проект и подключите необходимые зависимости (wfe-core, wfe-service).

                                            Реализуйте в нем требуемые расширения и соберите его в виде jar-файла.

                                            Замечание. Использование maven облегчит процесс управления зависимостями.

                                            Разместить собранный jar на сервере вы можете:

                                            положив его в runawfe.ear!/lib
                                            положив его в директорию deploy (только для jboss4)
                                            положив его в ${jboss.server.base.dir}/wfe.custom (только для jboss7)
                                            положив его в ${jboss.server.base.dir}/${jboss.server.name}/wfe.custom (только для jboss4)
                                            # Обработчики
                                            Обработчик в процессе – компонент процесса (элементы "Обработчик", "Задача сценария"), использующийся для выполнения каких-либо действий при возникновении определенных событий (проход по определенному переходу в процессе, приход или уход управления из узла и т.п.).

                                            Обработчик должен реализовывать интерфейс ru.runa.wfe.extension.ActionHandler. Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов Spring контекста (например с помощью аннотации @Autowired).

                                            При написании нового обработчика рекомендуется наследовать его от абстрактного класса ru.runa.wfe.extension.handler.CommonHandler или ru.runa.wfe.extension.handler.CommonParamBasedHandler. В методе setConfiguration обработчик должен запомнить свои параметры (если обработчик их ожидает), а в методе execute происходит непосредственная обработка и выполнение требуемых действий.

                                            В случае, если при выполнении обработчика произошла ошибка, произойдет откат транзакции и состояние процесса будет возвращено к заданию, исполнение которого повлекло вызов обработчика. В интерфейсе обработчика для бота ru.runa.wfe.extension.TaskHandler предусмотрен метод onRollback для работы с не-транзакционными ресурсами.

                                            Эти обработчики удобно использовать для простых операций (например для отправки оповещений в виде SMS-сообщений если процесс попал в определенное состояние). Но у них есть несколько ограничений. Прежде всего у них нет соответствующего объекта контекста безопасности (security context). Это означает, что в них нельзя выполнять защищенные методы (запуск процессов, выполнение задач, создание пользователей и т.п.) Ошибочным решением в них будет блокирование выполнения процесса (например с Thread::Sleep(...)). Например, если в обработчике отправляется e-mail, а SMTP сервер недоступен, обработчику нельзя "задерживать" свое выполнение.

                                            Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                                            # Специфика обработчиков для ботов
                                            Бот - это сокращение от робот. В системе боты - это особый тип исполнителей. Система не отличает ботов от людей. У каждого бота есть свои права на вход в систему, он периодически просыпается, проверяет свой список задачи и выполняет обнаруженные там задачи.

                                            Каждая задача бота обрабатывается при помощи соответствующего обработчика. Чтобы написать новый обработчик нужно реализовать интерфейс ru.runa.wfe.extension.TaskHandler.

                                            Обратите внимание, что этот вид обработчиков выполняется в контексте безопасности (security context) пользователя-бота, и здесь может выполнятся любая операция (если у бота есть на это права).

                                            Обработчики задач ботов могут блокировать выполнение процесса.

                                            Например, обработчик задач, отправляющий e-mail может блокировать выполнение бизнес процесса до тех пор, пока обработчик не удостоверится, что SMTP сервер принял сообщение для последующей доставки.

                                            Обработчики задач вызываются периодически, когда боты проверяют свои списки задач.

                                            # Специфика обработчика для элемента ветвление
                                            Обработчик для Decision является java-классом, реализующим интерфейс ru.runa.wfe.extension.DecisionHandler. Интерфейс содержит один метод decide(ExecutionContext executionContext), который возвращает имя выбранного перехода (одного из выходящих из данного ветвления). Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов контекста спринга (например с помощью аннотации @Autowired).

                                            Обработчик принимает ExecutionContext в качестве входящего параметра и должен сделать выбор перехода исходя из значений переменных бизнес процесса и условий, указанных в конфигурации обработчика. Точно также как обработчики действия (action handler) обработчики выбора (decision handlers) не могут использовать защищенные (secured) методы, не могут обрабатывать ошибки и откладывать выбор перехода до лучших времен.

                                            По умолчанию используется ru.runa.wfe.extension.decision.GroovyDecisionHandler.

                                            # Использование ru.runa.wfe.extension.handler.CommonParamBasedHandler в качестве базового класса
                                            Этот класс инкапсулирует в себе парсинг XML конфигурации определенного формата. Его удобно использовать если обработчик имеет фиксированное число параметров. Пример конфигурации:

                                            <?xml version="1.0" encoding="UTF-8"?>
                                            <config>
                                             <input>
                                               <param name="typeName" variable="тип отсутствия" />
                                               <param name="employee" variable="сотрудник" />
                                               <param name="requester" variable="подавший заявку" />
                                               <param name="from" variable="дата с" />
                                               <param name="to" variable="дата по" />
                                               <param name="cause" variable="причина" />
                                               <param name="comment" variable="комментарий" />
                                               <param name="confirmation" variable="дата подтверждения" />
                                               <param name="firmCode" value="111" />
                                               <param name="firmPositionCode" variable="код должности" />
                                               <param name="firmDepartmentCode" variable="код подразделения" />
                                             </input>
                                             <output>
                                               <param name="uuid" variable="идентификатор объекта" />
                                             </output>
                                            </config>
                                            Использование обработчика Groovy
                                            См. соответствующий раздел в руководстве по работе с Groovy.

                                            # Как написать функцию над организационной структурой
                                            Функции над организационной структурой в системе применяются, например, при инициализации Ролей-Дорожек и в правилах замещения.

                                            Класс, соответствующий функции над организационной структурой, должен реализовывать интерфейс ru.runa.wfe.extension.OrgFunction.

                                            Интерфейс содержит один метод

                                            List<? extends Executor> getExecutors(Object... parameters)
                                            Этот метод должен возвращать список исполнителей.

                                            В бизнес-процессе обработчик функции над оргструктурой используются при определении Ролей-Дорожек: указывается внутри тега swimlane, в теле тега <assignment>.В качестве параметра class тега <assignment> указывается класс-обработчик для инициализации swimlane: ru.runa.wfe.extension.AssignmentHandler. Внутри тега <assignment> содержится конфигурация для этого класса, которая представляет собой имя класса-наследника интерфейса OrgFunction и список параметров в скобках. В качестве параметра может выступать конкретное значение или имя переменной бизнес процесса в фигурных скобках, перед которым стоит значок $

                                            Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                                            Если есть планы по использованию функции в подсистеме замещений - её можно зарегистрировать в substitutions.xml.

                                            # Как написать критерий замещения
                                            Критерии замещения в системе применяются в правилах замещения. Класс, соответствующий критерию замещения, должен наследоваться от ru.runa.wfe.ss.SubstitutionCriteria.

                                            Для создания на основе него конечных критериев замещения с конфигурациями - его нужно зарегистрировать в substitution.criterias.xml.

                                            Как реализовать класс-формат для переменных бизнес-процесса
                                            См. соответствующий раздел в руководстве по работе с переменными.

                                            # Как реализовать валидатор переменных
                                            Классы, расширяющие абстрактный класс ru.runa.wfe.validation.FieldValidator, в системе применяются для проверки переменных при выполнении задания или старте процесса.

                                            Пример:

                                            public class OvertimeWorkRequestTimeCheck extends FieldValidator {
                                               @Override
                                               public void validate() {
                                                   Date date = (Date) getFieldValue();
                                                   if (date == null) {
                                                       return;
                                                   }
                                                   boolean testMode = getVariableProvider().getValueNotNull(boolean.class, "тестовый режим");
                                                   if (testMode) {
                                                       return;
                                                   }
                                                   Calendar calendar = CalendarUtil.dateToCalendar(date);
                                                   if (calendar.before(Calendar.getInstance())) {
                                                       addError("Заявка не может быть оформлена задним числом");
                                                       return;
                                                   }
                                                   CalendarUtil.setTimeFromCalendar(calendar, DemoProperties.getOvertimeWorkRequestMaximumStartTime());
                                                   Utils.adjustCalendarForHolidaysInOvertimwWork(calendar);
                                                   if (calendar.before(Calendar.getInstance())) {
                                                       addError("Заявка на этот день не может быть подана, время подачи истекло " + CalendarUtil.formatDateTime(calendar));
                                                   }
                                               }
                                            }

                                            Связь между Средой разработки и сервером осуществляется по имени валидатора, регистрация требуется на стороне сервера в файле validators.xml, а в среде разработки - в plugin.xml.

                                            # Как реализовать FreeMarker тег для формы
                                            FreemarkerForms#Components

                                            # Как реализовать Ajax команду
                                            Классы, расширяющие абстрактный класс ru.runa.wfe.commons.web.JsonAjaxCommand, (или реализующие ru.runa.wfe.commons.web.AjaxCommand) в системе применяются для доступа к функциональности сервера из JavaScript, например при отображении форм задания.

                                            Регистрация команды происходит любым из двух способов:

                                            в файле ajax.commands.xml, ей присваивается определенное имя
                                            в контексте приложения, именем является id spring-бина
                                            Затем по этому имени её можно выполнить используя JavaScript.

                                            Пример команды

                                            public class GetOrganizationNamesCommand extends JsonAjaxCommand {
                                               @Autowired
                                               private OrganizationDAO organizationDAO;
                                               @Override
                                               protected JSONAware execute(User user, HttpServletRequest request) throws Exception {
                                                   String term = request.getParameter("term");
                                                   if (term == null) {
                                                       term = "";
                                                   }
                                                   List<Organization> organizations = organizationDAO.getAll();
                                                   JSONArray array = new JSONArray();
                                                   for (Organization organization : organizations) {
                                                       if (organization.getName().startsWith(term)) {
                                                           array.add(organization.getName());
                                                       }
                                                   }
                                                   return array;
                                               }
                                            }
                                            Регистрация в wfe.custom.ajax.commands.xml

                                            <?xml version="1.0" encoding="UTF-8" ?>
                                            <configuration xmlns="http://runa.ru/xml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://runa.ru/xml">
                                             <command name="getOrganizationNames" class="ru.runa.rkdemo.web.ajax.GetOrganizationNamesCommand" />
                                            </configuration>
                                            Её использование со скрипта формы (autocomplete input)

                                            $(document).ready(function() {
                                             $('#editLinkedLists').on("onRowAdded", function(event, rowIndex) {
                                              $("input[name='названия организаций["+rowIndex+"]']").autocomplete( {
                                               delay: 300,
                                               minLength: 0,
                                               source: "/wfe/ajaxcmd?command=getOrganizationNames"
                                              });
                                              $("input[name='названия организаций["+rowIndex+"]']").focus(function() {
                                               $(this).autocomplete("search", $(this).val());
                                              });
                                             });
                                            });Введение
                                               # Основные компоненты и используемые технологии
                                               Для WF–системы была выбрана следующая общая архитектура (в целом соответствует архитектуре, предлагаемой коалицией WfMC):

                                               Компоненты системы:

                                               Ядро системы
                                               Содержит набор определений бизнес-процессов
                                               Содержит набор выполняющихся экземпляров бизнес–процессов
                                               Компонент, "назначающий" исполнителей для действий
                                               Клиент
                                               Список заданий (набор графических форм, содержит очереди поступивших работ, сортировки и фильтры)
                                               Проигрыватель форм (отображает формы, разработанные в Среде разработки)
                                               Административный интерфейс
                                               Показывает состояния процессов, позволяет фильтровать и останавливать процессы
                                               Позволяет загружать-выгружать процессы
                                               Позволяет заводить-удалять пользователей
                                               Позволяет задавать различные права
                                               Редактор назначения заместителей
                                               Среда разработки
                                               Конструктор графических форм
                                               Бот станции, содержащие ботов (Боты - приложения специального вида, которые также как и обычные пользователи могут выполнять задания)
                                               Подсистема управления правами доступа (авторизация и аутентификация)
                                               # Платформа программирования и используемые программные средства
                                               В качестве платформы программирования используется J2EE.

                                               Используемые программные средства:

                                               Сервер приложений - JBOSS (http://www.jboss.org).
                                               Среда разработки - любая, например Eclipse от IBM (http://www.eclipse.org).
                                               Система контроля версий - git
                                               Сборщик приложений – maven.
                                               Сервер баз данных – поддерживаются сервера БД:
                                               MS SQL Server (http://www.microsoft.com/sql/evaluation/default.mspx)
                                               HSQL (http://hsqldb.org)
                                               Oracle (http://www.oracle.com)
                                               PostgreSQL (http://postgresql.com)
                                               Операционная система — поддерживаются следующие ОС:
                                               Windows (Server 2000-2008, XP, Vista, 7)
                                               ALTLinux
                                               Mandriva Linux
                                               Fedora
                                               Debian/Ubuntu
                                               # Описание проектов
                                               Название проекта	Обязателен при сборке	Обязателен при работе	Зависимости	Описание
                                               wfe-alfresco	нет	нет	runawfe-app	Интеграция с Alfresco
                                               wfe-app	да	да	wfe-ear, wfe-cactus-it	Проект для организации сборки maven
                                               wfe-appserver	нет	нет	 ?	Не используется
                                               wfe-bots	да	да	wfe-service	Подсистема ботов
                                               wfe-cactus-it	да	нет	wfe-service	Интеграционные тесты
                                               wfe-core	да	да	-	Основные компоненты системы
                                               wfe-ear	да	да	wfe-service, wfe-bots, wfe-office, wfe-web	Проект для сборки runawfe.ear
                                               wfe-office	да	нет	wfe-core	Обработчики для работы с Word, Excel
                                               wfe-service	да	да	wfe-core	Сервисы (EJB + WebServices), представляющие собой публичное API приложения
                                               wfe-web	да	да	wfe-bots	Визуальная часть приложения
                                               wfe-webservice-client	нет	нет	 ?	Авто-генерации клиентской библиотеки на основе WSDL серверных сервисов. В нем же есть примеры использования веб-служб из Java клиента.
                                               # Описание слоев архитектуры системы
                                               Каждый компонент состоит из нескольких уровней (слоев).

                                               Список слоев:

                                               delegate
                                               service
                                               logic
                                               DAO
                                               hibernate
                                               # Слой Delegate
                                               Delegate-классы, реализующие сервисные интерфейсы представляют собой pattern проектирования BusinessDelegate, упрощающий доступ к серверному API системы. Клиентское приложение взаимодействует с системой только через Delegate-классы. Delegate-классы получаются посредством запроса фабрики Delegates, которая в зависимости от конфигурации возвращает нужную реализацию. Классы Delegate являются частью клиентского API.

                                               Список основных Delegate-классов:

                                               AuthenticationServiceDelegate – содержит методы для аутентификации пользователей в системе (с использованием логина/пароля, Kerberos и т.п.)
                                               AuthorizationServiceDelegate — содержит методы для работы с полномочиями пользователей (назначение полномочий, проверка на допустимость операции для пользователя и т.п.)
                                               BotServiceDelegate — содержит методы для работы с бот станциями и ботами
                                               ExecutorServiceDelegate — содержит методы для работы с исполнителями. Позволяет создавать/удалять/изменять исполнителей а так же включать их в группы
                                               ProfileServiceDelegate — содержит методы для работы с профайлам пользователей
                                               SubstitutionServiceDelegate — содержит методы для управления правилами замещения
                                               SystemServiceDelegate — содержит методы для входа/выхода пользователя в систему
                                               DefinitionServiceDelegate — содержит методы для работы с определениями процессов
                                               ExecutionServiceDelegate — содержит методы для работы с исполняемыми экземплярами процессов
                                               Все существующие в данный момент Delegate-классы реализуют требуемую функциональность при помощи технологии EJB.

                                               # Слой Service
                                               Слой service – это серверное API доступа к системе. Реализации Delegate интерфейсов обращаются именно к этому слою. Каждый Delegate работает с одним соответствующим классом Service. В настоящее время все разработанные service классы и интерфейсы ориентированы на EJB-технологию, однако в будущем возможны и другие реализации. Реализации классов Service являются Stateless Session Bean EJB, которые декларативно поддерживают транзакционность вызовов и запрашивают соответствующие классы из слоя Logic.

                                               Таким образом, классы Delegate – Service - Logic образуют как бы «транспорт» между клиентом и сервером.

                                               # Слой Logic
                                               Слой Logic – это реализация бизнес логики работы системы. Слой работает с классами слоя DAO для доступа к постоянному хранилищу.

                                               # Слой DAO
                                               Слой DAO – это интерфейсы и классы, обеспечивающие доступ к данным, находящимся в постоянном хранилище (базе данных). В настоящее время все DAO-классы системы реализованы при помощи ORM-средства Hibernate.

                                               # Использование Hibernate
                                               Hibernate – ORM (Object/Relational Mapping) средство. Отображает объектную архитектуру на реляционную структуру данных. Допускает настройку (не меняя разработанного кода) на большинство существующих серверов реляционных баз данных.

                                               Поддерживает работу с распределенными транзакциями, автоматически создает таблицы для новых классов и т.д. Вся работа с данными внутри системы ведется только через Hibernate.

                                               Все компоненты, предоставляющие клиентское API построены с использованием описанных выше слоев. В целях оптимизации в некоторых компонентах применяется кеширование, которое может встречаться на уровне logic или DAO. Основная функциональность по управлению кешами находится в классах CachingLogic, CacheInterceptor и классах соответствующих кешей. Изменения в кешируемых объектах перехватываются и сообщаются посредством CachingLogic всем подписавшимся на изменения классам кешей. Транзакция, изменяющая кеш, считается закрытой по окончанию обработки ejb вызова.

                                               # Обновление базы данных
                                               см. описание системы патчей.

                                               # API
                                               Система представляет API для интеграции с другими системами:

                                               # Java API
                                               Реализация (снизу вверх): БД - Hibernate3 - EJB3

                                               Документацию можно смотреть в исходном коде (javadocs в *Service.java).

                                               # WebServices API
                                               Реализация (снизу вверх): БД - Hibernate3 - JAX-WS

                                               Документация: WebServicesDeveloperGuide

                                               # Scripting API
                                               Реализация (снизу вверх): БД - Hibernate3 - XML Script

                                               Документация: AdminScriptGuide

                                               # Процесс сборки из исходного кода
                                               Исходный код системы доступен в открытом репозитории на github.

                                               Сервер можно собирать как средствами maven используя командную строку, так и используя среду Eclipse IDE.

                                               В результате сборки будет сформирован runawfe.ear, который теоретически можно запустить на любом сервере приложений. Начиная с версии 4.3.0 введена поддержка JAVA версии 8, и отказ от JAVA 6. В дальнейшем планируется отказ от java7, поэтому рекомендуется использовать сервер приложений wildfly.

                                               # Процесс сборки на примере Eclipse IDE
                                               # Необходимое программное обеспечение для сборки
                                               В отличие от Среды разработки для сборки сервера можно использовать Eclipse IDE любой версии и редакции.

                                               установите плагин m2eclipse
                                               используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу: http://maven.apache.org/
                                               добавьте путь к Apache Maven директории bin в переменную окружения Path
                                               # Импорт проектов
                                               Импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server.

                                               Eclipse srv proj.png

                                               # Установка maven артефактов
                                               Выполните

                                               ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                                               ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                                               или другим способом установите артефакты в локальный репозиторий

                                               # Сборка
                                               Заведите конфигурацию запуска на основе maven как показано на рисунке

                                               Maven.build.configuration.png

                                               Запустите конфигурацию.

                                               Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\eclipse-workspace\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"

                                               # Сборка из командной строки
                                               используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу http://maven.apache.org/
                                               добавьте путь к Apache Maven директории bin в переменную окружения Path
                                               импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server
                                               выполните обновление зависимостей
                                               ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                                               ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                                               откройте командную строку
                                               перейдите в директорию ${wfe}/wfe-app/
                                               выполните команду для сборки
                                               mvn clean package -Dmaven.test.skip=true
                                               Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"


                                               Для установки артефактов в локальный репозиторий используйте команду

                                               mvn clean install -Dmaven.test.skip=true
                                               # Использование ear на сервере приложений
                                               cкачайте текущую версию RunaWFE в виде файл-архива исполняемых java файлов runawfe-wildfly-java8-*.zip (на базе wildfly, java8)
                                               распакуйте архив
                                               обновите runawfe.ear на версию полученную в результате сборки
                                               # Расширение функциональности
                                               # Точки расширения системы
                                               Обработчики позволяют исполнить код в процессах (элементы "Обработчик", "Задача сценария") и ботах
                                               Форматы переменных определяют тип переменных и правила преобразования значений к текстовому представлению и обратно
                                               Организационные функции используются при назначении ролей и в правилах замещения для определения заместителя
                                               Критерии замещения используются в подсистеме замещения для определения заместителя при построении списка заданий
                                               Валидаторы обеспечивают проверку переменных при выполнении задания (в т.ч. введенные значения форм)
                                               Freemarker теги форм генерируют html код для отображения на форме
                                               Ajax команды предоставляют доступ к функциональности сервера из JavaScript
                                               # Процесс разработки расширений
                                               Создайте новый java-проект и подключите необходимые зависимости (wfe-core, wfe-service).

                                               Реализуйте в нем требуемые расширения и соберите его в виде jar-файла.

                                               Замечание. Использование maven облегчит процесс управления зависимостями.

                                               Разместить собранный jar на сервере вы можете:

                                               положив его в runawfe.ear!/lib
                                               положив его в директорию deploy (только для jboss4)
                                               положив его в ${jboss.server.base.dir}/wfe.custom (только для jboss7)
                                               положив его в ${jboss.server.base.dir}/${jboss.server.name}/wfe.custom (только для jboss4)
                                               # Обработчики
                                               Обработчик в процессе – компонент процесса (элементы "Обработчик", "Задача сценария"), использующийся для выполнения каких-либо действий при возникновении определенных событий (проход по определенному переходу в процессе, приход или уход управления из узла и т.п.).

                                               Обработчик должен реализовывать интерфейс ru.runa.wfe.extension.ActionHandler. Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов Spring контекста (например с помощью аннотации @Autowired).

                                               При написании нового обработчика рекомендуется наследовать его от абстрактного класса ru.runa.wfe.extension.handler.CommonHandler или ru.runa.wfe.extension.handler.CommonParamBasedHandler. В методе setConfiguration обработчик должен запомнить свои параметры (если обработчик их ожидает), а в методе execute происходит непосредственная обработка и выполнение требуемых действий.

                                               В случае, если при выполнении обработчика произошла ошибка, произойдет откат транзакции и состояние процесса будет возвращено к заданию, исполнение которого повлекло вызов обработчика. В интерфейсе обработчика для бота ru.runa.wfe.extension.TaskHandler предусмотрен метод onRollback для работы с не-транзакционными ресурсами.

                                               Эти обработчики удобно использовать для простых операций (например для отправки оповещений в виде SMS-сообщений если процесс попал в определенное состояние). Но у них есть несколько ограничений. Прежде всего у них нет соответствующего объекта контекста безопасности (security context). Это означает, что в них нельзя выполнять защищенные методы (запуск процессов, выполнение задач, создание пользователей и т.п.) Ошибочным решением в них будет блокирование выполнения процесса (например с Thread::Sleep(...)). Например, если в обработчике отправляется e-mail, а SMTP сервер недоступен, обработчику нельзя "задерживать" свое выполнение.

                                               Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                                               # Специфика обработчиков для ботов
                                               Бот - это сокращение от робот. В системе боты - это особый тип исполнителей. Система не отличает ботов от людей. У каждого бота есть свои права на вход в систему, он периодически просыпается, проверяет свой список задачи и выполняет обнаруженные там задачи.

                                               Каждая задача бота обрабатывается при помощи соответствующего обработчика. Чтобы написать новый обработчик нужно реализовать интерфейс ru.runa.wfe.extension.TaskHandler.

                                               Обратите внимание, что этот вид обработчиков выполняется в контексте безопасности (security context) пользователя-бота, и здесь может выполнятся любая операция (если у бота есть на это права).

                                               Обработчики задач ботов могут блокировать выполнение процесса.

                                               Например, обработчик задач, отправляющий e-mail может блокировать выполнение бизнес процесса до тех пор, пока обработчик не удостоверится, что SMTP сервер принял сообщение для последующей доставки.

                                               Обработчики задач вызываются периодически, когда боты проверяют свои списки задач.

                                               # Специфика обработчика для элемента ветвление
                                               Обработчик для Decision является java-классом, реализующим интерфейс ru.runa.wfe.extension.DecisionHandler. Интерфейс содержит один метод decide(ExecutionContext executionContext), который возвращает имя выбранного перехода (одного из выходящих из данного ветвления). Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов контекста спринга (например с помощью аннотации @Autowired).

                                               Обработчик принимает ExecutionContext в качестве входящего параметра и должен сделать выбор перехода исходя из значений переменных бизнес процесса и условий, указанных в конфигурации обработчика. Точно также как обработчики действия (action handler) обработчики выбора (decision handlers) не могут использовать защищенные (secured) методы, не могут обрабатывать ошибки и откладывать выбор перехода до лучших времен.

                                               По умолчанию используется ru.runa.wfe.extension.decision.GroovyDecisionHandler.

                                               # Использование ru.runa.wfe.extension.handler.CommonParamBasedHandler в качестве базового класса
                                               Этот класс инкапсулирует в себе парсинг XML конфигурации определенного формата. Его удобно использовать если обработчик имеет фиксированное число параметров. Пример конфигурации:

                                               <?xml version="1.0" encoding="UTF-8"?>
                                               <config>
                                                <input>
                                                  <param name="typeName" variable="тип отсутствия" />
                                                  <param name="employee" variable="сотрудник" />
                                                  <param name="requester" variable="подавший заявку" />
                                                  <param name="from" variable="дата с" />
                                                  <param name="to" variable="дата по" />
                                                  <param name="cause" variable="причина" />
                                                  <param name="comment" variable="комментарий" />
                                                  <param name="confirmation" variable="дата подтверждения" />
                                                  <param name="firmCode" value="111" />
                                                  <param name="firmPositionCode" variable="код должности" />
                                                  <param name="firmDepartmentCode" variable="код подразделения" />
                                                </input>
                                                <output>
                                                  <param name="uuid" variable="идентификатор объекта" />
                                                </output>
                                               </config>
                                               Использование обработчика Groovy
                                               См. соответствующий раздел в руководстве по работе с Groovy.

                                               # Как написать функцию над организационной структурой
                                               Функции над организационной структурой в системе применяются, например, при инициализации Ролей-Дорожек и в правилах замещения.

                                               Класс, соответствующий функции над организационной структурой, должен реализовывать интерфейс ru.runa.wfe.extension.OrgFunction.

                                               Интерфейс содержит один метод

                                               List<? extends Executor> getExecutors(Object... parameters)
                                               Этот метод должен возвращать список исполнителей.

                                               В бизнес-процессе обработчик функции над оргструктурой используются при определении Ролей-Дорожек: указывается внутри тега swimlane, в теле тега <assignment>.В качестве параметра class тега <assignment> указывается класс-обработчик для инициализации swimlane: ru.runa.wfe.extension.AssignmentHandler. Внутри тега <assignment> содержится конфигурация для этого класса, которая представляет собой имя класса-наследника интерфейса OrgFunction и список параметров в скобках. В качестве параметра может выступать конкретное значение или имя переменной бизнес процесса в фигурных скобках, перед которым стоит значок $

                                               Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                                               Если есть планы по использованию функции в подсистеме замещений - её можно зарегистрировать в substitutions.xml.

                                               # Как написать критерий замещения
                                               Критерии замещения в системе применяются в правилах замещения. Класс, соответствующий критерию замещения, должен наследоваться от ru.runa.wfe.ss.SubstitutionCriteria.

                                               Для создания на основе него конечных критериев замещения с конфигурациями - его нужно зарегистрировать в substitution.criterias.xml.

                                               Как реализовать класс-формат для переменных бизнес-процесса
                                               См. соответствующий раздел в руководстве по работе с переменными.

                                               # Как реализовать валидатор переменных
                                               Классы, расширяющие абстрактный класс ru.runa.wfe.validation.FieldValidator, в системе применяются для проверки переменных при выполнении задания или старте процесса.

                                               Пример:

                                               public class OvertimeWorkRequestTimeCheck extends FieldValidator {
                                                  @Override
                                                  public void validate() {
                                                      Date date = (Date) getFieldValue();
                                                      if (date == null) {
                                                          return;
                                                      }
                                                      boolean testMode = getVariableProvider().getValueNotNull(boolean.class, "тестовый режим");
                                                      if (testMode) {
                                                          return;
                                                      }
                                                      Calendar calendar = CalendarUtil.dateToCalendar(date);
                                                      if (calendar.before(Calendar.getInstance())) {
                                                          addError("Заявка не может быть оформлена задним числом");
                                                          return;
                                                      }
                                                      CalendarUtil.setTimeFromCalendar(calendar, DemoProperties.getOvertimeWorkRequestMaximumStartTime());
                                                      Utils.adjustCalendarForHolidaysInOvertimwWork(calendar);
                                                      if (calendar.before(Calendar.getInstance())) {
                                                          addError("Заявка на этот день не может быть подана, время подачи истекло " + CalendarUtil.formatDateTime(calendar));
                                                      }
                                                  }
                                               }

                                               Связь между Средой разработки и сервером осуществляется по имени валидатора, регистрация требуется на стороне сервера в файле validators.xml, а в среде разработки - в plugin.xml.

                                               # Как реализовать FreeMarker тег для формы
                                               FreemarkerForms#Components

                                               # Как реализовать Ajax команду
                                               Классы, расширяющие абстрактный класс ru.runa.wfe.commons.web.JsonAjaxCommand, (или реализующие ru.runa.wfe.commons.web.AjaxCommand) в системе применяются для доступа к функциональности сервера из JavaScript, например при отображении форм задания.

                                               Регистрация команды происходит любым из двух способов:

                                               в файле ajax.commands.xml, ей присваивается определенное имя
                                               в контексте приложения, именем является id spring-бина
                                               Затем по этому имени её можно выполнить используя JavaScript.

                                               Пример команды

                                               public class GetOrganizationNamesCommand extends JsonAjaxCommand {
                                                  @Autowired
                                                  private OrganizationDAO organizationDAO;
                                                  @Override
                                                  protected JSONAware execute(User user, HttpServletRequest request) throws Exception {
                                                      String term = request.getParameter("term");
                                                      if (term == null) {
                                                          term = "";
                                                      }
                                                      List<Organization> organizations = organizationDAO.getAll();
                                                      JSONArray array = new JSONArray();
                                                      for (Organization organization : organizations) {
                                                          if (organization.getName().startsWith(term)) {
                                                              array.add(organization.getName());
                                                          }
                                                      }
                                                      return array;
                                                  }
                                               }
                                               Регистрация в wfe.custom.ajax.commands.xml

                                               <?xml version="1.0" encoding="UTF-8" ?>
                                               <configuration xmlns="http://runa.ru/xml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://runa.ru/xml">
                                                <command name="getOrganizationNames" class="ru.runa.rkdemo.web.ajax.GetOrganizationNamesCommand" />
                                               </configuration>
                                               Её использование со скрипта формы (autocomplete input)

                                               $(document).ready(function() {
                                                $('#editLinkedLists').on("onRowAdded", function(event, rowIndex) {
                                                 $("input[name='названия организаций["+rowIndex+"]']").autocomplete( {
                                                  delay: 300,
                                                  minLength: 0,
                                                  source: "/wfe/ajaxcmd?command=getOrganizationNames"
                                                 });
                                                 $("input[name='названия организаций["+rowIndex+"]']").focus(function() {
                                                  $(this).autocomplete("search", $(this).val());
                                                 });
                                                });
                                               });Введение
                                                  # Основные компоненты и используемые технологии
                                                  Для WF–системы была выбрана следующая общая архитектура (в целом соответствует архитектуре, предлагаемой коалицией WfMC):

                                                  Компоненты системы:

                                                  Ядро системы
                                                  Содержит набор определений бизнес-процессов
                                                  Содержит набор выполняющихся экземпляров бизнес–процессов
                                                  Компонент, "назначающий" исполнителей для действий
                                                  Клиент
                                                  Список заданий (набор графических форм, содержит очереди поступивших работ, сортировки и фильтры)
                                                  Проигрыватель форм (отображает формы, разработанные в Среде разработки)
                                                  Административный интерфейс
                                                  Показывает состояния процессов, позволяет фильтровать и останавливать процессы
                                                  Позволяет загружать-выгружать процессы
                                                  Позволяет заводить-удалять пользователей
                                                  Позволяет задавать различные права
                                                  Редактор назначения заместителей
                                                  Среда разработки
                                                  Конструктор графических форм
                                                  Бот станции, содержащие ботов (Боты - приложения специального вида, которые также как и обычные пользователи могут выполнять задания)
                                                  Подсистема управления правами доступа (авторизация и аутентификация)
                                                  # Платформа программирования и используемые программные средства
                                                  В качестве платформы программирования используется J2EE.

                                                  Используемые программные средства:

                                                  Сервер приложений - JBOSS (http://www.jboss.org).
                                                  Среда разработки - любая, например Eclipse от IBM (http://www.eclipse.org).
                                                  Система контроля версий - git
                                                  Сборщик приложений – maven.
                                                  Сервер баз данных – поддерживаются сервера БД:
                                                  MS SQL Server (http://www.microsoft.com/sql/evaluation/default.mspx)
                                                  HSQL (http://hsqldb.org)
                                                  Oracle (http://www.oracle.com)
                                                  PostgreSQL (http://postgresql.com)
                                                  Операционная система — поддерживаются следующие ОС:
                                                  Windows (Server 2000-2008, XP, Vista, 7)
                                                  ALTLinux
                                                  Mandriva Linux
                                                  Fedora
                                                  Debian/Ubuntu
                                                  # Описание проектов
                                                  Название проекта	Обязателен при сборке	Обязателен при работе	Зависимости	Описание
                                                  wfe-alfresco	нет	нет	runawfe-app	Интеграция с Alfresco
                                                  wfe-app	да	да	wfe-ear, wfe-cactus-it	Проект для организации сборки maven
                                                  wfe-appserver	нет	нет	 ?	Не используется
                                                  wfe-bots	да	да	wfe-service	Подсистема ботов
                                                  wfe-cactus-it	да	нет	wfe-service	Интеграционные тесты
                                                  wfe-core	да	да	-	Основные компоненты системы
                                                  wfe-ear	да	да	wfe-service, wfe-bots, wfe-office, wfe-web	Проект для сборки runawfe.ear
                                                  wfe-office	да	нет	wfe-core	Обработчики для работы с Word, Excel
                                                  wfe-service	да	да	wfe-core	Сервисы (EJB + WebServices), представляющие собой публичное API приложения
                                                  wfe-web	да	да	wfe-bots	Визуальная часть приложения
                                                  wfe-webservice-client	нет	нет	 ?	Авто-генерации клиентской библиотеки на основе WSDL серверных сервисов. В нем же есть примеры использования веб-служб из Java клиента.
                                                  # Описание слоев архитектуры системы
                                                  Каждый компонент состоит из нескольких уровней (слоев).

                                                  Список слоев:

                                                  delegate
                                                  service
                                                  logic
                                                  DAO
                                                  hibernate
                                                  # Слой Delegate
                                                  Delegate-классы, реализующие сервисные интерфейсы представляют собой pattern проектирования BusinessDelegate, упрощающий доступ к серверному API системы. Клиентское приложение взаимодействует с системой только через Delegate-классы. Delegate-классы получаются посредством запроса фабрики Delegates, которая в зависимости от конфигурации возвращает нужную реализацию. Классы Delegate являются частью клиентского API.

                                                  Список основных Delegate-классов:

                                                  AuthenticationServiceDelegate – содержит методы для аутентификации пользователей в системе (с использованием логина/пароля, Kerberos и т.п.)
                                                  AuthorizationServiceDelegate — содержит методы для работы с полномочиями пользователей (назначение полномочий, проверка на допустимость операции для пользователя и т.п.)
                                                  BotServiceDelegate — содержит методы для работы с бот станциями и ботами
                                                  ExecutorServiceDelegate — содержит методы для работы с исполнителями. Позволяет создавать/удалять/изменять исполнителей а так же включать их в группы
                                                  ProfileServiceDelegate — содержит методы для работы с профайлам пользователей
                                                  SubstitutionServiceDelegate — содержит методы для управления правилами замещения
                                                  SystemServiceDelegate — содержит методы для входа/выхода пользователя в систему
                                                  DefinitionServiceDelegate — содержит методы для работы с определениями процессов
                                                  ExecutionServiceDelegate — содержит методы для работы с исполняемыми экземплярами процессов
                                                  Все существующие в данный момент Delegate-классы реализуют требуемую функциональность при помощи технологии EJB.

                                                  # Слой Service
                                                  Слой service – это серверное API доступа к системе. Реализации Delegate интерфейсов обращаются именно к этому слою. Каждый Delegate работает с одним соответствующим классом Service. В настоящее время все разработанные service классы и интерфейсы ориентированы на EJB-технологию, однако в будущем возможны и другие реализации. Реализации классов Service являются Stateless Session Bean EJB, которые декларативно поддерживают транзакционность вызовов и запрашивают соответствующие классы из слоя Logic.

                                                  Таким образом, классы Delegate – Service - Logic образуют как бы «транспорт» между клиентом и сервером.

                                                  # Слой Logic
                                                  Слой Logic – это реализация бизнес логики работы системы. Слой работает с классами слоя DAO для доступа к постоянному хранилищу.

                                                  # Слой DAO
                                                  Слой DAO – это интерфейсы и классы, обеспечивающие доступ к данным, находящимся в постоянном хранилище (базе данных). В настоящее время все DAO-классы системы реализованы при помощи ORM-средства Hibernate.

                                                  # Использование Hibernate
                                                  Hibernate – ORM (Object/Relational Mapping) средство. Отображает объектную архитектуру на реляционную структуру данных. Допускает настройку (не меняя разработанного кода) на большинство существующих серверов реляционных баз данных.

                                                  Поддерживает работу с распределенными транзакциями, автоматически создает таблицы для новых классов и т.д. Вся работа с данными внутри системы ведется только через Hibernate.

                                                  Все компоненты, предоставляющие клиентское API построены с использованием описанных выше слоев. В целях оптимизации в некоторых компонентах применяется кеширование, которое может встречаться на уровне logic или DAO. Основная функциональность по управлению кешами находится в классах CachingLogic, CacheInterceptor и классах соответствующих кешей. Изменения в кешируемых объектах перехватываются и сообщаются посредством CachingLogic всем подписавшимся на изменения классам кешей. Транзакция, изменяющая кеш, считается закрытой по окончанию обработки ejb вызова.

                                                  # Обновление базы данных
                                                  см. описание системы патчей.

                                                  # API
                                                  Система представляет API для интеграции с другими системами:

                                                  # Java API
                                                  Реализация (снизу вверх): БД - Hibernate3 - EJB3

                                                  Документацию можно смотреть в исходном коде (javadocs в *Service.java).

                                                  # WebServices API
                                                  Реализация (снизу вверх): БД - Hibernate3 - JAX-WS

                                                  Документация: WebServicesDeveloperGuide

                                                  # Scripting API
                                                  Реализация (снизу вверх): БД - Hibernate3 - XML Script

                                                  Документация: AdminScriptGuide

                                                  # Процесс сборки из исходного кода
                                                  Исходный код системы доступен в открытом репозитории на github.

                                                  Сервер можно собирать как средствами maven используя командную строку, так и используя среду Eclipse IDE.

                                                  В результате сборки будет сформирован runawfe.ear, который теоретически можно запустить на любом сервере приложений. Начиная с версии 4.3.0 введена поддержка JAVA версии 8, и отказ от JAVA 6. В дальнейшем планируется отказ от java7, поэтому рекомендуется использовать сервер приложений wildfly.

                                                  # Процесс сборки на примере Eclipse IDE
                                                  # Необходимое программное обеспечение для сборки
                                                  В отличие от Среды разработки для сборки сервера можно использовать Eclipse IDE любой версии и редакции.

                                                  установите плагин m2eclipse
                                                  используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу: http://maven.apache.org/
                                                  добавьте путь к Apache Maven директории bin в переменную окружения Path
                                                  # Импорт проектов
                                                  Импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server.

                                                  Eclipse srv proj.png

                                                  # Установка maven артефактов
                                                  Выполните

                                                  ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                                                  ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                                                  или другим способом установите артефакты в локальный репозиторий

                                                  # Сборка
                                                  Заведите конфигурацию запуска на основе maven как показано на рисунке

                                                  Maven.build.configuration.png

                                                  Запустите конфигурацию.

                                                  Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\eclipse-workspace\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"

                                                  # Сборка из командной строки
                                                  используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу http://maven.apache.org/
                                                  добавьте путь к Apache Maven директории bin в переменную окружения Path
                                                  импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server
                                                  выполните обновление зависимостей
                                                  ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                                                  ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                                                  откройте командную строку
                                                  перейдите в директорию ${wfe}/wfe-app/
                                                  выполните команду для сборки
                                                  mvn clean package -Dmaven.test.skip=true
                                                  Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"


                                                  Для установки артефактов в локальный репозиторий используйте команду

                                                  mvn clean install -Dmaven.test.skip=true
                                                  # Использование ear на сервере приложений
                                                  cкачайте текущую версию RunaWFE в виде файл-архива исполняемых java файлов runawfe-wildfly-java8-*.zip (на базе wildfly, java8)
                                                  распакуйте архив
                                                  обновите runawfe.ear на версию полученную в результате сборки
                                                  # Расширение функциональности
                                                  # Точки расширения системы
                                                  Обработчики позволяют исполнить код в процессах (элементы "Обработчик", "Задача сценария") и ботах
                                                  Форматы переменных определяют тип переменных и правила преобразования значений к текстовому представлению и обратно
                                                  Организационные функции используются при назначении ролей и в правилах замещения для определения заместителя
                                                  Критерии замещения используются в подсистеме замещения для определения заместителя при построении списка заданий
                                                  Валидаторы обеспечивают проверку переменных при выполнении задания (в т.ч. введенные значения форм)
                                                  Freemarker теги форм генерируют html код для отображения на форме
                                                  Ajax команды предоставляют доступ к функциональности сервера из JavaScript
                                                  # Процесс разработки расширений
                                                  Создайте новый java-проект и подключите необходимые зависимости (wfe-core, wfe-service).

                                                  Реализуйте в нем требуемые расширения и соберите его в виде jar-файла.

                                                  Замечание. Использование maven облегчит процесс управления зависимостями.

                                                  Разместить собранный jar на сервере вы можете:

                                                  положив его в runawfe.ear!/lib
                                                  положив его в директорию deploy (только для jboss4)
                                                  положив его в ${jboss.server.base.dir}/wfe.custom (только для jboss7)
                                                  положив его в ${jboss.server.base.dir}/${jboss.server.name}/wfe.custom (только для jboss4)
                                                  # Обработчики
                                                  Обработчик в процессе – компонент процесса (элементы "Обработчик", "Задача сценария"), использующийся для выполнения каких-либо действий при возникновении определенных событий (проход по определенному переходу в процессе, приход или уход управления из узла и т.п.).

                                                  Обработчик должен реализовывать интерфейс ru.runa.wfe.extension.ActionHandler. Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов Spring контекста (например с помощью аннотации @Autowired).

                                                  При написании нового обработчика рекомендуется наследовать его от абстрактного класса ru.runa.wfe.extension.handler.CommonHandler или ru.runa.wfe.extension.handler.CommonParamBasedHandler. В методе setConfiguration обработчик должен запомнить свои параметры (если обработчик их ожидает), а в методе execute происходит непосредственная обработка и выполнение требуемых действий.

                                                  В случае, если при выполнении обработчика произошла ошибка, произойдет откат транзакции и состояние процесса будет возвращено к заданию, исполнение которого повлекло вызов обработчика. В интерфейсе обработчика для бота ru.runa.wfe.extension.TaskHandler предусмотрен метод onRollback для работы с не-транзакционными ресурсами.

                                                  Эти обработчики удобно использовать для простых операций (например для отправки оповещений в виде SMS-сообщений если процесс попал в определенное состояние). Но у них есть несколько ограничений. Прежде всего у них нет соответствующего объекта контекста безопасности (security context). Это означает, что в них нельзя выполнять защищенные методы (запуск процессов, выполнение задач, создание пользователей и т.п.) Ошибочным решением в них будет блокирование выполнения процесса (например с Thread::Sleep(...)). Например, если в обработчике отправляется e-mail, а SMTP сервер недоступен, обработчику нельзя "задерживать" свое выполнение.

                                                  Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                                                  # Специфика обработчиков для ботов
                                                  Бот - это сокращение от робот. В системе боты - это особый тип исполнителей. Система не отличает ботов от людей. У каждого бота есть свои права на вход в систему, он периодически просыпается, проверяет свой список задачи и выполняет обнаруженные там задачи.

                                                  Каждая задача бота обрабатывается при помощи соответствующего обработчика. Чтобы написать новый обработчик нужно реализовать интерфейс ru.runa.wfe.extension.TaskHandler.

                                                  Обратите внимание, что этот вид обработчиков выполняется в контексте безопасности (security context) пользователя-бота, и здесь может выполнятся любая операция (если у бота есть на это права).

                                                  Обработчики задач ботов могут блокировать выполнение процесса.

                                                  Например, обработчик задач, отправляющий e-mail может блокировать выполнение бизнес процесса до тех пор, пока обработчик не удостоверится, что SMTP сервер принял сообщение для последующей доставки.

                                                  Обработчики задач вызываются периодически, когда боты проверяют свои списки задач.

                                                  # Специфика обработчика для элемента ветвление
                                                  Обработчик для Decision является java-классом, реализующим интерфейс ru.runa.wfe.extension.DecisionHandler. Интерфейс содержит один метод decide(ExecutionContext executionContext), который возвращает имя выбранного перехода (одного из выходящих из данного ветвления). Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов контекста спринга (например с помощью аннотации @Autowired).

                                                  Обработчик принимает ExecutionContext в качестве входящего параметра и должен сделать выбор перехода исходя из значений переменных бизнес процесса и условий, указанных в конфигурации обработчика. Точно также как обработчики действия (action handler) обработчики выбора (decision handlers) не могут использовать защищенные (secured) методы, не могут обрабатывать ошибки и откладывать выбор перехода до лучших времен.

                                                  По умолчанию используется ru.runa.wfe.extension.decision.GroovyDecisionHandler.

                                                  # Использование ru.runa.wfe.extension.handler.CommonParamBasedHandler в качестве базового класса
                                                  Этот класс инкапсулирует в себе парсинг XML конфигурации определенного формата. Его удобно использовать если обработчик имеет фиксированное число параметров. Пример конфигурации:

                                                  <?xml version="1.0" encoding="UTF-8"?>
                                                  <config>
                                                   <input>
                                                     <param name="typeName" variable="тип отсутствия" />
                                                     <param name="employee" variable="сотрудник" />
                                                     <param name="requester" variable="подавший заявку" />
                                                     <param name="from" variable="дата с" />
                                                     <param name="to" variable="дата по" />
                                                     <param name="cause" variable="причина" />
                                                     <param name="comment" variable="комментарий" />
                                                     <param name="confirmation" variable="дата подтверждения" />
                                                     <param name="firmCode" value="111" />
                                                     <param name="firmPositionCode" variable="код должности" />
                                                     <param name="firmDepartmentCode" variable="код подразделения" />
                                                   </input>
                                                   <output>
                                                     <param name="uuid" variable="идентификатор объекта" />
                                                   </output>
                                                  </config>
                                                  Использование обработчика Groovy
                                                  См. соответствующий раздел в руководстве по работе с Groovy.

                                                  # Как написать функцию над организационной структурой
                                                  Функции над организационной структурой в системе применяются, например, при инициализации Ролей-Дорожек и в правилах замещения.

                                                  Класс, соответствующий функции над организационной структурой, должен реализовывать интерфейс ru.runa.wfe.extension.OrgFunction.

                                                  Интерфейс содержит один метод

                                                  List<? extends Executor> getExecutors(Object... parameters)
                                                  Этот метод должен возвращать список исполнителей.

                                                  В бизнес-процессе обработчик функции над оргструктурой используются при определении Ролей-Дорожек: указывается внутри тега swimlane, в теле тега <assignment>.В качестве параметра class тега <assignment> указывается класс-обработчик для инициализации swimlane: ru.runa.wfe.extension.AssignmentHandler. Внутри тега <assignment> содержится конфигурация для этого класса, которая представляет собой имя класса-наследника интерфейса OrgFunction и список параметров в скобках. В качестве параметра может выступать конкретное значение или имя переменной бизнес процесса в фигурных скобках, перед которым стоит значок $

                                                  Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                                                  Если есть планы по использованию функции в подсистеме замещений - её можно зарегистрировать в substitutions.xml.

                                                  # Как написать критерий замещения
                                                  Критерии замещения в системе применяются в правилах замещения. Класс, соответствующий критерию замещения, должен наследоваться от ru.runa.wfe.ss.SubstitutionCriteria.

                                                  Для создания на основе него конечных критериев замещения с конфигурациями - его нужно зарегистрировать в substitution.criterias.xml.

                                                  Как реализовать класс-формат для переменных бизнес-процесса
                                                  См. соответствующий раздел в руководстве по работе с переменными.

                                                  # Как реализовать валидатор переменных
                                                  Классы, расширяющие абстрактный класс ru.runa.wfe.validation.FieldValidator, в системе применяются для проверки переменных при выполнении задания или старте процесса.

                                                  Пример:

                                                  public class OvertimeWorkRequestTimeCheck extends FieldValidator {
                                                     @Override
                                                     public void validate() {
                                                         Date date = (Date) getFieldValue();
                                                         if (date == null) {
                                                             return;
                                                         }
                                                         boolean testMode = getVariableProvider().getValueNotNull(boolean.class, "тестовый режим");
                                                         if (testMode) {
                                                             return;
                                                         }
                                                         Calendar calendar = CalendarUtil.dateToCalendar(date);
                                                         if (calendar.before(Calendar.getInstance())) {
                                                             addError("Заявка не может быть оформлена задним числом");
                                                             return;
                                                         }
                                                         CalendarUtil.setTimeFromCalendar(calendar, DemoProperties.getOvertimeWorkRequestMaximumStartTime());
                                                         Utils.adjustCalendarForHolidaysInOvertimwWork(calendar);
                                                         if (calendar.before(Calendar.getInstance())) {
                                                             addError("Заявка на этот день не может быть подана, время подачи истекло " + CalendarUtil.formatDateTime(calendar));
                                                         }
                                                     }
                                                  }

                                                  Связь между Средой разработки и сервером осуществляется по имени валидатора, регистрация требуется на стороне сервера в файле validators.xml, а в среде разработки - в plugin.xml.

                                                  # Как реализовать FreeMarker тег для формы
                                                  FreemarkerForms#Components

                                                  # Как реализовать Ajax команду
                                                  Классы, расширяющие абстрактный класс ru.runa.wfe.commons.web.JsonAjaxCommand, (или реализующие ru.runa.wfe.commons.web.AjaxCommand) в системе применяются для доступа к функциональности сервера из JavaScript, например при отображении форм задания.

                                                  Регистрация команды происходит любым из двух способов:

                                                  в файле ajax.commands.xml, ей присваивается определенное имя
                                                  в контексте приложения, именем является id spring-бина
                                                  Затем по этому имени её можно выполнить используя JavaScript.

                                                  Пример команды

                                                  public class GetOrganizationNamesCommand extends JsonAjaxCommand {
                                                     @Autowired
                                                     private OrganizationDAO organizationDAO;
                                                     @Override
                                                     protected JSONAware execute(User user, HttpServletRequest request) throws Exception {
                                                         String term = request.getParameter("term");
                                                         if (term == null) {
                                                             term = "";
                                                         }
                                                         List<Organization> organizations = organizationDAO.getAll();
                                                         JSONArray array = new JSONArray();
                                                         for (Organization organization : organizations) {
                                                             if (organization.getName().startsWith(term)) {
                                                                 array.add(organization.getName());
                                                             }
                                                         }
                                                         return array;
                                                     }
                                                  }
                                                  Регистрация в wfe.custom.ajax.commands.xml

                                                  <?xml version="1.0" encoding="UTF-8" ?>
                                                  <configuration xmlns="http://runa.ru/xml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://runa.ru/xml">
                                                   <command name="getOrganizationNames" class="ru.runa.rkdemo.web.ajax.GetOrganizationNamesCommand" />
                                                  </configuration>
                                                  Её использование со скрипта формы (autocomplete input)

                                                  $(document).ready(function() {
                                                   $('#editLinkedLists').on("onRowAdded", function(event, rowIndex) {
                                                    $("input[name='названия организаций["+rowIndex+"]']").autocomplete( {
                                                     delay: 300,
                                                     minLength: 0,
                                                     source: "/wfe/ajaxcmd?command=getOrganizationNames"
                                                    });
                                                    $("input[name='названия организаций["+rowIndex+"]']").focus(function() {
                                                     $(this).autocomplete("search", $(this).val());
                                                    });
                                                   });
                                                  });Введение
                                                     # Основные компоненты и используемые технологии
                                                     Для WF–системы была выбрана следующая общая архитектура (в целом соответствует архитектуре, предлагаемой коалицией WfMC):

                                                     Компоненты системы:

                                                     Ядро системы
                                                     Содержит набор определений бизнес-процессов
                                                     Содержит набор выполняющихся экземпляров бизнес–процессов
                                                     Компонент, "назначающий" исполнителей для действий
                                                     Клиент
                                                     Список заданий (набор графических форм, содержит очереди поступивших работ, сортировки и фильтры)
                                                     Проигрыватель форм (отображает формы, разработанные в Среде разработки)
                                                     Административный интерфейс
                                                     Показывает состояния процессов, позволяет фильтровать и останавливать процессы
                                                     Позволяет загружать-выгружать процессы
                                                     Позволяет заводить-удалять пользователей
                                                     Позволяет задавать различные права
                                                     Редактор назначения заместителей
                                                     Среда разработки
                                                     Конструктор графических форм
                                                     Бот станции, содержащие ботов (Боты - приложения специального вида, которые также как и обычные пользователи могут выполнять задания)
                                                     Подсистема управления правами доступа (авторизация и аутентификация)
                                                     # Платформа программирования и используемые программные средства
                                                     В качестве платформы программирования используется J2EE.

                                                     Используемые программные средства:

                                                     Сервер приложений - JBOSS (http://www.jboss.org).
                                                     Среда разработки - любая, например Eclipse от IBM (http://www.eclipse.org).
                                                     Система контроля версий - git
                                                     Сборщик приложений – maven.
                                                     Сервер баз данных – поддерживаются сервера БД:
                                                     MS SQL Server (http://www.microsoft.com/sql/evaluation/default.mspx)
                                                     HSQL (http://hsqldb.org)
                                                     Oracle (http://www.oracle.com)
                                                     PostgreSQL (http://postgresql.com)
                                                     Операционная система — поддерживаются следующие ОС:
                                                     Windows (Server 2000-2008, XP, Vista, 7)
                                                     ALTLinux
                                                     Mandriva Linux
                                                     Fedora
                                                     Debian/Ubuntu
                                                     # Описание проектов
                                                     Название проекта	Обязателен при сборке	Обязателен при работе	Зависимости	Описание
                                                     wfe-alfresco	нет	нет	runawfe-app	Интеграция с Alfresco
                                                     wfe-app	да	да	wfe-ear, wfe-cactus-it	Проект для организации сборки maven
                                                     wfe-appserver	нет	нет	 ?	Не используется
                                                     wfe-bots	да	да	wfe-service	Подсистема ботов
                                                     wfe-cactus-it	да	нет	wfe-service	Интеграционные тесты
                                                     wfe-core	да	да	-	Основные компоненты системы
                                                     wfe-ear	да	да	wfe-service, wfe-bots, wfe-office, wfe-web	Проект для сборки runawfe.ear
                                                     wfe-office	да	нет	wfe-core	Обработчики для работы с Word, Excel
                                                     wfe-service	да	да	wfe-core	Сервисы (EJB + WebServices), представляющие собой публичное API приложения
                                                     wfe-web	да	да	wfe-bots	Визуальная часть приложения
                                                     wfe-webservice-client	нет	нет	 ?	Авто-генерации клиентской библиотеки на основе WSDL серверных сервисов. В нем же есть примеры использования веб-служб из Java клиента.
                                                     # Описание слоев архитектуры системы
                                                     Каждый компонент состоит из нескольких уровней (слоев).

                                                     Список слоев:

                                                     delegate
                                                     service
                                                     logic
                                                     DAO
                                                     hibernate
                                                     # Слой Delegate
                                                     Delegate-классы, реализующие сервисные интерфейсы представляют собой pattern проектирования BusinessDelegate, упрощающий доступ к серверному API системы. Клиентское приложение взаимодействует с системой только через Delegate-классы. Delegate-классы получаются посредством запроса фабрики Delegates, которая в зависимости от конфигурации возвращает нужную реализацию. Классы Delegate являются частью клиентского API.

                                                     Список основных Delegate-классов:

                                                     AuthenticationServiceDelegate – содержит методы для аутентификации пользователей в системе (с использованием логина/пароля, Kerberos и т.п.)
                                                     AuthorizationServiceDelegate — содержит методы для работы с полномочиями пользователей (назначение полномочий, проверка на допустимость операции для пользователя и т.п.)
                                                     BotServiceDelegate — содержит методы для работы с бот станциями и ботами
                                                     ExecutorServiceDelegate — содержит методы для работы с исполнителями. Позволяет создавать/удалять/изменять исполнителей а так же включать их в группы
                                                     ProfileServiceDelegate — содержит методы для работы с профайлам пользователей
                                                     SubstitutionServiceDelegate — содержит методы для управления правилами замещения
                                                     SystemServiceDelegate — содержит методы для входа/выхода пользователя в систему
                                                     DefinitionServiceDelegate — содержит методы для работы с определениями процессов
                                                     ExecutionServiceDelegate — содержит методы для работы с исполняемыми экземплярами процессов
                                                     Все существующие в данный момент Delegate-классы реализуют требуемую функциональность при помощи технологии EJB.

                                                     # Слой Service
                                                     Слой service – это серверное API доступа к системе. Реализации Delegate интерфейсов обращаются именно к этому слою. Каждый Delegate работает с одним соответствующим классом Service. В настоящее время все разработанные service классы и интерфейсы ориентированы на EJB-технологию, однако в будущем возможны и другие реализации. Реализации классов Service являются Stateless Session Bean EJB, которые декларативно поддерживают транзакционность вызовов и запрашивают соответствующие классы из слоя Logic.

                                                     Таким образом, классы Delegate – Service - Logic образуют как бы «транспорт» между клиентом и сервером.

                                                     # Слой Logic
                                                     Слой Logic – это реализация бизнес логики работы системы. Слой работает с классами слоя DAO для доступа к постоянному хранилищу.

                                                     # Слой DAO
                                                     Слой DAO – это интерфейсы и классы, обеспечивающие доступ к данным, находящимся в постоянном хранилище (базе данных). В настоящее время все DAO-классы системы реализованы при помощи ORM-средства Hibernate.

                                                     # Использование Hibernate
                                                     Hibernate – ORM (Object/Relational Mapping) средство. Отображает объектную архитектуру на реляционную структуру данных. Допускает настройку (не меняя разработанного кода) на большинство существующих серверов реляционных баз данных.

                                                     Поддерживает работу с распределенными транзакциями, автоматически создает таблицы для новых классов и т.д. Вся работа с данными внутри системы ведется только через Hibernate.

                                                     Все компоненты, предоставляющие клиентское API построены с использованием описанных выше слоев. В целях оптимизации в некоторых компонентах применяется кеширование, которое может встречаться на уровне logic или DAO. Основная функциональность по управлению кешами находится в классах CachingLogic, CacheInterceptor и классах соответствующих кешей. Изменения в кешируемых объектах перехватываются и сообщаются посредством CachingLogic всем подписавшимся на изменения классам кешей. Транзакция, изменяющая кеш, считается закрытой по окончанию обработки ejb вызова.

                                                     # Обновление базы данных
                                                     см. описание системы патчей.

                                                     # API
                                                     Система представляет API для интеграции с другими системами:

                                                     # Java API
                                                     Реализация (снизу вверх): БД - Hibernate3 - EJB3

                                                     Документацию можно смотреть в исходном коде (javadocs в *Service.java).

                                                     # WebServices API
                                                     Реализация (снизу вверх): БД - Hibernate3 - JAX-WS

                                                     Документация: WebServicesDeveloperGuide

                                                     # Scripting API
                                                     Реализация (снизу вверх): БД - Hibernate3 - XML Script

                                                     Документация: AdminScriptGuide

                                                     # Процесс сборки из исходного кода
                                                     Исходный код системы доступен в открытом репозитории на github.

                                                     Сервер можно собирать как средствами maven используя командную строку, так и используя среду Eclipse IDE.

                                                     В результате сборки будет сформирован runawfe.ear, который теоретически можно запустить на любом сервере приложений. Начиная с версии 4.3.0 введена поддержка JAVA версии 8, и отказ от JAVA 6. В дальнейшем планируется отказ от java7, поэтому рекомендуется использовать сервер приложений wildfly.

                                                     # Процесс сборки на примере Eclipse IDE
                                                     # Необходимое программное обеспечение для сборки
                                                     В отличие от Среды разработки для сборки сервера можно использовать Eclipse IDE любой версии и редакции.

                                                     установите плагин m2eclipse
                                                     используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу: http://maven.apache.org/
                                                     добавьте путь к Apache Maven директории bin в переменную окружения Path
                                                     # Импорт проектов
                                                     Импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server.

                                                     Eclipse srv proj.png

                                                     # Установка maven артефактов
                                                     Выполните

                                                     ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                                                     ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                                                     или другим способом установите артефакты в локальный репозиторий

                                                     # Сборка
                                                     Заведите конфигурацию запуска на основе maven как показано на рисунке

                                                     Maven.build.configuration.png

                                                     Запустите конфигурацию.

                                                     Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\eclipse-workspace\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"

                                                     # Сборка из командной строки
                                                     используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу http://maven.apache.org/
                                                     добавьте путь к Apache Maven директории bin в переменную окружения Path
                                                     импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server
                                                     выполните обновление зависимостей
                                                     ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                                                     ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                                                     откройте командную строку
                                                     перейдите в директорию ${wfe}/wfe-app/
                                                     выполните команду для сборки
                                                     mvn clean package -Dmaven.test.skip=true
                                                     Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"


                                                     Для установки артефактов в локальный репозиторий используйте команду

                                                     mvn clean install -Dmaven.test.skip=true
                                                     # Использование ear на сервере приложений
                                                     cкачайте текущую версию RunaWFE в виде файл-архива исполняемых java файлов runawfe-wildfly-java8-*.zip (на базе wildfly, java8)
                                                     распакуйте архив
                                                     обновите runawfe.ear на версию полученную в результате сборки
                                                     # Расширение функциональности
                                                     # Точки расширения системы
                                                     Обработчики позволяют исполнить код в процессах (элементы "Обработчик", "Задача сценария") и ботах
                                                     Форматы переменных определяют тип переменных и правила преобразования значений к текстовому представлению и обратно
                                                     Организационные функции используются при назначении ролей и в правилах замещения для определения заместителя
                                                     Критерии замещения используются в подсистеме замещения для определения заместителя при построении списка заданий
                                                     Валидаторы обеспечивают проверку переменных при выполнении задания (в т.ч. введенные значения форм)
                                                     Freemarker теги форм генерируют html код для отображения на форме
                                                     Ajax команды предоставляют доступ к функциональности сервера из JavaScript
                                                     # Процесс разработки расширений
                                                     Создайте новый java-проект и подключите необходимые зависимости (wfe-core, wfe-service).

                                                     Реализуйте в нем требуемые расширения и соберите его в виде jar-файла.

                                                     Замечание. Использование maven облегчит процесс управления зависимостями.

                                                     Разместить собранный jar на сервере вы можете:

                                                     положив его в runawfe.ear!/lib
                                                     положив его в директорию deploy (только для jboss4)
                                                     положив его в ${jboss.server.base.dir}/wfe.custom (только для jboss7)
                                                     положив его в ${jboss.server.base.dir}/${jboss.server.name}/wfe.custom (только для jboss4)
                                                     # Обработчики
                                                     Обработчик в процессе – компонент процесса (элементы "Обработчик", "Задача сценария"), использующийся для выполнения каких-либо действий при возникновении определенных событий (проход по определенному переходу в процессе, приход или уход управления из узла и т.п.).

                                                     Обработчик должен реализовывать интерфейс ru.runa.wfe.extension.ActionHandler. Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов Spring контекста (например с помощью аннотации @Autowired).

                                                     При написании нового обработчика рекомендуется наследовать его от абстрактного класса ru.runa.wfe.extension.handler.CommonHandler или ru.runa.wfe.extension.handler.CommonParamBasedHandler. В методе setConfiguration обработчик должен запомнить свои параметры (если обработчик их ожидает), а в методе execute происходит непосредственная обработка и выполнение требуемых действий.

                                                     В случае, если при выполнении обработчика произошла ошибка, произойдет откат транзакции и состояние процесса будет возвращено к заданию, исполнение которого повлекло вызов обработчика. В интерфейсе обработчика для бота ru.runa.wfe.extension.TaskHandler предусмотрен метод onRollback для работы с не-транзакционными ресурсами.

                                                     Эти обработчики удобно использовать для простых операций (например для отправки оповещений в виде SMS-сообщений если процесс попал в определенное состояние). Но у них есть несколько ограничений. Прежде всего у них нет соответствующего объекта контекста безопасности (security context). Это означает, что в них нельзя выполнять защищенные методы (запуск процессов, выполнение задач, создание пользователей и т.п.) Ошибочным решением в них будет блокирование выполнения процесса (например с Thread::Sleep(...)). Например, если в обработчике отправляется e-mail, а SMTP сервер недоступен, обработчику нельзя "задерживать" свое выполнение.

                                                     Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                                                     # Специфика обработчиков для ботов
                                                     Бот - это сокращение от робот. В системе боты - это особый тип исполнителей. Система не отличает ботов от людей. У каждого бота есть свои права на вход в систему, он периодически просыпается, проверяет свой список задачи и выполняет обнаруженные там задачи.

                                                     Каждая задача бота обрабатывается при помощи соответствующего обработчика. Чтобы написать новый обработчик нужно реализовать интерфейс ru.runa.wfe.extension.TaskHandler.

                                                     Обратите внимание, что этот вид обработчиков выполняется в контексте безопасности (security context) пользователя-бота, и здесь может выполнятся любая операция (если у бота есть на это права).

                                                     Обработчики задач ботов могут блокировать выполнение процесса.

                                                     Например, обработчик задач, отправляющий e-mail может блокировать выполнение бизнес процесса до тех пор, пока обработчик не удостоверится, что SMTP сервер принял сообщение для последующей доставки.

                                                     Обработчики задач вызываются периодически, когда боты проверяют свои списки задач.

                                                     # Специфика обработчика для элемента ветвление
                                                     Обработчик для Decision является java-классом, реализующим интерфейс ru.runa.wfe.extension.DecisionHandler. Интерфейс содержит один метод decide(ExecutionContext executionContext), который возвращает имя выбранного перехода (одного из выходящих из данного ветвления). Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов контекста спринга (например с помощью аннотации @Autowired).

                                                     Обработчик принимает ExecutionContext в качестве входящего параметра и должен сделать выбор перехода исходя из значений переменных бизнес процесса и условий, указанных в конфигурации обработчика. Точно также как обработчики действия (action handler) обработчики выбора (decision handlers) не могут использовать защищенные (secured) методы, не могут обрабатывать ошибки и откладывать выбор перехода до лучших времен.

                                                     По умолчанию используется ru.runa.wfe.extension.decision.GroovyDecisionHandler.

                                                     # Использование ru.runa.wfe.extension.handler.CommonParamBasedHandler в качестве базового класса
                                                     Этот класс инкапсулирует в себе парсинг XML конфигурации определенного формата. Его удобно использовать если обработчик имеет фиксированное число параметров. Пример конфигурации:

                                                     <?xml version="1.0" encoding="UTF-8"?>
                                                     <config>
                                                      <input>
                                                        <param name="typeName" variable="тип отсутствия" />
                                                        <param name="employee" variable="сотрудник" />
                                                        <param name="requester" variable="подавший заявку" />
                                                        <param name="from" variable="дата с" />
                                                        <param name="to" variable="дата по" />
                                                        <param name="cause" variable="причина" />
                                                        <param name="comment" variable="комментарий" />
                                                        <param name="confirmation" variable="дата подтверждения" />
                                                        <param name="firmCode" value="111" />
                                                        <param name="firmPositionCode" variable="код должности" />
                                                        <param name="firmDepartmentCode" variable="код подразделения" />
                                                      </input>
                                                      <output>
                                                        <param name="uuid" variable="идентификатор объекта" />
                                                      </output>
                                                     </config>
                                                     Использование обработчика Groovy
                                                     См. соответствующий раздел в руководстве по работе с Groovy.

                                                     # Как написать функцию над организационной структурой
                                                     Функции над организационной структурой в системе применяются, например, при инициализации Ролей-Дорожек и в правилах замещения.

                                                     Класс, соответствующий функции над организационной структурой, должен реализовывать интерфейс ru.runa.wfe.extension.OrgFunction.

                                                     Интерфейс содержит один метод

                                                     List<? extends Executor> getExecutors(Object... parameters)
                                                     Этот метод должен возвращать список исполнителей.

                                                     В бизнес-процессе обработчик функции над оргструктурой используются при определении Ролей-Дорожек: указывается внутри тега swimlane, в теле тега <assignment>.В качестве параметра class тега <assignment> указывается класс-обработчик для инициализации swimlane: ru.runa.wfe.extension.AssignmentHandler. Внутри тега <assignment> содержится конфигурация для этого класса, которая представляет собой имя класса-наследника интерфейса OrgFunction и список параметров в скобках. В качестве параметра может выступать конкретное значение или имя переменной бизнес процесса в фигурных скобках, перед которым стоит значок $

                                                     Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                                                     Если есть планы по использованию функции в подсистеме замещений - её можно зарегистрировать в substitutions.xml.

                                                     # Как написать критерий замещения
                                                     Критерии замещения в системе применяются в правилах замещения. Класс, соответствующий критерию замещения, должен наследоваться от ru.runa.wfe.ss.SubstitutionCriteria.

                                                     Для создания на основе него конечных критериев замещения с конфигурациями - его нужно зарегистрировать в substitution.criterias.xml.

                                                     Как реализовать класс-формат для переменных бизнес-процесса
                                                     См. соответствующий раздел в руководстве по работе с переменными.

                                                     # Как реализовать валидатор переменных
                                                     Классы, расширяющие абстрактный класс ru.runa.wfe.validation.FieldValidator, в системе применяются для проверки переменных при выполнении задания или старте процесса.

                                                     Пример:

                                                     public class OvertimeWorkRequestTimeCheck extends FieldValidator {
                                                        @Override
                                                        public void validate() {
                                                            Date date = (Date) getFieldValue();
                                                            if (date == null) {
                                                                return;
                                                            }
                                                            boolean testMode = getVariableProvider().getValueNotNull(boolean.class, "тестовый режим");
                                                            if (testMode) {
                                                                return;
                                                            }
                                                            Calendar calendar = CalendarUtil.dateToCalendar(date);
                                                            if (calendar.before(Calendar.getInstance())) {
                                                                addError("Заявка не может быть оформлена задним числом");
                                                                return;
                                                            }
                                                            CalendarUtil.setTimeFromCalendar(calendar, DemoProperties.getOvertimeWorkRequestMaximumStartTime());
                                                            Utils.adjustCalendarForHolidaysInOvertimwWork(calendar);
                                                            if (calendar.before(Calendar.getInstance())) {
                                                                addError("Заявка на этот день не может быть подана, время подачи истекло " + CalendarUtil.formatDateTime(calendar));
                                                            }
                                                        }
                                                     }

                                                     Связь между Средой разработки и сервером осуществляется по имени валидатора, регистрация требуется на стороне сервера в файле validators.xml, а в среде разработки - в plugin.xml.

                                                     # Как реализовать FreeMarker тег для формы
                                                     FreemarkerForms#Components

                                                     # Как реализовать Ajax команду
                                                     Классы, расширяющие абстрактный класс ru.runa.wfe.commons.web.JsonAjaxCommand, (или реализующие ru.runa.wfe.commons.web.AjaxCommand) в системе применяются для доступа к функциональности сервера из JavaScript, например при отображении форм задания.

                                                     Регистрация команды происходит любым из двух способов:

                                                     в файле ajax.commands.xml, ей присваивается определенное имя
                                                     в контексте приложения, именем является id spring-бина
                                                     Затем по этому имени её можно выполнить используя JavaScript.

                                                     Пример команды

                                                     public class GetOrganizationNamesCommand extends JsonAjaxCommand {
                                                        @Autowired
                                                        private OrganizationDAO organizationDAO;
                                                        @Override
                                                        protected JSONAware execute(User user, HttpServletRequest request) throws Exception {
                                                            String term = request.getParameter("term");
                                                            if (term == null) {
                                                                term = "";
                                                            }
                                                            List<Organization> organizations = organizationDAO.getAll();
                                                            JSONArray array = new JSONArray();
                                                            for (Organization organization : organizations) {
                                                                if (organization.getName().startsWith(term)) {
                                                                    array.add(organization.getName());
                                                                }
                                                            }
                                                            return array;
                                                        }
                                                     }
                                                     Регистрация в wfe.custom.ajax.commands.xml

                                                     <?xml version="1.0" encoding="UTF-8" ?>
                                                     <configuration xmlns="http://runa.ru/xml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://runa.ru/xml">
                                                      <command name="getOrganizationNames" class="ru.runa.rkdemo.web.ajax.GetOrganizationNamesCommand" />
                                                     </configuration>
                                                     Её использование со скрипта формы (autocomplete input)

                                                     $(document).ready(function() {
                                                      $('#editLinkedLists').on("onRowAdded", function(event, rowIndex) {
                                                       $("input[name='названия организаций["+rowIndex+"]']").autocomplete( {
                                                        delay: 300,
                                                        minLength: 0,
                                                        source: "/wfe/ajaxcmd?command=getOrganizationNames"
                                                       });
                                                       $("input[name='названия организаций["+rowIndex+"]']").focus(function() {
                                                        $(this).autocomplete("search", $(this).val());
                                                       });
                                                      });
                                                     });Введение
                                                        # Основные компоненты и используемые технологии
                                                        Для WF–системы была выбрана следующая общая архитектура (в целом соответствует архитектуре, предлагаемой коалицией WfMC):

                                                        Компоненты системы:

                                                        Ядро системы
                                                        Содержит набор определений бизнес-процессов
                                                        Содержит набор выполняющихся экземпляров бизнес–процессов
                                                        Компонент, "назначающий" исполнителей для действий
                                                        Клиент
                                                        Список заданий (набор графических форм, содержит очереди поступивших работ, сортировки и фильтры)
                                                        Проигрыватель форм (отображает формы, разработанные в Среде разработки)
                                                        Административный интерфейс
                                                        Показывает состояния процессов, позволяет фильтровать и останавливать процессы
                                                        Позволяет загружать-выгружать процессы
                                                        Позволяет заводить-удалять пользователей
                                                        Позволяет задавать различные права
                                                        Редактор назначения заместителей
                                                        Среда разработки
                                                        Конструктор графических форм
                                                        Бот станции, содержащие ботов (Боты - приложения специального вида, которые также как и обычные пользователи могут выполнять задания)
                                                        Подсистема управления правами доступа (авторизация и аутентификация)
                                                        # Платформа программирования и используемые программные средства
                                                        В качестве платформы программирования используется J2EE.

                                                        Используемые программные средства:

                                                        Сервер приложений - JBOSS (http://www.jboss.org).
                                                        Среда разработки - любая, например Eclipse от IBM (http://www.eclipse.org).
                                                        Система контроля версий - git
                                                        Сборщик приложений – maven.
                                                        Сервер баз данных – поддерживаются сервера БД:
                                                        MS SQL Server (http://www.microsoft.com/sql/evaluation/default.mspx)
                                                        HSQL (http://hsqldb.org)
                                                        Oracle (http://www.oracle.com)
                                                        PostgreSQL (http://postgresql.com)
                                                        Операционная система — поддерживаются следующие ОС:
                                                        Windows (Server 2000-2008, XP, Vista, 7)
                                                        ALTLinux
                                                        Mandriva Linux
                                                        Fedora
                                                        Debian/Ubuntu
                                                        # Описание проектов
                                                        Название проекта	Обязателен при сборке	Обязателен при работе	Зависимости	Описание
                                                        wfe-alfresco	нет	нет	runawfe-app	Интеграция с Alfresco
                                                        wfe-app	да	да	wfe-ear, wfe-cactus-it	Проект для организации сборки maven
                                                        wfe-appserver	нет	нет	 ?	Не используется
                                                        wfe-bots	да	да	wfe-service	Подсистема ботов
                                                        wfe-cactus-it	да	нет	wfe-service	Интеграционные тесты
                                                        wfe-core	да	да	-	Основные компоненты системы
                                                        wfe-ear	да	да	wfe-service, wfe-bots, wfe-office, wfe-web	Проект для сборки runawfe.ear
                                                        wfe-office	да	нет	wfe-core	Обработчики для работы с Word, Excel
                                                        wfe-service	да	да	wfe-core	Сервисы (EJB + WebServices), представляющие собой публичное API приложения
                                                        wfe-web	да	да	wfe-bots	Визуальная часть приложения
                                                        wfe-webservice-client	нет	нет	 ?	Авто-генерации клиентской библиотеки на основе WSDL серверных сервисов. В нем же есть примеры использования веб-служб из Java клиента.
                                                        # Описание слоев архитектуры системы
                                                        Каждый компонент состоит из нескольких уровней (слоев).

                                                        Список слоев:

                                                        delegate
                                                        service
                                                        logic
                                                        DAO
                                                        hibernate
                                                        # Слой Delegate
                                                        Delegate-классы, реализующие сервисные интерфейсы представляют собой pattern проектирования BusinessDelegate, упрощающий доступ к серверному API системы. Клиентское приложение взаимодействует с системой только через Delegate-классы. Delegate-классы получаются посредством запроса фабрики Delegates, которая в зависимости от конфигурации возвращает нужную реализацию. Классы Delegate являются частью клиентского API.

                                                        Список основных Delegate-классов:

                                                        AuthenticationServiceDelegate – содержит методы для аутентификации пользователей в системе (с использованием логина/пароля, Kerberos и т.п.)
                                                        AuthorizationServiceDelegate — содержит методы для работы с полномочиями пользователей (назначение полномочий, проверка на допустимость операции для пользователя и т.п.)
                                                        BotServiceDelegate — содержит методы для работы с бот станциями и ботами
                                                        ExecutorServiceDelegate — содержит методы для работы с исполнителями. Позволяет создавать/удалять/изменять исполнителей а так же включать их в группы
                                                        ProfileServiceDelegate — содержит методы для работы с профайлам пользователей
                                                        SubstitutionServiceDelegate — содержит методы для управления правилами замещения
                                                        SystemServiceDelegate — содержит методы для входа/выхода пользователя в систему
                                                        DefinitionServiceDelegate — содержит методы для работы с определениями процессов
                                                        ExecutionServiceDelegate — содержит методы для работы с исполняемыми экземплярами процессов
                                                        Все существующие в данный момент Delegate-классы реализуют требуемую функциональность при помощи технологии EJB.

                                                        # Слой Service
                                                        Слой service – это серверное API доступа к системе. Реализации Delegate интерфейсов обращаются именно к этому слою. Каждый Delegate работает с одним соответствующим классом Service. В настоящее время все разработанные service классы и интерфейсы ориентированы на EJB-технологию, однако в будущем возможны и другие реализации. Реализации классов Service являются Stateless Session Bean EJB, которые декларативно поддерживают транзакционность вызовов и запрашивают соответствующие классы из слоя Logic.

                                                        Таким образом, классы Delegate – Service - Logic образуют как бы «транспорт» между клиентом и сервером.

                                                        # Слой Logic
                                                        Слой Logic – это реализация бизнес логики работы системы. Слой работает с классами слоя DAO для доступа к постоянному хранилищу.

                                                        # Слой DAO
                                                        Слой DAO – это интерфейсы и классы, обеспечивающие доступ к данным, находящимся в постоянном хранилище (базе данных). В настоящее время все DAO-классы системы реализованы при помощи ORM-средства Hibernate.

                                                        # Использование Hibernate
                                                        Hibernate – ORM (Object/Relational Mapping) средство. Отображает объектную архитектуру на реляционную структуру данных. Допускает настройку (не меняя разработанного кода) на большинство существующих серверов реляционных баз данных.

                                                        Поддерживает работу с распределенными транзакциями, автоматически создает таблицы для новых классов и т.д. Вся работа с данными внутри системы ведется только через Hibernate.

                                                        Все компоненты, предоставляющие клиентское API построены с использованием описанных выше слоев. В целях оптимизации в некоторых компонентах применяется кеширование, которое может встречаться на уровне logic или DAO. Основная функциональность по управлению кешами находится в классах CachingLogic, CacheInterceptor и классах соответствующих кешей. Изменения в кешируемых объектах перехватываются и сообщаются посредством CachingLogic всем подписавшимся на изменения классам кешей. Транзакция, изменяющая кеш, считается закрытой по окончанию обработки ejb вызова.

                                                        # Обновление базы данных
                                                        см. описание системы патчей.

                                                        # API
                                                        Система представляет API для интеграции с другими системами:

                                                        # Java API
                                                        Реализация (снизу вверх): БД - Hibernate3 - EJB3

                                                        Документацию можно смотреть в исходном коде (javadocs в *Service.java).

                                                        # WebServices API
                                                        Реализация (снизу вверх): БД - Hibernate3 - JAX-WS

                                                        Документация: WebServicesDeveloperGuide

                                                        # Scripting API
                                                        Реализация (снизу вверх): БД - Hibernate3 - XML Script

                                                        Документация: AdminScriptGuide

                                                        # Процесс сборки из исходного кода
                                                        Исходный код системы доступен в открытом репозитории на github.

                                                        Сервер можно собирать как средствами maven используя командную строку, так и используя среду Eclipse IDE.

                                                        В результате сборки будет сформирован runawfe.ear, который теоретически можно запустить на любом сервере приложений. Начиная с версии 4.3.0 введена поддержка JAVA версии 8, и отказ от JAVA 6. В дальнейшем планируется отказ от java7, поэтому рекомендуется использовать сервер приложений wildfly.

                                                        # Процесс сборки на примере Eclipse IDE
                                                        # Необходимое программное обеспечение для сборки
                                                        В отличие от Среды разработки для сборки сервера можно использовать Eclipse IDE любой версии и редакции.

                                                        установите плагин m2eclipse
                                                        используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу: http://maven.apache.org/
                                                        добавьте путь к Apache Maven директории bin в переменную окружения Path
                                                        # Импорт проектов
                                                        Импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server.

                                                        Eclipse srv proj.png

                                                        # Установка maven артефактов
                                                        Выполните

                                                        ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                                                        ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                                                        или другим способом установите артефакты в локальный репозиторий

                                                        # Сборка
                                                        Заведите конфигурацию запуска на основе maven как показано на рисунке

                                                        Maven.build.configuration.png

                                                        Запустите конфигурацию.

                                                        Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\eclipse-workspace\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"

                                                        # Сборка из командной строки
                                                        используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу http://maven.apache.org/
                                                        добавьте путь к Apache Maven директории bin в переменную окружения Path
                                                        импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server
                                                        выполните обновление зависимостей
                                                        ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                                                        ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                                                        откройте командную строку
                                                        перейдите в директорию ${wfe}/wfe-app/
                                                        выполните команду для сборки
                                                        mvn clean package -Dmaven.test.skip=true
                                                        Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"


                                                        Для установки артефактов в локальный репозиторий используйте команду

                                                        mvn clean install -Dmaven.test.skip=true
                                                        # Использование ear на сервере приложений
                                                        cкачайте текущую версию RunaWFE в виде файл-архива исполняемых java файлов runawfe-wildfly-java8-*.zip (на базе wildfly, java8)
                                                        распакуйте архив
                                                        обновите runawfe.ear на версию полученную в результате сборки
                                                        # Расширение функциональности
                                                        # Точки расширения системы
                                                        Обработчики позволяют исполнить код в процессах (элементы "Обработчик", "Задача сценария") и ботах
                                                        Форматы переменных определяют тип переменных и правила преобразования значений к текстовому представлению и обратно
                                                        Организационные функции используются при назначении ролей и в правилах замещения для определения заместителя
                                                        Критерии замещения используются в подсистеме замещения для определения заместителя при построении списка заданий
                                                        Валидаторы обеспечивают проверку переменных при выполнении задания (в т.ч. введенные значения форм)
                                                        Freemarker теги форм генерируют html код для отображения на форме
                                                        Ajax команды предоставляют доступ к функциональности сервера из JavaScript
                                                        # Процесс разработки расширений
                                                        Создайте новый java-проект и подключите необходимые зависимости (wfe-core, wfe-service).

                                                        Реализуйте в нем требуемые расширения и соберите его в виде jar-файла.

                                                        Замечание. Использование maven облегчит процесс управления зависимостями.

                                                        Разместить собранный jar на сервере вы можете:

                                                        положив его в runawfe.ear!/lib
                                                        положив его в директорию deploy (только для jboss4)
                                                        положив его в ${jboss.server.base.dir}/wfe.custom (только для jboss7)
                                                        положив его в ${jboss.server.base.dir}/${jboss.server.name}/wfe.custom (только для jboss4)
                                                        # Обработчики
                                                        Обработчик в процессе – компонент процесса (элементы "Обработчик", "Задача сценария"), использующийся для выполнения каких-либо действий при возникновении определенных событий (проход по определенному переходу в процессе, приход или уход управления из узла и т.п.).

                                                        Обработчик должен реализовывать интерфейс ru.runa.wfe.extension.ActionHandler. Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов Spring контекста (например с помощью аннотации @Autowired).

                                                        При написании нового обработчика рекомендуется наследовать его от абстрактного класса ru.runa.wfe.extension.handler.CommonHandler или ru.runa.wfe.extension.handler.CommonParamBasedHandler. В методе setConfiguration обработчик должен запомнить свои параметры (если обработчик их ожидает), а в методе execute происходит непосредственная обработка и выполнение требуемых действий.

                                                        В случае, если при выполнении обработчика произошла ошибка, произойдет откат транзакции и состояние процесса будет возвращено к заданию, исполнение которого повлекло вызов обработчика. В интерфейсе обработчика для бота ru.runa.wfe.extension.TaskHandler предусмотрен метод onRollback для работы с не-транзакционными ресурсами.

                                                        Эти обработчики удобно использовать для простых операций (например для отправки оповещений в виде SMS-сообщений если процесс попал в определенное состояние). Но у них есть несколько ограничений. Прежде всего у них нет соответствующего объекта контекста безопасности (security context). Это означает, что в них нельзя выполнять защищенные методы (запуск процессов, выполнение задач, создание пользователей и т.п.) Ошибочным решением в них будет блокирование выполнения процесса (например с Thread::Sleep(...)). Например, если в обработчике отправляется e-mail, а SMTP сервер недоступен, обработчику нельзя "задерживать" свое выполнение.

                                                        Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                                                        # Специфика обработчиков для ботов
                                                        Бот - это сокращение от робот. В системе боты - это особый тип исполнителей. Система не отличает ботов от людей. У каждого бота есть свои права на вход в систему, он периодически просыпается, проверяет свой список задачи и выполняет обнаруженные там задачи.

                                                        Каждая задача бота обрабатывается при помощи соответствующего обработчика. Чтобы написать новый обработчик нужно реализовать интерфейс ru.runa.wfe.extension.TaskHandler.

                                                        Обратите внимание, что этот вид обработчиков выполняется в контексте безопасности (security context) пользователя-бота, и здесь может выполнятся любая операция (если у бота есть на это права).

                                                        Обработчики задач ботов могут блокировать выполнение процесса.

                                                        Например, обработчик задач, отправляющий e-mail может блокировать выполнение бизнес процесса до тех пор, пока обработчик не удостоверится, что SMTP сервер принял сообщение для последующей доставки.

                                                        Обработчики задач вызываются периодически, когда боты проверяют свои списки задач.

                                                        # Специфика обработчика для элемента ветвление
                                                        Обработчик для Decision является java-классом, реализующим интерфейс ru.runa.wfe.extension.DecisionHandler. Интерфейс содержит один метод decide(ExecutionContext executionContext), который возвращает имя выбранного перехода (одного из выходящих из данного ветвления). Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов контекста спринга (например с помощью аннотации @Autowired).

                                                        Обработчик принимает ExecutionContext в качестве входящего параметра и должен сделать выбор перехода исходя из значений переменных бизнес процесса и условий, указанных в конфигурации обработчика. Точно также как обработчики действия (action handler) обработчики выбора (decision handlers) не могут использовать защищенные (secured) методы, не могут обрабатывать ошибки и откладывать выбор перехода до лучших времен.

                                                        По умолчанию используется ru.runa.wfe.extension.decision.GroovyDecisionHandler.

                                                        # Использование ru.runa.wfe.extension.handler.CommonParamBasedHandler в качестве базового класса
                                                        Этот класс инкапсулирует в себе парсинг XML конфигурации определенного формата. Его удобно использовать если обработчик имеет фиксированное число параметров. Пример конфигурации:

                                                        <?xml version="1.0" encoding="UTF-8"?>
                                                        <config>
                                                         <input>
                                                           <param name="typeName" variable="тип отсутствия" />
                                                           <param name="employee" variable="сотрудник" />
                                                           <param name="requester" variable="подавший заявку" />
                                                           <param name="from" variable="дата с" />
                                                           <param name="to" variable="дата по" />
                                                           <param name="cause" variable="причина" />
                                                           <param name="comment" variable="комментарий" />
                                                           <param name="confirmation" variable="дата подтверждения" />
                                                           <param name="firmCode" value="111" />
                                                           <param name="firmPositionCode" variable="код должности" />
                                                           <param name="firmDepartmentCode" variable="код подразделения" />
                                                         </input>
                                                         <output>
                                                           <param name="uuid" variable="идентификатор объекта" />
                                                         </output>
                                                        </config>
                                                        Использование обработчика Groovy
                                                        См. соответствующий раздел в руководстве по работе с Groovy.

                                                        # Как написать функцию над организационной структурой
                                                        Функции над организационной структурой в системе применяются, например, при инициализации Ролей-Дорожек и в правилах замещения.

                                                        Класс, соответствующий функции над организационной структурой, должен реализовывать интерфейс ru.runa.wfe.extension.OrgFunction.

                                                        Интерфейс содержит один метод

                                                        List<? extends Executor> getExecutors(Object... parameters)
                                                        Этот метод должен возвращать список исполнителей.

                                                        В бизнес-процессе обработчик функции над оргструктурой используются при определении Ролей-Дорожек: указывается внутри тега swimlane, в теле тега <assignment>.В качестве параметра class тега <assignment> указывается класс-обработчик для инициализации swimlane: ru.runa.wfe.extension.AssignmentHandler. Внутри тега <assignment> содержится конфигурация для этого класса, которая представляет собой имя класса-наследника интерфейса OrgFunction и список параметров в скобках. В качестве параметра может выступать конкретное значение или имя переменной бизнес процесса в фигурных скобках, перед которым стоит значок $

                                                        Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                                                        Если есть планы по использованию функции в подсистеме замещений - её можно зарегистрировать в substitutions.xml.

                                                        # Как написать критерий замещения
                                                        Критерии замещения в системе применяются в правилах замещения. Класс, соответствующий критерию замещения, должен наследоваться от ru.runa.wfe.ss.SubstitutionCriteria.

                                                        Для создания на основе него конечных критериев замещения с конфигурациями - его нужно зарегистрировать в substitution.criterias.xml.

                                                        Как реализовать класс-формат для переменных бизнес-процесса
                                                        См. соответствующий раздел в руководстве по работе с переменными.

                                                        # Как реализовать валидатор переменных
                                                        Классы, расширяющие абстрактный класс ru.runa.wfe.validation.FieldValidator, в системе применяются для проверки переменных при выполнении задания или старте процесса.

                                                        Пример:

                                                        public class OvertimeWorkRequestTimeCheck extends FieldValidator {
                                                           @Override
                                                           public void validate() {
                                                               Date date = (Date) getFieldValue();
                                                               if (date == null) {
                                                                   return;
                                                               }
                                                               boolean testMode = getVariableProvider().getValueNotNull(boolean.class, "тестовый режим");
                                                               if (testMode) {
                                                                   return;
                                                               }
                                                               Calendar calendar = CalendarUtil.dateToCalendar(date);
                                                               if (calendar.before(Calendar.getInstance())) {
                                                                   addError("Заявка не может быть оформлена задним числом");
                                                                   return;
                                                               }
                                                               CalendarUtil.setTimeFromCalendar(calendar, DemoProperties.getOvertimeWorkRequestMaximumStartTime());
                                                               Utils.adjustCalendarForHolidaysInOvertimwWork(calendar);
                                                               if (calendar.before(Calendar.getInstance())) {
                                                                   addError("Заявка на этот день не может быть подана, время подачи истекло " + CalendarUtil.formatDateTime(calendar));
                                                               }
                                                           }
                                                        }

                                                        Связь между Средой разработки и сервером осуществляется по имени валидатора, регистрация требуется на стороне сервера в файле validators.xml, а в среде разработки - в plugin.xml.

                                                        # Как реализовать FreeMarker тег для формы
                                                        FreemarkerForms#Components

                                                        # Как реализовать Ajax команду
                                                        Классы, расширяющие абстрактный класс ru.runa.wfe.commons.web.JsonAjaxCommand, (или реализующие ru.runa.wfe.commons.web.AjaxCommand) в системе применяются для доступа к функциональности сервера из JavaScript, например при отображении форм задания.

                                                        Регистрация команды происходит любым из двух способов:

                                                        в файле ajax.commands.xml, ей присваивается определенное имя
                                                        в контексте приложения, именем является id spring-бина
                                                        Затем по этому имени её можно выполнить используя JavaScript.

                                                        Пример команды

                                                        public class GetOrganizationNamesCommand extends JsonAjaxCommand {
                                                           @Autowired
                                                           private OrganizationDAO organizationDAO;
                                                           @Override
                                                           protected JSONAware execute(User user, HttpServletRequest request) throws Exception {
                                                               String term = request.getParameter("term");
                                                               if (term == null) {
                                                                   term = "";
                                                               }
                                                               List<Organization> organizations = organizationDAO.getAll();
                                                               JSONArray array = new JSONArray();
                                                               for (Organization organization : organizations) {
                                                                   if (organization.getName().startsWith(term)) {
                                                                       array.add(organization.getName());
                                                                   }
                                                               }
                                                               return array;
                                                           }
                                                        }
                                                        Регистрация в wfe.custom.ajax.commands.xml

                                                        <?xml version="1.0" encoding="UTF-8" ?>
                                                        <configuration xmlns="http://runa.ru/xml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://runa.ru/xml">
                                                         <command name="getOrganizationNames" class="ru.runa.rkdemo.web.ajax.GetOrganizationNamesCommand" />
                                                        </configuration>
                                                        Её использование со скрипта формы (autocomplete input)

                                                        $(document).ready(function() {
                                                         $('#editLinkedLists').on("onRowAdded", function(event, rowIndex) {
                                                          $("input[name='названия организаций["+rowIndex+"]']").autocomplete( {
                                                           delay: 300,
                                                           minLength: 0,
                                                           source: "/wfe/ajaxcmd?command=getOrganizationNames"
                                                          });
                                                          $("input[name='названия организаций["+rowIndex+"]']").focus(function() {
                                                           $(this).autocomplete("search", $(this).val());
                                                          });
                                                         });
                                                        });: {
    "@type": "WebPage",
    "@id": "https://javarush.ru/groups/posts/1993-mnogopotochnostjh-chto-delajut-metodih-klassa-thread"
  },
  "headline": "Многопоточность: что делают методы класса Thread",
  "description": "Привет! Сегодня продолжаем говорить о многопоточности. Рассмотрим класс Thread и работу его нескольких методов. Раньше, когда мы изучали методы класса, чаще всего просто писали это так: «название метода» -&gt; «что он делает». С методами Thread так не получится :) ...",
  "image": [
    "https://cdn.javarush.ru/images/article/a11feba5-e610-4125-bce8-a8e73bc30eb6/original.jpeg"
  ],
  "datePublished": "2018-09-27T16:41:58.000Z",
  "dateModified": "2018-11-15T09:23:50.593Z",
  "author": {
    "@type": "Person",
    "name": "Professor Hans Noodles"
  },
  "publisher": {
    "@type": "Organization",
    "name": "JavaRush",
    "logo": {
      "@type": "ImageObject",
      "url": "https://javarush.ru/assets/images/site/logo/logo-short.svg"
    }
  }
}</script> <script> (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-NH6ZXRJ'); </script> </head> <body> <div id=sapper>


<main class=""><div class="javarush-site"><div class="sidebar"><nav class="sidebar-nav"><a href="https://javarush.ru/" class="sidebar-nav__home"><div class="sidebar-nav__logo-container"><img src="/sapper/assets/images/site/logo/sidebar-logo.svg" class="sidebar-nav__logo" alt="JavaRush"></div></a>
    <div class="sidebar-nav__sections"><div class="side-bar-group"><div class="sidebar-group-head sidebar-group-head--has-collapse"><a href="https://javarush.ru/learn" class="sidebar-group-head__link">
Обучение
</a>

    <button class="sidebar-group-head__collapse"><span class="sidebar-group-head__collapse-icon"><svg class="icon icon--common-caret" aria-hidden="true"><use xlink:href="/sapper/assets/icons/common.svg?v=19#icon-caret"></use></svg></span></button></div>
  <div class="sidebar-group-items"><div class="sidebar-nav-item" data-site-tour-target="QUESTS"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-course" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-course"></use></svg></div>





  <a href="https://javarush.ru/quests" class="sidebar-nav-link"><div class="sidebar-nav-label">Курс</div>
</a></div><div class="sidebar-nav-item" data-site-tour-target="TASKS"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-tasks" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-tasks"></use></svg></div>





  <a href="https://javarush.ru/tasks" class="sidebar-nav-link"><div class="sidebar-nav-label">Задачи</div>
</a></div><div class="sidebar-nav-item" data-site-tour-target="QUIZZES"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-quizzes" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-quizzes"></use></svg></div>





  <a href="https://javarush.ru/quizzes" class="sidebar-nav-link"><div class="sidebar-nav-label">Опросы</div>
</a></div><div class="sidebar-nav-item" data-site-tour-target="PROJECTS"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-games" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-games"></use></svg></div>





  <a href="https://javarush.ru/projects/games" class="sidebar-nav-link"><div class="sidebar-nav-label">Игры</div>
</a></div><div class="sidebar-nav-item" data-site-tour-target="HELP"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-help" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-help"></use></svg></div>





  <a href="https://javarush.ru/help" class="sidebar-nav-link"><div class="sidebar-nav-label">Помощь</div>
</a></div><div class="sidebar-nav-item" data-site-tour-target="NONE"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-kick" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-kick"></use></svg></div>





  <a href="https://javarush.ru/schedule" class="sidebar-nav-link"><div class="sidebar-nav-label">График пинков</div>
</a></div><div class="sidebar-nav-item" data-site-tour-target="INTERNSHIP"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-internship" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-internship"></use></svg></div>





  <a href="https://javarush.ru/internship" class="sidebar-nav-link"><div class="sidebar-nav-label">Стажировка</div>
</a></div></div></div><div class="side-bar-group"><div class="sidebar-group-head sidebar-group-head--has-collapse"><a href="https://javarush.ru/community" class="sidebar-group-head__link">
Сообщество
</a>

    <button class="sidebar-group-head__collapse"><span class="sidebar-group-head__collapse-icon"><svg class="icon icon--common-caret" aria-hidden="true"><use xlink:href="/sapper/assets/icons/common.svg?v=19#icon-caret"></use></svg></span></button></div>
  <div class="sidebar-group-items"><div class="sidebar-nav-item" data-site-tour-target="USERS"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-friends" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-friends"></use></svg></div>





  <a href="https://javarush.ru/users" class="sidebar-nav-link"><div class="sidebar-nav-label">Друзья</div>
</a></div><div class="sidebar-nav-item" data-site-tour-target="FORUM"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-forum" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-forum"></use></svg></div>





  <a href="https://javarush.ru/forum" class="sidebar-nav-link"><div class="sidebar-nav-label">Форум</div>
</a></div><div class="sidebar-nav-item" data-site-tour-target="CHAT"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-chat" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-chat"></use></svg></div>





  <a href="https://javarush.ru/chat" class="sidebar-nav-link"><div class="sidebar-nav-label">Чат</div>
</a></div><div class="sidebar-nav-item sidebar-nav-item--active" data-site-tour-target="GROUPS"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-articles" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-articles"></use></svg></div>





  <a href="https://javarush.ru/groups/posts" class="sidebar-nav-link"><div class="sidebar-nav-label">Статьи</div>
</a></div><div class="sidebar-nav-item" data-site-tour-target="NONE"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-success-stories" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-success-stories"></use></svg></div>





  <a href="https://javarush.ru/groups/stories" class="sidebar-nav-link"><div class="sidebar-nav-label">Истории успеха</div>
</a></div><div class="sidebar-nav-item" data-site-tour-target="NEWS"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-activity" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-activity"></use></svg></div>





  <a href="https://javarush.ru/news" class="sidebar-nav-link"><div class="sidebar-nav-label">Активности</div>
</a></div><div class="sidebar-nav-item" data-site-tour-target="NONE"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-reviews" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-reviews"></use></svg></div>





  <a href="https://javarush.ru/about/reviews" class="sidebar-nav-link"><div class="sidebar-nav-label">Отзывы</div>
</a></div></div></div><div class="side-bar-group"><div class="sidebar-group-head sidebar-group-head--has-collapse"><a href="https://javarush.ru/me" class="sidebar-group-head__link">
Мой аккаунт
</a>

    <button class="sidebar-group-head__collapse"><span class="sidebar-group-head__collapse-icon"><svg class="icon icon--common-caret" aria-hidden="true"><use xlink:href="/sapper/assets/icons/common.svg?v=19#icon-caret"></use></svg></span></button></div>
  <div class="sidebar-group-items"><div class="sidebar-nav-item" data-site-tour-target="DIALOGUES"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-dialogues" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-dialogues"></use></svg></div>





  <a href="https://javarush.ru/dialogues" class="sidebar-nav-link"><div class="sidebar-nav-label">Сообщения</div>
</a></div><div class="sidebar-nav-item" data-site-tour-target="NONE"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-notifications" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-notifications"></use></svg></div>





  <a href="https://javarush.ru/dialogues/notices" class="sidebar-nav-link"><div class="sidebar-nav-label">Уведомления</div>
</a></div><div class="sidebar-nav-item" data-site-tour-target="PRICES"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-subscriptions" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-subscriptions"></use></svg></div>





  <a href="https://javarush.ru/prices" class="sidebar-nav-link"><div class="sidebar-nav-label">Подписки</div>
</a></div><div class="sidebar-nav-item" data-site-tour-target="NONE"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-rating" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-rating"></use></svg></div>





  <a href="https://javarush.ru/rating" class="sidebar-nav-link"><div class="sidebar-nav-label">Рейтинги</div>
</a></div><div class="sidebar-nav-item" data-site-tour-target="NONE"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-support" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-support"></use></svg></div>





  <a href="https://javarush.ru/dialogues/administration" class="sidebar-nav-link"><div class="sidebar-nav-label">Поддержка</div>
</a></div><div class="sidebar-nav-item" data-site-tour-target="NONE"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-settings" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-settings"></use></svg></div>





  <a href="https://javarush.ru/settings" class="sidebar-nav-link"><div class="sidebar-nav-label">Настройки</div>
</a></div><div class="sidebar-nav-item" data-site-tour-target="NONE"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-bookmarks" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-bookmarks"></use></svg></div>





  <a href="https://javarush.ru/bookmarks" class="sidebar-nav-link"><div class="sidebar-nav-label">Закладки</div>
</a></div></div></div></div></nav>
  <button title="Свернуть" type="button" class="sidebar-nav__toggle"><span class="sidebar-nav__toggle-icon"><svg class="icon icon--common-caret" aria-hidden="true"><use xlink:href="/sapper/assets/icons/common.svg?v=19#icon-caret"></use></svg></span></button></div>
    <div class="site-layout site-layout--post-page"><div class="site-layout__container"><div class="site-layout__main"><div class="site-layout__overlay"><svg class="icon icon--common-cross" aria-hidden="true"><use xlink:href="/sapper/assets/icons/common.svg?v=19#icon-cross"></use></svg></div>
          <div class="site-layout__header"><header class="site-header"><div class="site-header__container"><div class="site-header__toggle-menu"><button class="toggle-menu-button" type="button" aria-label="Открыть меню"><div class="toggle-menu-button__icon"></div></button></div>
    <div class="site-header__title-and-search"><div class="site-header__title"><div class="site-header-title">Статья</div></div>

      <div class="site-header__search"><div><div class="header-search-panel"><input type="search" class="header-search-panel__input" placeholder="Поиск">
    <div class="header-search-panel__icon"><svg class="icon icon--common-search" aria-hidden="true"><use xlink:href="/sapper/assets/icons/common.svg?v=19#icon-search"></use></svg></div>
    <button class="header-search-panel__close" type="button"><svg class="icon icon--common-cross" aria-hidden="true"><use xlink:href="/sapper/assets/icons/common.svg?v=19#icon-cross"></use></svg></button></div></div></div></div>
    <div class="site-header__user-panel"><div class="me-short-panel-host"><a href="https://javarush.ru/me" class="me-short-panel"><div class="me-short-panel__avatar"><figure class="avatar avatar--smd"><div style="background-image: url('https://cdn.javarush.ru/images/avatar/2496069/64.webp')" class="avatar__image" role="img"></div>
  <figcaption class="avatar__caption">
    Fomin Dmitriy</figcaption></figure></div>
    <div class="me-short-panel__info"><div class="me-short-panel__name-and-level"><div class="me-short-panel__name" title="Fomin Dmitriy">Fomin Dmitriy</div>
        <div class="me-short-panel__level">17 уровень</div></div>
      <div class="me-short-panel__force"><div class="me-short-panel__dark-matter"><div class="dark-matter"><div class="dark-matter__icon"><svg class="icon icon--common-dark-matter" aria-hidden="true"><use xlink:href="/sapper/assets/icons/common.svg?v=19#icon-dark-matter"></use></svg></div>
            <div class="dark-matter__value">608</div></div></div></div></div></a></div>
        <div class="site-header__subscription-status"><a href="https://javarush.ru/prices/my" class="me-subscription-status"><div class="subscription-status subscription-status--premium"><div class="subscription-status__label">Premium</div></div></a></div>
        <div class="site-header__notifications"><div class="user-notifications"><a class="user-notifications__link" href="https://javarush.ru/dialogues"><div class="user-notifications__icon"><svg class="icon icon--sidebar-nav-dialogues" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-dialogues"></use></svg></div>
              </a>

            <a class="user-notifications__link" href="https://javarush.ru/dialogues/notices"><div class="user-notifications__icon"><svg class="icon icon--sidebar-nav-notifications" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-notifications"></use></svg></div>
              </a></div></div></div>

    <div class="site-header__theme-switcher"><div class="switcher-daynight"><input class="switcher-daynight__checkbox" type="checkbox">
  <div class="switcher-daynight__track"><div class="switcher-daynight__toggle"></div>
    <div class="switcher-daynight__icon switcher-daynight__icon--night"><svg class="icon icon--common-night-mode" aria-hidden="true"><use xlink:href="/sapper/assets/icons/common.svg?v=19#icon-night-mode"></use></svg></div>
    <div class="switcher-daynight__icon switcher-daynight__icon--day"><svg class="icon icon--common-day-mode" aria-hidden="true"><use xlink:href="/sapper/assets/icons/common.svg?v=19#icon-day-mode"></use></svg></div></div></div></div></div></header></div>

          <div class="site-layout__header-guest-fixed"></div>
          <div class="site-layout__content">

<div class="page"><div class="page__nav container-narrow"><div class="tabs"><ul class="tabs__list" role="tablist"><li class="tabs__item"><a class="tabs__button" href="https://javarush.ru/groups/posts">Список статей</a>
        </li><li class="tabs__item"><a class="tabs__button" href="https://javarush.ru/groups/all">Все группы</a>
        </li><li class="tabs__item"><a class="tabs__button" href="https://javarush.ru/groups/my">Мои группы</a>
        </li></ul></div></div>
  <div class="page__content"><article class="article"><div class="article__head container-narrow"><div class="post-head"><div class="post-head__user"><a href="https://javarush.ru/users/1770672" target="_blank" class="user-short-info-card"><div class="user-short-info-card__avatar"><figure class="avatar avatar--lg"><div style="background-image: url('https://cdn.javarush.ru/images/avatar/1770672/128.webp')" class="avatar__image" role="img"></div>
  <figcaption class="avatar__caption">Пользователь
    Professor Hans Noodles</figcaption></figure></div>
  <div class="user-short-info-card__name">Professor Hans Noodles</div>
  <div class="user-short-info-card__level">41 уровень</div>
  </a></div>
  <div class="post-head__info"><div class="post-head__meta"><ul class="post-meta-panel"><li class="post-meta-panel__item post-meta-panel__date"><span class="post-meta-panel__icon"><svg class="icon icon--common-date" aria-hidden="true"><use xlink:href="/sapper/assets/icons/common.svg?v=19#icon-date"></use></svg></span>
      <span class="post-meta-panel__value">27 сентября 2018</span></li>
  <li class="post-meta-panel__item post-meta-panel__hits"><span class="post-meta-panel__icon"><svg class="icon icon--common-hits" aria-hidden="true"><use xlink:href="/sapper/assets/icons/common.svg?v=19#icon-hits"></use></svg></span>
      <span class="post-meta-panel__value">47142</span>
      <span class="post-meta-panel__label">просмотров</span></li>
  <li class="post-meta-panel__item post-meta-panel__comments"><a class="post-meta-panel__link" href="https://javarush.ru/groups/posts/1993-mnogopotochnostjh-chto-delajut-metodih-klassa-thread#discussion"><span class="post-meta-panel__icon"><svg class="icon icon--common-comments" aria-hidden="true"><use xlink:href="/sapper/assets/icons/common.svg?v=19#icon-comments"></use></svg></span>
        <span class="post-meta-panel__value">109</span>
        <span class="post-meta-panel__label">комментариев</span>
        </a></li>
  </ul></div>
    <h1 class="post-head__title">Многопоточность: что делают методы класса Thread</h1>
    <div class="post-head__source"><div class="post-source-meta"><div class="post-source-meta__main"><a class="post-source-meta__link" href="https://javarush.ru/groups/java-developer">Статья из группы
            Java Developer</a></div>
        <div class="post-source-meta__extra">28028
            участников
          </div></div></div>
    <div class="post-head__status"><button class="button button--md button--info-alt">Присоединиться</button>

  </div></div></div></div>
        <div id="post-content" class="article__content container-narrow"><div class="content content--raw">Привет! Сегодня продолжаем говорить о многопоточности. Рассмотрим класс Thread и работу его нескольких методов. Раньше, когда мы изучали методы класса, чаще всего просто писали это так: «название метода» -> «что он делает».
<div class='row justify-content-center jr-image-wrap'><div class='col-12 col-sm-10 col-md-8'><img data-id="a721b583-c502-4047-b2d9-a49895b5a89a" data-max-width="710" alt="Многопоточность: что делают методы класса Thread - 1" data-src="https://cdn.javarush.ru/images/article/a721b583-c502-4047-b2d9-a49895b5a89a/1024.jpeg"></div></div>С методами Thread так не получится :) Их логика сложнее, и без нескольких примеров не разобраться.

<h2>Метод Thread.start()</h2>Начнем с повторения. Как ты наверняка помнишь, создать поток можно унаследовав свой класс от класса <code>Thread</code> и переопределив в нем метод <code>run()</code>.

Но сам он, конечно, не запустится. Для этого у нашего объекта вызываем метод <code>start()</code>.
<img data-id="b9b6e5a5-b771-4c79-8122-2e453ab57ace" data-max-width="850" alt="Многопоточность: что делают методы класса Thread - 2" data-src="https://cdn.javarush.ru/images/article/b9b6e5a5-b771-4c79-8122-2e453ab57ace/1024.jpeg">Давай вспомним пример из предыдущей лекции:

<pre class='lang-java line-numbers'><code>
public class MyFirstThread extends Thread {

   @Override
   public void run() {
       System.out.println("Выполнен поток " + getName());
   }
}


public class Main {

   public static void main(String[] args) {

       for (int i = 0; i < 10; i++) {
           MyFirstThread thread = new MyFirstThread();
           thread.start();
       }
   }
}
</code></pre>
<em><strong>Обрати внимание:</strong></em> чтобы запустить поток, необходимо вызвать специальный метод <code>start()</code>, а не метод <code>run()</code>! Эту ошибку легко допустить, особенно в начале изучения многопоточности.

Если в нашем примере ты 10 раз вызовешь у объекта метод <code>run()</code> вместо <code>start()</code>, результат будет таким:

<pre class='lang-java line-numbers'><code>
public class Main {

   public static void main(String[] args) {

       for (int i = 0; i < 10; i++) {
           MyFirstThread thread = new MyFirstThread();
           thread.run();
       }
   }
}
</code></pre>

<em><strong>Выполнен поток Thread-0
Выполнен поток Thread-1
Выполнен поток Thread-2
Выполнен поток Thread-3
Выполнен поток Thread-4
Выполнен поток Thread-5
Выполнен поток Thread-6
Выполнен поток Thread-7
Выполнен поток Thread-8
Выполнен поток Thread-9</strong></em>

Посмотри на последовательность вывода: все идет строго по порядку. Странно, да? Мы к такому не привыкли, ведь уже знаем, что порядок запуска и выполнения потоков определяет сверхразум внутри нашей операционной системы — планировщик потоков. Может, просто повезло?

Конечно, дело не в везении. В этом можешь убедиться, запустив программу еще пару раз.

Дело в том, что прямой вызов метода <code>run()</code> не имеет отношения к многопоточности. В этом случае программа будет выполнена в главном потоке — том, в котором выполняется метод <code>main()</code>. Он просто последовательно выведет 10 строк на консоль и все. Никакие 10 потоков не запустятся.

Поэтому запомни на будущее и постоянно себя проверяй. Хочешь, чтобы выполнился <code>run()</code>, вызывай <code>start()</code>. Поехали дальше.

<h2>Метод Thread.sleep()</h2>Для приостановки выполнения текущего потока на какое-то время, используем метод <code>sleep()</code>.
<img data-id="1e9f01d2-6dba-4189-9bf6-121c25c29110" data-max-width="850" alt="Многопоточность: что делают методы класса Thread - 3" data-src="https://cdn.javarush.ru/images/article/1e9f01d2-6dba-4189-9bf6-121c25c29110/1024.jpeg">Метод <code>sleep()</code> принимает в качестве параметра число миллисекунд, то есть то время, на которое необходимо «усыпить» поток.

<pre class='lang-java line-numbers'><code>
public class Main {

   public static void main(String[] args) throws InterruptedException {

       long start = System.currentTimeMillis();

       Thread.sleep(3000);

       System.out.println(" - Сколько я проспал? \n - " + ((System.currentTimeMillis()-start)) / 1000 + " секунды");

   }
}
</code></pre>
<strong>Вывод в консоль:

<em> - Сколько я проспал?
 - 3 секунды</em></strong>

Обрати внимание: метод <code>sleep()</code> — статический: он усыпляет текущий поток. То есть тот, который работает в данный момент.

Еще один важный нюанс: поток в состоянии сна можно прервать. В таком случае в программе возникнет исключение <code>InterruptedException</code>. Мы рассмотрим пример ниже.

Кстати, а что произойдет после того, как поток «проснется»? Продолжит ли он сразу же свое выполнение с того места, где закончил? Нет.

После того, как поток «просыпается» — когда заканчивается время, переданное в качестве аргумента в <code>Thread.sleep()</code>, — он переходит в состояние <em>runnable</em>, «работоспособный». Однако это не значит, что планировщик потоков запустит именно его. Вполне возможно, он отдаст предпочтение какому-то другому «неспящему» потоку, а наш «свежепроснувшийся» продолжит работу чуть позже.

Обязательно запомни: «проснулся — не значит продолжил работать в ту же секунду»!

<h2>Метод Thread.join()</h2><img data-id="c3c0548b-4341-4b3f-a577-44ba15c84b23" data-max-width="850" alt="Многопоточность: что делают методы класса Thread - 4" data-src="https://cdn.javarush.ru/images/article/c3c0548b-4341-4b3f-a577-44ba15c84b23/1024.jpeg">Метод <code>join()</code> приостанавливает выполнение текущего потока до тех пор, пока не завершится другой поток.

Если у нас есть 2 потока, <code>t1</code> и <code>t2</code>, и мы напишем —

<pre class='lang-java line-numbers'><code>
t1.join()
</code></pre>
<code>t2</code> не начнет работу, пока t1 не завершит свою. Метод <code>join()</code> можно использовать, чтобы гарантировать последовательность выполнения потоков.

Давай рассмотрим работу <code>join()</code> на примере:

<pre class='lang-java line-numbers'><code>
public class ThreadExample extends Thread {

   @Override
   public void run() {

       System.out.println("Начало работы потока " + getName());

       try {
           Thread.sleep(5000);
       } catch (InterruptedException e) {
           e.printStackTrace();
       }
       System.out.println("Поток " + getName() +  " завершил работу.");
   }
}


public class Main {

   public static void main(String[] args) throws InterruptedException {

       ThreadExample t1 = new ThreadExample();
       ThreadExample t2 = new ThreadExample();

       t1.start();


 /*Второй поток t2 начнет выполнение только после того, как будет завершен
       (или бросит исключение) первый поток - t1*/
       try {
           t1.join();
       } catch (InterruptedException e) {
           e.printStackTrace();
       }

       t2.start();

       //Главный поток продолжит работу только после того, как t1 и t2 завершат работу
       try {
           t1.join();
           t2.join();
       } catch (InterruptedException e) {
           e.printStackTrace();
       }

       System.out.println("Все потоки закончили работу, программа завершена");

   }
}
</code></pre>
Мы создали простой класс <code>ThreadExample</code>. Его задача — вывести на экран сообщение о начале работы, потом уснуть на 5 секунд и в конце сообщить о завершении работы. Ничего сложного.

Главная логика заключена в классе <code>Main</code>. Посмотри на комментарии: с помощью метода <code>join()</code> мы успешно управляем последовательностью выполнения потоков. Если ты вспомнишь начало темы, этим занимался планировщик потоков. Он запускал их на свое усмотрение: каждый раз по-разному.

Здесь же мы с помощью метода гарантировали, что сначала будет запущен и выполнен поток <code>t1</code>, затем — <code>t2</code>, и только после них — главный поток выполнения программы.

Идем дальше.

В реальных программах тебе не раз встретятся ситуации, когда необходимо будет прервать выполнение какого-то потока.

Например, наш поток выполняется, но при этом ждет определенного события или выполнения условия. Если это произошло, он останавливается. Было бы, наверное, логично, если бы существовал какой-то метод типа <code>stop()</code>.

Однако все не так просто. Когда-то давно метод <code><strong>Thread.stop()</strong></code> в Java действительно был и позволял прерывать работу потока. Но позже его удалили из библиотеки Java. Ты можешь найти его в документации Oracle и увидеть, что он помечен как <em>deprecated</em>.

Почему? Потому что он просто останавливал поток без какой-либо дополнительной работы.

Например, поток мог работать с данными и что-то в них менять. Потом его резко вырубали методом <code>stop()</code> посреди работы — и все. Ни корректного завершения работы, ни освобождения ресурсов, ни хотя бы обработки ошибок — ничего этого не было.

Метод <code>stop()</code>, если утрировать, просто крушил все на своем пути.

Его работу можно сравнить с тем, как кто-то выдергивает вилку из розетки, чтобы выключить компьютер. Да, нужного результата добиться можно. Но все понимают, что через пару недель компьютер не скажет за это «спасибо».

По этой причине логику прерывания потоков в Java изменили, и теперь используется специальный метод — <code>interrupt()</code>.

<h2>Метод Thread.interrupt()</h2>Что произойдет, если у потока вызвать <strong>метод</strong> <code><strong>interrupt()</strong></code>?

Есть 2 варианта:

<ol>
<li>Если объект находился в этот момент в состоянии ожидания, например, <code>join</code> или <code>sleep</code>, ожидание будет прервано, и программа выбросит <code>InterruptedException</code>.</li>
<li>Если же поток в этот момент был в работоспособном состоянии, у объекта будет установлен boolean-флаг <code><strong>interrupted</strong></code>.</li></ol>
Но проверить объект на значение этого флага и корректно завершить работу мы должны будем самостоятельно! Для этого в классе <code>Thread</code> есть специальный метод — <code><strong>boolean isInterrupted()</strong></code>.

Давай вернемся к примеру с часами, который был в лекции основного курса. Для удобства он немного упрощен:

<pre class='lang-java line-numbers'><code>
public class Clock extends Thread {

   public static void main(String[] args) throws InterruptedException {
       Clock clock = new Clock();
       clock.start();

       Thread.sleep(10000);
       clock.interrupt();
   }

   public void run() {
       Thread current = Thread.currentThread();

       while (!current.isInterrupted())
       {
           try {
               Thread.sleep(1000);
           } catch (InterruptedException e) {
               System.out.println("Работа потока была прервана");
               break;
           }
           System.out.println("Tik");
       }
   }
}
</code></pre>
В нашем случае часы стартуют и начинают тикать каждую секунду. На 10-й секунде мы прерываем поток часов.

Как ты уже знаешь, если поток, который мы пытаемся прервать, находится в одном из состояний ожидания, это приводит к <code>InterruptedException</code>. Данный вид исключения — проверяемый, поэтому его можно легко перехватить и выполнить нашу логику завершения программы. Что мы и сделали.

<strong>Вот наш результат:</strong>

<em><strong>Tik
Tik
Tik
Tik
Tik
Tik
Tik
Tik
Tik</strong></em>

Работа потока была прервана

На этом мы заканчиваем знакомство с основными методами класса <code>Thread</code>.

Чтобы закрепить знания, можешь посмотреть эту видеолекцию о многопоточности:
<div class="row">
<div class="col col-md-10 col-lg-8">
<div class="embed-responsive embed-responsive-16by9">
<iframe width="560" height="315" src="https://www.youtube.com/embed/zxZ0BXlTys0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>
</div>
</div>она послужит отличным дополнительным материалом! В конце, после обзора методов, в ней рассказывается как раз о том, что мы будем проходить дальше по курсу :)

Успехов!</div></div>
        <div class="article__discussion"><div class="discussion-wrap"><div class="share-and-rating"><div class="share-and-rating__container"><div class="share-and-rating__share"><div class="discussion-sharing"><div class="discussion-sharing__item"><div class="social-button-wrap"><a class="social-button social-button--vk social-button--sm"><span class="social-button__icon"><svg class="icon icon--social-vk" aria-hidden="true"><use xlink:href="/sapper/assets/icons/social.svg?v=19#icon-vk"></use></svg></span>
    </a></div></div>
  <div class="discussion-sharing__item"><div class="social-button-wrap"><a class="social-button social-button--facebook social-button--sm"><span class="social-button__icon"><svg class="icon icon--social-facebook" aria-hidden="true"><use xlink:href="/sapper/assets/icons/social.svg?v=19#icon-facebook"></use></svg></span>
    </a></div></div>
  <div class="discussion-sharing__item"><div class="social-button-wrap"><a class="social-button social-button--linkedin social-button--sm"><span class="social-button__icon"><svg class="icon icon--social-linkedin" aria-hidden="true"><use xlink:href="/sapper/assets/icons/social.svg?v=19#icon-linkedin"></use></svg></span>
    </a></div></div>
  <div class="discussion-sharing__item"><div class="social-button-wrap"><a class="social-button social-button--twitter social-button--sm"><span class="social-button__icon"><svg class="icon icon--social-twitter" aria-hidden="true"><use xlink:href="/sapper/assets/icons/social.svg?v=19#icon-twitter"></use></svg></span>
    </a></div></div></div></div>
        <div class="share-and-rating__stars"></div>
        <div class="share-and-rating__rating"></div></div></div>

  <div class="comments-container" id="discussion"><div class="comments-head d-sm-flex"><div class="comments-head__title">Комментарии
    (109)</div></div>
    <div class="comments vertical-gutter-bottom"><div class="comment-layout"><div class="no-content"><div class="no-content__body"><span class="text-uppercase">Чтобы просмотреть все комментарии или
              оставить свой,<br>
              <span class="link">перейдите в полную версию</span></span></div></div></div>
      <div class="comment-layout"><div class="comment-wrap"><div class="comment"><span class="ava__wrapper"><a href="https://javarush.ru/users/2204027" target="_blank" class="ava" tabindex="-1" style="background-image: url('https://cdn.javarush.ru/images/anonymous.svg')"><span></span></a></span>
    <div class="comment-head"><div class="head-left"><a href="https://javarush.ru/users/2204027" target="_blank" class="user">Andrzej Latysz</a>
        <span class="more-info">22
          уровень</span>



        </div>
      <div class="head-right"><span class="date">22 декабря 2020</span>
        </div></div>
    <div class="comment-body"><div class="view-text">Прошу прощения но в следующем предложении, кажется содержится ошибка - "Метод join() приостанавливает выполнение текущего потока до тех пор, пока не завершится другой поток."</div></div></div></div>
        </div><div class="comment-layout"><div class="comment-wrap"><div class="comment"><span class="ava__wrapper"><a href="https://javarush.ru/users/2181104" target="_blank" class="ava" tabindex="-1" style="background-image: url('https://cdn.javarush.ru/images/anonymous.svg')"><span></span></a></span>
    <div class="comment-head"><div class="head-left"><a href="https://javarush.ru/users/2181104" target="_blank" class="user">Игорь</a>
        <span class="more-info">26
          уровень, Санкт-Петербург</span>



        </div>
      <div class="head-right"><span class="date">7 декабря 2020</span>
        </div></div>
    <div class="comment-body"><div class="view-text">По-моему это лишнее
   Thread current = Thread.currentThread();

Можно просто написать :

    public void run() {
        while (!isInterrupted())
        {
     ///код
        }
    }

</div></div></div></div>
        </div><div class="comment-layout"><div class="comment-wrap"><div class="comment"><span class="ava__wrapper"><a href="https://javarush.ru/users/2275993" target="_blank" class="ava" tabindex="-1" style="background-image: url('https://cdn.javarush.ru/images/avatar/2275993/64.webp')"><span></span></a></span>
    <div class="comment-head"><div class="head-left"><a href="https://javarush.ru/users/2275993" target="_blank" class="user">Максим Дудин</a>
        <span class="more-info">18
          уровень, Калининград</span>



        </div>
      <div class="head-right"><span class="date">7 декабря 2020</span>
        </div></div>
    <div class="comment-body"><div class="view-text">фух.... насколько же мне проще читать текст, чем слушать лектора....  хотя он и шире излагает, но это прям на морально волевых... </div></div></div></div>
        </div><div class="comment-layout"><div class="comment-wrap"><div class="comment"><span class="ava__wrapper"><a href="https://javarush.ru/users/2241979" target="_blank" class="ava" tabindex="-1" style="background-image: url('https://cdn.javarush.ru/images/anonymous.svg')"><span></span></a></span>
    <div class="comment-head"><div class="head-left"><a href="https://javarush.ru/users/2241979" target="_blank" class="user">Алексей</a>
        <span class="more-info">19
          уровень, Night city</span>



        </div>
      <div class="head-right"><span class="date">23 ноября 2020</span>
        </div></div>
    <div class="comment-body"><div class="view-text">"Но проверить объект на значение этого флага и корректно завершить работу мы должны будем самостоятельно!"

так как же завершить поток?</div></div></div></div>
        </div><div class="comment-layout"><div class="comment-wrap"><div class="comment"><span class="ava__wrapper"><a href="https://javarush.ru/users/2412909" target="_blank" class="ava" tabindex="-1" style="background-image: url('https://cdn.javarush.ru/images/avatar/2412909/64.webp')"><span></span></a></span>
    <div class="comment-head"><div class="head-left"><a href="https://javarush.ru/users/2412909" target="_blank" class="user">Е К</a>
        <span class="more-info">20
          уровень, Краснодар</span>



        </div>
      <div class="head-right"><span class="date">30 октября 2020</span>
        </div></div>
    <div class="comment-body"><div class="view-text">Заинтересовала разница между volatile и synchronized.
Насколько я понял для себя - основное отличие это, то что volatile применяется только для полей(fields), а synchronized применяется для классов, экземпляров и блоков кода{}. Смысл же один - обеспечить одномоментный доступ к ресурсу.

Только вот понятно, что synchronized захватывает флаг(?) monitor. А вот механизм работы volatile не понятен мне пока. Иду гуглить)

Поправьте, если где ошибся.</div></div></div></div>
        </div><div class="comment-layout"><div class="comment-wrap"><div class="comment"><span class="ava__wrapper"><a href="https://javarush.ru/users/2416255" target="_blank" class="ava" tabindex="-1" style="background-image: url('https://cdn.javarush.ru/images/avatar/2416255/64.webp')"><span></span></a></span>
    <div class="comment-head"><div class="head-left"><a href="https://javarush.ru/users/2416255" target="_blank" class="user">𝔐𝔢𝔱𝔞𝔪𝔬𝔯𝔭𝔥𝔬𝔤𝔢𝔫𝔢𝔰𝔦𝔰</a>
        <span class="more-info">20
          уровень, Житомир</span>



        </div>
      <div class="head-right"><span class="date">16 октября 2020</span>
        </div></div>
    <div class="comment-body"><div class="view-text">В одних примерах метод прерывается командой break; в других return;
Есть между ними разница?</div></div></div></div>
        </div><div class="comment-layout"><div class="comment-wrap"><div class="comment"><span class="ava__wrapper"><a href="https://javarush.ru/users/1812875" target="_blank" class="ava" tabindex="-1" style="background-image: url('https://cdn.javarush.ru/images/anonymous.svg')"><span></span></a></span>
    <div class="comment-head"><div class="head-left"><a href="https://javarush.ru/users/1812875" target="_blank" class="user">Иван</a>
        <span class="more-info">28
          уровень, Санкт-Петербург</span>



        </div>
      <div class="head-right"><span class="date">13 октября 2020</span>
        </div></div>
    <div class="comment-body"><div class="view-text">Почему не сказали что в последнем примере если не будет принудительного выхода ихз цикла break; то он будет вечным даже если мы его прервали?
о том что контроль исключения на InterruptedException сбрасывает признак прерывания у потока и проверка на isInterrupted() вернет ложь Нужно было написать.
Данный пример только вводит в заблуждение и показывает пример не оптимального кода.</div></div></div></div>
        </div><div class="comment-layout"><div class="comment-wrap"><div class="comment"><span class="ava__wrapper"><a href="https://javarush.ru/users/2273741" target="_blank" class="ava" tabindex="-1" style="background-image: url('https://cdn.javarush.ru/images/avatar/2273741/64.webp')"><span></span></a></span>
    <div class="comment-head"><div class="head-left"><a href="https://javarush.ru/users/2273741" target="_blank" class="user">Павел </a>
        <span class="more-info">17
          уровень, Подольск</span>



        </div>
      <div class="head-right"><span class="date">23 августа 2020</span>
        </div></div>
    <div class="comment-body"><div class="view-text"><pre class="lang-java line-numbers"><code>
public class Main {

   public static void main(String[] args) throws InterruptedException {

       long start = System.currentTimeMillis();

       Thread.sleep(3000);

       System.out.println(" - Сколько я проспал? \n - " + ((System.currentTimeMillis()-start)) / 1000 + " секунды");

   }
}
</code></pre>

Я немного запутался от большого объема информации, поправьте пожалуйста.
Метод main у нас является единственным потоком в данном случае? С помощью метода sleep приостанавливается работа главного потока main  на 3 сек. А  метод start у нас используется, только тогда, когда в программе помимо основного потока main, есть дополнительные потоки, все верно?
</div></div></div></div>
        </div><div class="comment-layout"><div class="comment-wrap"><div class="comment"><span class="ava__wrapper"><a href="https://javarush.ru/users/2361665" target="_blank" class="ava" tabindex="-1" style="background-image: url('https://cdn.javarush.ru/images/anonymous.svg')"><span></span></a></span>
    <div class="comment-head"><div class="head-left"><a href="https://javarush.ru/users/2361665" target="_blank" class="user">wan-derer.ru</a>
        <span class="more-info">39
          уровень, Москва</span>



        </div>
      <div class="head-right"><span class="date">16 августа 2020</span>
        </div></div>
    <div class="comment-body"><div class="view-text">Пример по<strong> join()</strong>:
<pre class="lang-java line-numbers"><code>
       //Главный поток продолжит работу только после того, как t1 и t2 завершат работу
       try {
           t1.join();
           t2.join();
</code></pre>
Но ведь <strong>t1.join();</strong> уже было раньше, значит t1 уже точно завершился. Зачем писать это второй раз?
</div></div></div></div>
        </div><div class="comment-layout"><div class="comment-wrap"><div class="comment"><span class="ava__wrapper"><a href="https://javarush.ru/users/2392258" target="_blank" class="ava" tabindex="-1" style="background-image: url('https://cdn.javarush.ru/images/avatar/2392258/64.webp')"><span></span></a></span>
    <div class="comment-head"><div class="head-left"><a href="https://javarush.ru/users/2392258" target="_blank" class="user">Erik</a>
        <span class="more-info">25
          уровень, Новосибирск</span>



        </div>
      <div class="head-right"><span class="date">9 августа 2020</span>
        </div></div>
    <div class="comment-body"><div class="view-text">После просмотра видеоролика больше вопросов, чем ответов, во всяком случае у меня.</div></div></div></div>
        </div></div></div></div></div></article></div></div></div>
          <div class="site-layout__footer"><div class="footer-wrap"><footer class="site-footer site-footer--common"><div class="site-footer__container"><div class="site-footer__nav"><div class="site-footer__nav-section"><div class="site-footer-nav-wrap"><div class="site-footer-nav"><div class="site-footer-nav__head">Обучение</div>
    <ul class="site-footer-nav__list"><li class="site-footer-nav__item"><a href="https://javarush.ru/quests" class="site-footer-nav__link">Курс Java</a>
        </li><li class="site-footer-nav__item"><a href="https://javarush.ru/quests/QUEST_HARVARD_CS50" class="site-footer-nav__link">Курс Harvard CS50</a>
        </li><li class="site-footer-nav__item"><a href="https://javarush.ru/quests/QUEST_GOOGLE_ANDROID" class="site-footer-nav__link">Курс по Android</a>
        </li><li class="site-footer-nav__item"><a href="https://javarush.ru/internship" class="site-footer-nav__link">Стажировка</a>
        </li><li class="site-footer-nav__item"><a href="https://javarush.ru/help" class="site-footer-nav__link">Помощь по задачам</a>
        </li><li class="site-footer-nav__item"><a href="https://javarush.ru/prices" class="site-footer-nav__link">Подписки</a>
        </li><li class="site-footer-nav__item"><a href="https://javarush.ru/projects/games" class="site-footer-nav__link">Задачи-игры</a>
        </li></ul></div></div></div>
        <div class="site-footer__nav-section"><div class="site-footer-nav-wrap"><div class="site-footer-nav"><div class="site-footer-nav__head">Сообщество</div>
    <ul class="site-footer-nav__list"><li class="site-footer-nav__item"><a href="https://javarush.ru/users" class="site-footer-nav__link">Пользователи</a>
        </li><li class="site-footer-nav__item"><a href="https://javarush.ru/groups/posts" class="site-footer-nav__link">Статьи</a>
        </li><li class="site-footer-nav__item"><a href="https://javarush.ru/forum" class="site-footer-nav__link">Форум</a>
        </li><li class="site-footer-nav__item"><a href="https://javarush.ru/chat" class="site-footer-nav__link">Чат</a>
        </li><li class="site-footer-nav__item"><a href="https://javarush.ru/groups/stories" class="site-footer-nav__link">Истории успеха</a>
        </li><li class="site-footer-nav__item"><a href="https://javarush.ru/news" class="site-footer-nav__link">Активности</a>
        </li><li class="site-footer-nav__item"><a href="https://javarush.ru/search/post?query=конкурс от JavaRush" class="site-footer-nav__link">Конкурсы</a>
        </li></ul></div></div></div>
        <div class="site-footer__nav-section"><div class="site-footer-nav-wrap"><div class="site-footer-nav"><div class="site-footer-nav__head">О нас</div>
    <ul class="site-footer-nav__list"><li class="site-footer-nav__item"><a href="https://javarush.ru/about/mission" class="site-footer-nav__link">О JavaRush</a>
        </li><li class="site-footer-nav__item"><a href="https://javarush.ru/about/contacts" class="site-footer-nav__link">Контакты</a>
        </li><li class="site-footer-nav__item"><a href="https://javarush.ru/about/reviews" class="site-footer-nav__link">Отзывы</a>
        </li><li class="site-footer-nav__item"><a href="https://javarush.ru/about/faq" class="site-footer-nav__link">FAQ</a>
        </li><li class="site-footer-nav__item"><a href="https://javarush.ru/dialogues/administration" class="site-footer-nav__link">Поддержка</a>
        </li></ul></div></div></div>
        <div class="site-footer__nav-section"><div class="site-footer-nav-wrap"><div class="site-footer-nav"><div class="site-footer-nav__head">Видео</div>
    <ul class="site-footer-nav__list"><li class="site-footer-nav__item"><a href="https://javarush.ru/groups/posts/557-uroki-programmirovanija-na-java#3-top-features-javarush" class="site-footer-nav__link">Топ-3 фичи JavaRush</a>
        </li><li class="site-footer-nav__item"><a href="https://javarush.ru/groups/posts/557-uroki-programmirovanija-na-java#section-course" class="site-footer-nav__link">Раздел «Курс»</a>
        </li><li class="site-footer-nav__item"><a href="https://javarush.ru/groups/posts/557-uroki-programmirovanija-na-java#section-help" class="site-footer-nav__link">Раздел «Помощь»</a>
        </li><li class="site-footer-nav__item"><a href="https://javarush.ru/groups/posts/2052-razdel-igrih-na-javarush-chastjh-1-populjarnihe-voprosih#section-game" class="site-footer-nav__link">Раздел «Игры»</a>
        </li><li class="site-footer-nav__item"><a href="https://javarush.ru/groups/posts/557-uroki-programmirovanija-na-java#3ide" class="site-footer-nav__link">3 IDE</a>
        </li><li class="site-footer-nav__item"><a href="https://javarush.ru/groups/posts/557-uroki-programmirovanija-na-java#light_theme" class="site-footer-nav__link">Светлая тема сайта</a>
        </li></ul></div></div></div></div>

      <div class="site-footer__social-and-copyright"><div class="site-footer__social"><div class="social-links"><ul class="social-links__list"><li class="social-links__item"><a class="social-links__link social-links__link--vk" href="https://vk.com/javarush" target="_blank"><svg class="icon icon--social-vk" aria-hidden="true"><use xlink:href="/sapper/assets/icons/social.svg?v=19#icon-vk"></use></svg></a></li>
    <li class="social-links__item"><a class="social-links__link social-links__link--facebook" href="https://www.facebook.com/www.javarush.ru/" target="_blank"><svg class="icon icon--social-facebook" aria-hidden="true"><use xlink:href="/sapper/assets/icons/social.svg?v=19#icon-facebook"></use></svg></a></li>
    <li class="social-links__item"><a class="social-links__link social-links__link--linkedin" href="https://www.linkedin.com/company/javarush/" target="_blank"><svg class="icon icon--social-linkedin" aria-hidden="true"><use xlink:href="/sapper/assets/icons/social.svg?v=19#icon-linkedin"></use></svg></a></li>
    <li class="social-links__item"><a class="social-links__link social-links__link--twitter" href="https://twitter.com/javarush_ru" target="_blank"><svg class="icon icon--social-twitter" aria-hidden="true"><use xlink:href="/sapper/assets/icons/social.svg?v=19#icon-twitter"></use></svg></a></li>
    <li class="social-links__item"><a class="social-links__link social-links__link--youtube" href="https://www.youtube.com/channel/UCMcDsSeqS531-HKz6GiJgtA" target="_blank"><svg class="icon icon--social-youtube" aria-hidden="true"><use xlink:href="/sapper/assets/icons/social.svg?v=19#icon-youtube"></use></svg></a></li>
    <li class="social-links__item"><a class="social-links__link social-links__link--instagram" href="https://www.instagram.com/javarush_photo/" target="_blank"><svg class="icon icon--social-instagram" aria-hidden="true"><use xlink:href="/sapper/assets/icons/social.svg?v=19#icon-instagram"></use></svg></a></li>
    <li class="social-links__item"><a class="social-links__link social-links__link--telegram" href="https://t.me/javarush_original" target="_blank"><svg class="icon icon--social-telegram" aria-hidden="true"><use xlink:href="/sapper/assets/icons/social.svg?v=19#icon-telegram"></use></svg></a></li></ul></div></div>
        <div class="site-footer__acceptance"><div class="footer-acceptance"><img class="footer-acceptance__item" src="/sapper/assets/images/site/payment-systems/visa.svg" alt="Visa">
  <img class="footer-acceptance__item" src="/sapper/assets/images/site/payment-systems/mastercard.svg" alt="Mastercard"></div></div>
        <div class="site-footer__copyright site-footer__copyright--desktop">© 2021 JavaRush <span class="site-footer__tagline">«Программистами не рождаются»</span></div></div>

      <div class="site-footer__copyright site-footer__copyright--mobile">© 2021 JavaRush <span class="site-footer__tagline">«Программистами не рождаются»</span></div></div></footer></div></div></div></div></div></div></main></div>
   @Override
   public void run() {
       System.out.println("Выполнен поток " + getName());
   }
}


public class Main {

   public static void main(String[] args) {

       for (int i = 0; i < 10; i++) {
           MyFirstThread thread = new MyFirstThread();
           thread.start();
       }
   }
}

Обрати внимание: чтобы запустить поток, необходимо вызвать специальный метод start(), а не метод run()! Эту ошибку легко допустить, особенно в начале изучения многопоточности.

Если в нашем примере ты 10 раз вызовешь у объекта метод run() вместо start(), результат будет таким:

public class Main {

   public static void main(String[] args) {

       for (int i = 0; i < 10; i++) {
           MyFirstThread thread = new MyFirstThread();
           thread.run();
       }
   }
}


Выполнен поток Thread-0
Выполнен поток Thread-1
Выполнен поток Thread-2
Выполнен поток Thread-3
Выполнен поток Thread-4
Выполнен поток Thread-5
Выполнен поток Thread-6
Выполнен поток Thread-7
Выполнен поток Thread-8
Выполнен поток Thread-9

Посмотри на последовательность вывода: все идет строго по порядку. Странно, да? Мы к такому не привыкли, ведь уже знаем, что порядок запуска и выполнения потоков определяет сверхразум внутри нашей операционной системы — планировщик потоков. Может, просто повезло?

Конечно, дело не в везении. В этом можешь убедиться, запустив программу еще пару раз.

Дело в том, что прямой вызов метода run() не имеет отношения к многопоточности. В этом случае программа будет выполнена в главном потоке — том, в котором выполняется метод main(). Он просто последовательно выведет 10 строк на консоль и все. Никакие 10 потоков не запустятся.

Поэтому запомни на будущее и постоянно себя проверяй. Хочешь, чтобы выполнился run(), вызывай start(). Поехали дальше.

Метод Thread.sleep()
Для приостановки выполнения текущего потока на какое-то время, используем метод sleep().
Многопоточность: что делают методы класса Thread - 3Метод sleep() принимает в качестве параметра число миллисекунд, то есть то время, на которое необходимо «усыпить» поток.

public class Main {

   public static void main(String[] args) throws InterruptedException {

       long start = System.currentTimeMillis();

       Thread.sleep(3000);

       System.out.println(" - Сколько я проспал? \n - " + ((System.currentTimeMillis()-start)) / 1000 + " секунды");

   }
}

Вывод в консоль:

 - Сколько я проспал?
 - 3 секунды

Обрати внимание: метод sleep() — статический: он усыпляет текущий поток. То есть тот, который работает в данный момент.

Еще один важный нюанс: поток в состоянии сна можно прервать. В таком случае в программе возникнет исключение InterruptedException. Мы рассмотрим пример ниже.

Кстати, а что произойдет после того, как поток «проснется»? Продолжит ли он сразу же свое выполнение с того места, где закончил? Нет.

После того, как поток «просыпается» — когда заканчивается время, переданное в качестве аргумента в Thread.sleep(), — он переходит в состояние runnable, «работоспособный». Однако это не значит, что планировщик потоков запустит именно его. Вполне возможно, он отдаст предпочтение какому-то другому «неспящему» потоку, а наш «свежепроснувшийся» продолжит работу чуть позже.

Обязательно запомни: «проснулся — не значит продолжил работать в ту же секунду»!

Метод Thread.join()
Многопоточность: что делают методы класса Thread - 4Метод join() приостанавливает выполнение текущего потока до тех пор, пока не завершится другой поток.

Если у нас есть 2 потока, t1 и t2, и мы напишем —

t1.join()

t2 не начнет работу, пока t1 не завершит свою. Метод join() можно использовать, чтобы гарантировать последовательность выполнения потоков.

Давай рассмотрим работу join() на примере:

public class ThreadExample extends Thread {

   @Override
   public void run() {

       System.out.println("Начало работы потока " + getName());

       try {
           Thread.sleep(5000);
       } catch (InterruptedException e) {
           e.printStackTrace();
       }
       System.out.println("Поток " + getName() +  " завершил работу.");
   }
}


public class Main {

   public static void main(String[] args) throws InterruptedException {

       ThreadExample t1 = new ThreadExample();
       ThreadExample t2 = new ThreadExample();

       t1.start();



/*Второй поток t2 начнет выполнение только после того, как будет завершен
       (или бросит исключение) первый поток - t1*/

       try {
           t1.join();
       } catch (InterruptedException e) {
           e.printStackTrace();
       }

       t2.start();


//Главный поток продолжит работу только после того, как t1 и t2 завершат работу

       try {
           t1.join();
           t2.join();
       } catch (InterruptedException e) {
           e.printStackTrace();
       }

       System.out.println("Все потоки закончили работу, программа завершена");

   }
}

Мы создали простой класс ThreadExample. Его задача — вывести на экран сообщение о начале работы, потом уснуть на 5 секунд и в конце сообщить о завершении работы. Ничего сложного.

Главная логика заключена в классе Main. Посмотри на комментарии: с помощью метода join() мы успешно управляем последовательностью выполнения потоков. Если ты вспомнишь начало темы, этим занимался планировщик потоков. Он запускал их на свое усмотрение: каждый раз по-разному.

Здесь же мы с помощью метода гарантировали, что сначала будет запущен и выполнен поток t1, затем — t2, и только после них — главный поток выполнения программы.

Идем дальше.

В реальных программах тебе не раз встретятся ситуации, когда необходимо будет прервать выполнение какого-то потока.

Например, наш поток выполняется, но при этом ждет определенного события или выполнения условия. Если это произошло, он останавливается. Было бы, наверное, логично, если бы существовал какой-то метод типа stop().

Однако все не так просто. Когда-то давно метод Thread.stop() в Java действительно был и позволял прерывать работу потока. Но позже его удалили из библиотеки Java. Ты можешь найти его в документации Oracle и увидеть, что он помечен как deprecated.

Почему? Потому что он просто останавливал поток без какой-либо дополнительной работы.

Например, поток мог работать с данными и что-то в них менять. Потом его резко вырубали методом stop() посреди работы — и все. Ни корректного завершения работы, ни освобождения ресурсов, ни хотя бы обработки ошибок — ничего этого не было.

Метод stop(), если утрировать, просто крушил все на своем пути.

Его работу можно сравнить с тем, как кто-то выдергивает вилку из розетки, чтобы выключить компьютер. Да, нужного результата добиться можно. Но все понимают, что через пару недель компьютер не скажет за это «спасибо».

По этой причине логику прерывания потоков в Java изменили, и теперь используется специальный метод — interrupt().

Метод Thread.interrupt()
Что произойдет, если у потока вызвать метод interrupt()?

Есть 2 варианта:

Если объект находился в этот момент в состоянии ожидания, например, join или sleep, ожидание будет прервано, и программа выбросит InterruptedException.
Если же поток в этот момент был в работоспособном состоянии, у объекта будет установлен boolean-флаг interrupted.

Но проверить объект на значение этого флага и корректно завершить работу мы должны будем самостоятельно! Для этого в классе Thread есть специальный метод — boolean isInterrupted().

Давай вернемся к примеру с часами, который был в лекции основного курса. Для удобства он немного упрощен:

public class Clock extends Thread {

   public static void main(String[] args) throws InterruptedException {
       Clock clock = new Clock();
       clock.start();

       Thread.sleep(10000);
       clock.interrupt();
   }

   public void run() {
       Thread current = Thread.currentThread();

       while (!current.isInterrupted())
       {
           try {
               Thread.sleep(1000);
           } catch (InterruptedException e) {
               System.out.println("Работа потока была прервана");
               break;
           }
           System.out.println("Tik");
       }
   }
}

В нашем случае часы стартуют и начинают тикать каждую секунду. На 10-й секунде мы прерываем поток часов.

Как ты уже знаешь, если поток, который мы пытаемся прервать, находится в одном из состояний ожидания, это приводит к InterruptedException. Данный вид исключения — проверяемый, поэтому его можно легко перехватить и выполнить нашу логику завершения программы. Что мы и сделали.

Вот наш результат:

Tik
Tik
Tik
Tik
Tik
Tik
Tik
Tik
Tik

Работа потока была прервана

На
Брюс Эккель - Философия Java (4-е полное издание)
#JavaBooks@javatutorial

Впервые читатель может познакомиться с полной версией этого классического труда, который ранее на русском языке печатался в сокращении. Книга, выдержавшая в оригинале не одно переиздание, за глубокое и поистине философское изложение тонкостей языка Java считается одним из лучших пособий для программистов. Чтобы по-настоящему понять язык Java, необходимо рассматривать его не просто как набор неких команд и операторов, а понять его "философию", подход к решению задач, в сравнении с таковыми в других языках программирования. На этих страницах автор рассказывает об основных проблемах написания кода: в чем их природа и какой подход использует Java в их разрешении. Поэтому обсуждаемые в каждой главе черты языка неразрывно связаны с тем, как они используются для решения определенных задач.
Брюс Эккель - Философия Java (4-е полное издание).pdf
99.3 МБ
148
НравитсяПоказать список оценивших
15
Комментарий
29
ПоделитьсяПоказать список поделившихся
11K
Сначала старые
Andrey Makarov
Andrey Makarov
Подойдёт начинающему?
(Под словом "начинающий" подразумеваю человека, изучившего базовый синтаксис, циклы, основу ооп)
1
НравитсяПоказать список оценивших29 мар 2020Ответить
Михаил Коротков
Михаил Коротков
Самое оно!
4
НравитсяПоказать список оценивших29 мар 2020Ответить
Andrey Makarov
Andrey Makarov ответил Михаилу
Михаил, а практические задачи там есть?
НравитсяПоказать список оценивших29 мар 2020Ответить
Денис Рябчиков
Денис Рябчиков  ответил Andrey
Andrey, да, полно, причем они сразу даются, как только изучил какую-то маленькую тему
1
НравитсяПоказать список оценивших29 мар 2020Ответить
Михаил Коротков
Михаил Коротков  ответил Andrey
Andrey, небольшие задания есть в конце каждой главы.
НравитсяПоказать список оценивших29 мар 2020Ответить
Andrey Makarov
Andrey Makarov ответил Михаилу
Михаил, благодарю за ответ
НравитсяПоказать список оценивших29 мар 2020Ответить
Денис Рябчиков
Денис Рябчиков  ответил Михаилу
Михаил, не только в конце, если не считать первые главы
НравитсяПоказать список оценивших29 мар 2020Ответить
Андрей Лабинцев
Андрей Лабинцев
Andrey, учти, в книге нет java8. Полистай Кей С. Хорстманн - Java SE 8 Базовый курс для сравнения.
1
НравитсяПоказать список оценивших29 мар 2020Ответить
Ivan Arsyonov
Ivan Arsyonov
скачай и посмотри подойдёт она тому начинающему или нет. вопросы такие задаешь.. будто скачать и посмотреть боишься
НравитсяПоказать список оценивших29 мар 2020Ответить
Andrey Makarov
Andrey Makarov ответил Ivan
Ivan, не мог в тот момент скачать и посмотреть. Я тебе что, жизнь испортил этим вопросом или что?
НравитсяПоказать список оценивших29 мар 2020Ответить
Ivan Arsyonov
Ivan Arsyonov ответил Andrey
выбираю "или что"
НравитсяПоказать список оценивших29 мар 2020Ответить
Ivan Arsyonov
Ivan Arsyonov ответил Andrey
Andrey, книга, кстати, про JavaScript как заявлено во введении
1
НравитсяПоказать список оценивших29 мар 2020Ответить
Евгений Сигитов
Евгений Сигитов
редачер колбаса просто
НравитсяПоказать список оценивших30 мар 2020Ответить
Артём Сирош
Артём Сирош
Эх.. вот бы пятое издание вышло... Интересно, в скольки томах оно было бы?
НравитсяПоказать список оценивших29 мар 2020Ответить
Ivan ArsyonovМИНИСТЕРСТВО НАУКИ И ВЫСШЕГО ОБРАЗОВАНИЯ РОССИЙСКОЙ ФЕДЕРАЦИИ
             ФЕДЕРАЛЬНОЕ ГОСУДАРСТВЕННОЕ БЮДЖЕТНОЕ ОБРАЗОВАТЕЛЬНОЕ УЧРЕЖДЕНИЕ ВЫСШЕГО ОБРАЗОВАНИЯ
             «МОСКОВСКИЙ ПОЛИТЕХНИЧЕСКИЙ УНИВЕРСИТЕТ»
             (МОСКОВСКИЙ ПОЛИТЕХ)

             Факультет информационных технологий


             Кафедра «Прикладная информатика»
             Направление: 090301-«Информатика и вычислительная техника»
             Профиль: «Программное обеспечение средств вычислительной техники и автоматизированных систем»
             Форма обучения: заочная


             КУРСОВАЯ РАБОТА


             по дисциплине Программирование на тему «Проектирование программы с графическим интерфейсом для расчёта баллистической траектории снаряда в декартовой системе координат по углу и модулю вектора начальной скорости»


             Выполнил студент группы 183-321	_________________ 		/Фомин Д.В./
             (подпись) 			И.О. Фамилия

             Руководитель
             Курсовой работы
             ст. преп./доцент/профессор     ____________	/Осипов А.В./
             (подпись) 			И.О. Фамилия
             Оценка ______________
             Дата_________________
















             МОСКВА 2020
             МИНИСТЕРСТВО НАУКИ И ВЫСШЕГО ОБРАЗОВАНИЯ РОССИЙСКОЙ ФЕДЕРАЦИИ
             ФЕДЕРАЛЬНОЕ ГОСУДАРСТВЕННОЕ БЮДЖЕТНОЕ ОБРАЗОВАТЕЛЬНОЕ УЧРЕЖДЕНИЕ ВЫСШЕГО ОБРАЗОВАНИЯ
             «МОСКОВСКИЙ ПОЛИТЕХНИЧЕСКИЙ УНИВЕРСИТЕТ»
             (МОСКОВСКИЙ ПОЛИТЕХ)

             Факультет информационных технологий


             Кафедра «Прикладная информатика»
             Направление: 090301-«Информатика и вычислительная техника»
             Профиль: «Программное обеспечение средств вычислительной техники и автоматизированных систем»
             Форма обучения: заочная

             З А Д А Н И Е на КУРСОВУЮ РАБОТУ
             по дисциплине	«Программирование»

             на тему	«Проектирование программы с графическим интерфейсом для
             расчёта баллистической траектории снаряда в декартовой системе координат по углу и модулю вектора начальной скорости»
             выдано студенту группы   183-321 Фомину Дмитрию Владимировичу
             (фамилия, имя, отчество)

             Исходные данные	Дмитриевский А.А., Лысенко Л.Н. «Внешняя Баллистика»,
             https://nauka.club/fizika/ballisticheskoe-dvizhenie.html, лекции по физике раздела «кинематика».


             Содержание пояснительной записки (перечень подлежащих разработке вопросов)
             Для определения баллистической траектории снаряда  нужно знать его первоначальную скорость и угол
             наклона. Построить баллистическую таблицу, в которой аргументом является время, а функцией –
             значение координат снаряда. Первоначальная скорость и угол вводится текстовых строках.



             Перечень графического материала	Изображения: рисунок 1-22, скриншот 1-11,
             Таблица 1-2





             Дата сдачи курсового проекта на проверку руководителю	27 июня 2020 года

             Дата выдачи задания	15 июня 2020 года


             Руководитель КР
             Уч. степень, уч. звание 		            _______________	/____Осипов А.В._/
             (подпись) 			И.О. Фамилия

             Задание принял к исполнению            	_______________	          /____Фомин Д.В.____/
             (подпись) 			И.О. Фамилия


             Содержание
             	Введение…………………………………………………………………….4
             	Аналитическая часть……………………………………………………….6
             	Общая характеристика объекта исследования…………………….6
             	Анализ уровня и особенностей применения информационных технологий…………………………………………………………...8
             	Анализ существующих систем и методик решения поставленных задач………………………………………………………………….9
             	Обоснование направлений проектных подходов в разрабатываемой информационной системе……………………..12
             	Теоретическая часть………………………………………………………13
             	Выбор и обоснование применяемого метода…………………….13
             	Математические модели…………………………………………...14
             	Среда разработки автоматизированной системы………………..19
             	Язык программирования для реализации…………………19
             	Среда разработки……………………………………………20
             	Проектная часть…………………………………………………………...24
             	Общая структура программы……………………………………...24
             	Структура программных блоков и реализация программы……..26
             	Технические требования и характеристики……………………...31
             	Перечень выполненных проектных решений……………………34
             	Заключение………………………………………………………………..35
             	Список основных источников и литературы………………………..….38
             	Приложение……………………………………………………………....39
             	Листинг……………………………………………………………..39
             	Скриншоты работы программы………………………………….54
             Проектирование программы с графическим интерфейсом для расчёта баллистической траектории снаряда в декартовой системе координат по углу и модулю вектора начальной скорости
             Введение
             Одна из основных задач, решаемых вычислительной системой артиллерийского зенитного комплекса – это задача встречи снаряда с целью. В свою очередь, основа проблемы составляет задача прогнозирования траектории полета снаряда на произвольный отрезок времени в будущем. В большинстве зенитных комплексов, принятых в настоящее время на вооружение, прогнозирование траектории полета снаряда решается табличным способом. Для каждого разрабатываемого образца вооружения составляются оригинальные таблицы стрельбы, которые состоят из баллистических таблиц.
             Размер таблицы зависит от калибра артиллерийского орудия (для калибра 30 мм размер таблицы составляет около 200 значений). В связи с компактностью таблиц их размещение в памяти вычислительной системы не вызывает трудностей. Выборка из двумерной таблицы, как правило, сопровождается линейной интерполяцией значений для произвольных аргументов дальности D и угла места E. Практическая реализация задачи встречи с использованием табличного прогнозирования траектории полета снаряда возможна, если производительность вычислительной системы превышает миллион операций в секунду. Для настоящего уровня развития вычислительной техники указанное требование по производительности вычислений является довольно скромным (например, микроконтроллер фирмы Atmel AT91R40807 производительностью 30 миллионов операций в секунду снят с производства как морально устаревший).
             Альтернативой табличному способу расчета траектории полета снаряда является способ численного интегрирования системы дифференциальных уравнений, описывающих траекторию полета снаряда в атмосфере Земли. Задача построения системы дифференциальных уравнений, в основе которой лежит изучение влияния действия внешних сил и моментов сил на снаряд с момента прохождения его среза дула ствола орудия, называется основной задачей внешней баллистики. Этой задачей занимались довольно давно, теория вопроса достаточно проработана [1, 2]. В этой литературе представлена расчетная модель для вычисления кинематических элементов траектории полета снарядов, которая позволяет учесть форму и вращение Земли, возмущение атмосферы, принудительное вращение снаряда, колебания снаряда относительно центра масс. Практическая реализация задачи встречи с использованием метода численного интегрирования системы дифференциальных уравнений траектории полета снаряда возможна, если производительность вычислительной системы превышает 15 миллионов операций в секунду. Такая производительность вычислений вполне доступна на практике (например, микроконтроллер фирмы Atmel AT91R40008 производительностью 60 миллионов операций в секунду, AT91SAM9 – 200 миллионов операций в секунду, процессоры фирмы Texas Instruments TMS320C64x+ – 1000 миллионов операций в секунду). Таким образом, в настоящее время не существует объективных препятствий в практической реализации метода численного решения задачи внешней баллистики в вычислительной системе зенитного комплекса.
             Хотя метод численного интегрирования по сравнению с табличным является более затратным, он превосходит последний в точности определения параметров траектории полета снаряда. Табличный метод представляет собой приближенное частное решение, в котором упрощенно учитывается взаимное влияние (иными словами, учитывается только главный член разложения) отдельных внешних факторов на результат решения задачи внешней баллистики снаряда. Это важно по той причине, что в табличном методе решение ищется в виде суммы: расчет траектории снаряда в стандартных метеобаллистических условиях (баллистические таблицы) плюс изменения в траектории, вызванные отклонениями баллистических и метеорологических условий от принятых за стандартные (поправочные таблицы). Таким образом, точность табличного метода расчета ограничена учетом только линейных связей внешних факторов с результатом.
             Опережающие темпы развития цифровой элементной базы по сравнению с темпами совершенствования материальной части артиллерийского вооружения создали условия повышения эффективности существующих зенитных комплексов за счет внедрения более совершенных алгоритмов управления, которые не удалось реализовать ранее из-за ограниченных возможностей вычислительной техники. В рамках предполагаемой модернизации предлагается заменить алгоритм табличного прогнозирования траектории полета снаряда на алгоритм численного интегрирования системы дифференциальных уравнений задачи внешней баллистики полета снаряда.
             В условиях поставленной задачи, ограничении начальных данных для расчёта и технических возможностей было принято решение выполнить реализацию расчёта табличным методом.
             В связи с поставленным условием задачи будет рассматриваться табличный способ рассмотрения траектории полёта снаряда с учётом начальных координат полёта, направления и модуля вектора начальной скорости. Для получения удовлетворяющего результата, будет должна быть реализована возможность самостоятельно указать шаг измерения по времени полёта, начальные координаты полёта, а также вычисляется дополнительные ключевые параметры, такие как время полёта горизонтальное, время полёта вертикальное, общая продолжительность полёта, максимальная высота подъёма снаряда и дальность выстрела по горизонтальное проекции.
             Расчёт траектории полёта снаряда является задачей при стрельбе из артиллерийских орудий и зачастую производится с помощью расчётных таблиц, составленных экспериментально. Целью данной работы является создание программы для составление баллистической таблицы.
             Актуальность данной темы заключается в том, что она ускорит наводку орудий без встроенного баллистического калькулятора, такие как миномёт и прочие. Цель данного проекта - это создания программы ускоряющий процесс наведения орудия.
             Перед проектом определен ряд задач:
             	Обеспечить пользователю интерфейс для ввода данных.
             	Создать методы для расчёта.
             	Реализовать структурированный вывод результатов вычислений.
             	Реализовать функционал для построения таблицы, отражающих траекторию.
             	Обеспечить защиту от сбоев в работе программы при расчёте.
             Аналитическая часть
             1.Общая характеристика объекта исследования
             Определение баллистики звучит следующим образом – наука о движении тел, двигающихся в пространстве. Она изучает в первую очередь принципы движения всевозможных объектов, в частности пуль и снарядов, а также законы природы, влияющие на это движение и способность тела преодолевать возникшие на его пути преграды.
             Физика и математика - вот основы, на которых базируется эта наука, они позволяют при должных знаниях рассчитывать траекторию полёта пули, исходя из воздействия на неё внешних сил, и её проникающую способность. Сама же наука о законах полета снарядов делится на 4 направления (рисунок 1):
             	Исследование движения пули или снаряда в канале ствола орудия изучает направление, которое называется внутренняя баллистика.

             	Поведение снаряда на выходе из канала ствола и в районе дульного среза исследуется промежуточной баллистикой и используется в разработке пламегасящих устройств и глушителей.

             	Вопросы движения снаряда в атмосфере и при воздействии внешних факторов изучаются внешней баллистикой. Основная область её применения – установление поправок на упреждение и влияние скорости ветра на траекторию.
             	Изучение проникающей способности снаряда – цель исследований баллистики под названием преградная (терминальная), которую изучают специалисты по вопросам бронезащиты.

             Рисунок 1
             Метательные камни, ножи и дротики, ручные пращи, луки, арбалеты, а впоследствии – баллисты, катапульты, требушеты, толлеоны и, в конце концов, огнестрельное оружие и артиллерийские орудия - все эти средства толкали науку баллистики на протяжении всей своей истории. Начало изучения траектории полета снаряда, как науки, было положено Николло Тарталья в 1537 году, начавшим исследование кривой движения этого тела. Продолжил изучение Галилей, сформулировав параболическую теорию.
             Развивал данную тему и Ньютон, благодаря изучению законов воздушного сопротивления которого стало возможным доказать невозможность параболической кривой полета снаряда. Его дело продолжил Бенджамин Робинс, основное исследование которого - расчет начальной скорости ядра.
             Далее баллистика развивалась семимильными шагами. Вошедшее в обиход в начале XIX века нарезное оружие, а также использование адаптированных под него снарядов и нового образца патрона, с пулей продолговатой формы, а точнее – необходимость изучения их эффективности и дальнейшей оптимизации, стали серьезным толчком в изучении данной науки, поскольку характеристики нового оружия были весьма высоки, что обуславливало широкую его популярность, и как следствие – высокий спрос. Одним из ключевых витков истории баллистики стала разработка численного метода интегрирования дифференциальных уравнений, созданного Карлом Рунге и Мартином Кутта. Определенные элементы их метода позволяли с максимальной точностью вести расчеты траектории тел в пространстве.

             Определим, что же в итоге представляет собой баллистическая траектория. Современная энциклопедия гласит: «Это траектория движения свободно брошенного тела под действием только силы тяжести» (рисунок 2)
             Например, межконтинентальные баллистические ракеты считаются таковыми, поскольку продолжают своё движение к цели после выключения двигателей, как раз-таки по траектории, которую называют баллистической.  Здесь же – расчет ведения огня по настильной траектории, проще говоря – плавно опускающейся линии по ходу полета снаряда, и расчет возможности преодолевать возвышения по пути к конечной точке. Фактически, таковым является движение любого тела в пространстве, при отсутствии какой-либо дополнительной тяги.
             2.Анализ уровня и особенностей применения информационных технологий
             Существует большое количество баллистических программ. Есть бесплатные и платные, дешевые и не очень. Но стоимость программы не является индикатором того, насколько точными будут её расчеты. Точность расчета траектории зависит от точности исходных данных. Необходимость точно рассчитать траекторию на конечном участке полёта пули, важна стрелкам, которым требуется попадание с первого выстрела. Но не нужно забывать, что баллистические программы также могут быть использованы для проведения сравнительного анализа характеристик. Из огромного множества программ, занимающихся расчетами баллистических характеристик, были выбраны и проанализированы 3 наиболее популярные и, с точки зрения оценки баллистиков, наиболее полные в расчете выходных данных. Программа «Баллистический исследователь» лаборатории Ойлера вычисляет траекторию и все ее параметры для любых патронов, зарядов пороха и разных пуль при различных скоростях и в разных условиях. В ней содержатся данные о выпускаемых боеприпасах и пулях. Она может высчитывать все необходимые данные о выстреле, основанные на этой информации, и некоторых дополнительных данных, которые может ввести стрелок. Результаты могут быть представлены в виде графика или таблиц. «Данные о выстреле» включают в себя траекторию, скорость, энергию, понижение, дальность по горизонту и некоторые другие. Программа производит вычисления, основанные на различных баллистических моделях, и может вычислить, в том числе и другие параметры, основываясь на введенных данных. На практике она берет в расчет баллистический коэффициент и скорость и вычисляет траекторию. Если вы введете данные о направлении ветра и его скорости, то она вычислит и ветровой снос. Если вы добавите другие факторы, влияющие на траекторию, например температуру, барометрическое давление, высоту и угол стрельбы, программа их тоже обработает. Каждый набор вычислений для данной скорости пули называется трассированием. Программа может прорабатывать три трассировки одновременно и выводить их в одном графике для удобства сравнения. Данные о боеприпасах и пулях из «Баллистического Исследователя» можно вызвать и использовать для вычислений, что позволит сравнить показатели вашего оружия с показателями завода – изготовителя патронов. В общем, это очень полезная программа и совсем не сложная для тех, кто пользуется персональным компьютером. Программа компании «Сьерра», по сути выполняет те же функции, что и программа Ойлера, но у нее другой подход и, соответственно, она немного более гибкая. Программа не совсем проста для пользователя, но тем не менее она предлагает несколько полезных функций. Например, у нее есть отдельная функция вычисления баллистического коэффициента с использованием данных, введенных пользователем. Исходя из рассмотренных выше двух похожих программ, производящих расчеты баллистических параметров, можно сделать вывод о том, что они обе очень удобны для компьютерных баллистических вычислений, но не являются уникальными в своем роде и максимально полными в плане выходных параметров. «Прикладная аналитическая баллистика», появившаяся в 2014 году, дает возможность её пользователям рассчитать траекторию выстрела, не только используя баллистические коэффициенты, но и применять индивидуальные баллистические профили. Данная система, подкрепленная информационной базой, собранной в лабораторных условиях, предоставляет уникальный инструмент «Аналитик зоны поражения цели» (ЗПЦ), наряду с полным набором стандартных баллистических функций. Аналитик ЗПЦ – возможность расчёта вероятности попадания по цели на различные дальности, предоставляющая стрелку установить границы неопределенности параметров. Помимо выше изложенных функций, в программу еще входит «Аналитик ветрового профиля». Он позволяет рассчитывать среднее значение непробития, учитывая силу и направление ветра на нескольких участках траектории, вплоть до 10 отрезков. Кроме того, стрелок может загружать индивидуальные баллистические профили на совместимые устройства [3]. Конечно, существуют и другие баллистические программы, позволяющие проводить корректные расчёты. Необходимо понимать, какие цели каждый перед собой ставит, и какие инструменты необходимы для решения поставленной задачи. Заключение В данной статье были проанализированы программы компании «Сьерра», лаборатории Ойлера, и «Прикладная аналитическая баллистика» от Брайана Литца. Данные программы являются одними из самых распространенных в области внешней баллистики и каждая из них по-своему уникальная, и решает ряд поставленных задач, нужных её владельцу. Следует заметить, для получения корректного результата в любой баллистической программе, 79 необходимо быть уверенным, что входные данные являются истинными. А именно, данные с высокой долей достоверности, с минимальными погрешностями и в той системе измерений, которые необходимы выбранной программе. Именно от этого в конечном счете зависит точность результата, полнота и достоверность выходных данных любой программы.
             3.Анализ существующих систем и методик решения поставленных задач
             Важную роль в баллистическом методе играют математические модели, которые с требуемой глубиной и полнотой описывают движение снаряда. В зависимости от условий стрельбы, типа снаряда и средства метания, а также назначения модели, существует множество математических моделей движения снаряда. В них снаряд может быть абсолютно твердым или деформируемым телом, иметь постоянную или переменную массу, а движение снаряда может быть свободным или несвободным, рассматривается в разных системах отсчета и описывается с помощью различных методов теоретической механики и математики.

             Рисунок 3
             Если обобщить все изложенное выше и учесть поставленную задачу, то баллистический метод можно представить состоящим из следующих основных этапов (рисунок 3):
             	Баллистический анализ снаряда: назначение, конструкция, материалы, форма, размеры, масса и ее распределение, функционирование.
             	Баллистический анализ средств метания: назначение, конструкция, источники энергии, движители, взаимодействие со снарядом, основные процессы, основные параметры, эксплуатация.
             	Анализ условий стрельбы: характеристики окружающей среды, взаимодействие снаряда со средой, силы и моменты, действующие на снаряд, боевое применение.
             	Построение физической модели движения снаряда: анализ экспериментальных данных, выявление основных процессов и факторов, обоснование допущений.
             	Выбор систем отсчета: основная система отсчета, дополнительные системы координат, способ преобразования координат.
             	Составление математической модели движения: выбор математического метода, описание основных процессов, переход от векторной к аналитической форме, замыкание системы уравнений, начальные и граничные условия.
             	Качественный анализ движения: анализ дифференциальных уравнений, качественные зависимости элементов движения от времени, оценка устойчивости движения, оценка влияния дополнительных факторов.
             	Интегрирование системы дифференциальных уравнений: выбор метода интегрирования, преобразование уравнений, упрощение системы уравнений, получение конечных результатов.
             	Согласование решения основной задачи баллистики с опытом: отбор опытных данных, расчет траектории, сравнение результатов, выявление причин расхождения, коррекция математической модели.
             	Разработка способов применения решения основной задачи баллистики для практики: поиск потребителей, анализ практических задач, разработка алгоритма, решение задачи, трансформация решения, оценка полученных результатов.
             В зависимости от глубины изучения движения снаряда число баллистических параметров будет различным. При подробном рассмотрении всех процессов, сопровождающих движение снаряда, в систему уравнений внутренней и внешней баллистики войдет более сотни баллистических параметров. При инженерном подходе их число уменьшится. Среди баллистических параметров особое место занимают величины й,v,c,p, являющиеся интегральными параметрами. Начальная скорость снаряда зависит от условий его движения в канале ствола и дополнительно учитывает действие на снаряд процесса истечения пороховых газов после вылета. Угол бросания связан с наведением орудия на цель и включает еще угол вылета, возникающий вследствие кривизны канала ствола и колебательного движения ствола и снаряда в нем. Баллистический коэффициент с характеризует взаимодействие снаряда с атмосферой Земли в полете, которое зависит от многих факторов и, в частности, от формы снаряда. Давление форсирования p учитывает процесс врезания ведущих поясков снаряда в нарезы и весьма сложным образом связано с конструкцией снаряда и ствола. Первая характеристика формы пороха й отражает процесс образования пороховых газов и, в частности, прогрессивность и однообразие горения пороха. Точные значения этих баллистических параметров могут быть получены только экспериментальным путем.
             4.Обоснование направлений проектных подходов по разрабатываемой информационной системе
             В заключение необходимо отметить, что при определении баллистических параметров всё обычно приводится к нормальным (табличным) метеорологическим и баллистическим условиям:
             	Атмосфера относительно Земли неподвижна (ветер и осадки отсутствуют).
             	Температура, давление, плотность и влажность воздуха соответствуют нормальной артиллерийской атмосфере (НАА).
             	Размеры и форма снаряда, марка пороха, чертежные (номинальные).
             	Массы снаряда и метательного заряда соответствуют принятым в таблицах стрельбы.
             Полученные в разных местах и в разное время, но приведенные к нормальным условиям значения баллистических параметров и результаты решения баллистических задач могут сравниваться между собой и использоваться в разных организациях.

             Рисунок 4
             При расчетах и изучении баллистического движения любого тела, стоит обратить внимание на огромное количество факторов – массу, скорость и обтекаемость тела, атмосферные условия и многое-многое другое. Но даже при учете этого, в баллистике есть свои основные формулы, являющиеся основой любого подобного расчёта (рисунок 4). Так по условию пользователь задаёт только угол вектора начальной скорости к горизонту и модуль вектора начальной скорости, а требуется создать баллистическую таблицу аргументом времени, и функцией координат снаряд в момент времени, то для удобства расчёта было решено внедрить дополнительные функции ввода шага измерения по времени и координаты точки начала полёта снаряда. Ограничениями является угол, который не должен быть в диапазоне (-π/2;π/2). Так же для наглядности расчётов было решено дополнительно указать максимальную высоту полёта снаряда, веря полёта вверх, время полёта вниз, общее время полёта, а также расстояние по горизонтали, которое пройдёт снаряд за общее время полёта.
             Теоретическая часть
             1.Выбор и обоснование применяемого метода
             На брошенное под углом к горизонту тело в полете действует по меньшей мере – сила тяжести и сопротивление воздуха. Если исключить из этого силу сопротивления, то, согласно 2-го закону Ньютона, тело движется с ускорением, равным ускорению свободного падения; проекции ускорения на координатные оси равны (рисунок 5)

             Рисунок 5
             ах = 0, ау = -g.
             Проекции скорости тела, следовательно, изменяются со временем следующим образом: Vx = Vx0 = V0 * cos α;
             Vy = Vy0 – g * t = V0 * sin α – g * t, где V0 - начальная скорость, α – угол бросания. Координаты тела, следовательно, изменяются так: x = x0 + V0 * t * cos α; y = y0 + V0 * t * sin α – 0,5 * g * t2.
             Если за точку отсчета берутся координаты х = у = 0, то: x = V0 * t * cos α; y = V0 * t * sin α – 0,5 * g * t2.
             Дальнейшие расчеты производятся при введении таких переменных как дальность полета и время, в итоге же получается финальное уравнение траектории движения. Выглядит оно следующим образом: y = x * tg α – g * x2 / 2 * V02 * cos2α.
             Выше приведена общая характеристика выбранного метода для реализации программы. Далее будет разбираться математический метод исходя из условий поставленной задачи.
             2.Математические модели
             Для удобного и эффективного расчёта пользователь задаёт параметры угла вектора начальной скорости к горизонту α,  модуль начальной скорости V0, шаг измерения координат снаряда по времени ∆t, а так же начальные координаты снаряда x, y в момент времени T=0 c. В результате для пользователя должна быть построена баллистическая таблица, где T-аргумент, координаты X, Y-функции от аргумента t (таблица 1).

             T	X	Y
             0	x	y
             ∆t
             	v*∆t*cos⁡α+x
             	|v*∆t*sin⁡α-(g*〖∆t〗^2)/2+y|
             2*∆t
             	v*2*∆t*cos⁡α+x
             	|v*2*∆t*sin⁡α-(g*(2*〖∆t)〗^2)/2+y|
             3*∆t
             	v*3*∆t*cos⁡α+x
             	|v*3*∆t*sin⁡α-(g*(3*〖∆t)〗^2)/2+y|
             4*∆t
             	v*4*∆t*cos⁡α+x
             	|v*4*∆t*sin⁡α-(g*(4*∆t)^2)/2+y|
             5*∆t
             	v*5*∆t*cosα+x
             	|v*5*∆t*sin⁡α-(g*(5*∆t)^2)/2+y|
             …………………....	……………………………………………...	……………………………………………………...............................................

             Таблица 1
             На таблице 1 мы видим образец баллистической таблицы, внутри ячеек, за исключение первой строки стоят формулы функций. Иными словами, формулы для функций X(T) и Y(T) имеют следующий вид:
             {█(X(T)=v*n*∆t*cos⁡(α)+x,@Y(T)=|v*n*∆t*sin⁡(α)-(g*(n*∆t)^2)/2+y| ),┤  n-номер шага
             Так же программа должна рассчитать дополнительные ключевые баллистические показатели:
             	Максимальная высота H подъёма от начальной точки вылета снаряда
             	Время движения вверх t1
             	Время движения вниз t2
             	Общее время полёта T
             	Дальность полёта по проекции на горизонталь S

             H=sin⁡(α)*v*t1-(g*〖t1〗^2)/2

             t1=(sin⁡(α)*v)/g

             t2=√((2*(H+y))/g)

             T=t1+t2

             S=T*cos⁡(α)*v


             У вводимых параметров есть ограничения, в случаи нарушения которых будет появляться окно с ошибкой. Следующие ограничения на вводимые параметры:
             π<α<0

             0<v<1.7E+308

             0<∆t<1.7E+308

             -1.7E+308<x<1.7E+308

             -1.7E+308<y<1.7E+308

             Общие модели вычислений будут представлена в виде блок-схемы:
             1)Приём параметров из текстовых окон и их проверка на соответствие представленным выше критериям (рисунок 6)

             Рисунок 6
             2)Обработка значений t1, t2, T, H в конструкторе класса (рисунок 7)


             Рисунок 7
             3)Вычисление количества шагов измерения координат снаряда по времени (рисунок 8)


             Рисунок 8
             4)Вычисление значений функций X(t), Y(t) (рисунок 9)


             Рисунок 9
             4)Вычисление пройденного расстояния по горизонтали за время полёта снаряда S и вывод ключевых показателей пользователю (рисунок 10)


             Рисунок 10
             Так же все ключевые параметры, которые будут выведены программой на экран, будут округлены до 3-х знаков после запятой, что связано с размерами взятых единиц измерения (таблица 2):

             Параметр	Единица измерения
             α	градус
             v	м/c
             ∆t	c
             x	-
             y	-
             H	м
             t1	с
             t2	с
             T	с
             S	м
             X	-
             Y	-
             Таблица 2
             3.Среда разработки автоматизированной системы
             Для удобства пользователя было решено выполнить программу по расчёту баллистической траектории в графическом интерфейсе. Для эффективной реализации математической модели необходим язык объектно-ориентированного программирования (ООП), так как при таком наборе элементов необходима структура классов, конструкторов классов. Для реализации проекта был выбран язык ООП Java. А для наиболее эффективной реализации графического интерфейса была взята среда NET Beans 12.0. Далее проанализируем главные особенности языка Java, а также ощие характеристики среды NET Beans.
             3.1Язык программирования для реализации
             Java — язык программирования общего назначения. Относится к объектно-ориентированным языкам программирования, к языкам с сильной типизацией.
             Java является объектно-ориентированным языком, относится к языкам программирования с сильной типизацией.
             Создатели реализовали принцип WORA: write once, run anywhere или «пиши один раз, запускай везде». Это значит, что написанное на Java приложение можно запустить на любой платформе, если на ней установлена среда исполнения Java (JRE, Java Runtime Environment).
             Эта задача решается благодаря компиляции написанного на Java кода в байт-код. Этот формат исполняет JVM или виртуальная машина Java. JVM — часть среды исполнения Java (JRE). Виртуальная машина не зависит от платформы.
             В Java реализован механизм управления памятью, который называется сборщиком мусора или garbage collector. Разработчик создаёт объекты, а JRE с помощью сборщика мусора очищает память, когда объекты перестают использоваться. Существует понятие — циклический мусор. Внутри цикла на все объекты есть ссылки, однако garbage collector в Java удалит его, если объекты не могут использоваться из программы.
             Выше отмечено, что Java относится к языкам программирования общего назначения. Новичкам интересно знать, что конкретно пишут Java-программисты, чтобы определиться с выбором языка.
             По данным компании Oracle, программы на Java запускаются на 3 млрд девайсов. Именно такое сообщение можно увидеть в окне установки.
             Это маркетинговое сообщение сложно проверить. Тем не менее Java широко используется и входит в число самых востребованных языков, это не вызывает сомнения.
             Например, подавляющее большинство крупных компаний так или иначе используют Java. Очень много серверных приложений для корпораций написаны на этом языке. Например, речь идёт о программах для финансовых организаций, которые обеспечивают проведение транзакций, фиксацию торговых операций.
             На Java написано много веб-приложений. Популярные фреймворки, в том числе Spring, Stuts, JSP, используются для создания разных приложений в вебе: от ecommerce-проектов до крупных порталов, от образовательных платформ до правительственных ресурсов.
             Популярная компьютерная игра Minecraft написана на Java.
             Мобильная разработка — ещё одна область использования Java. На этом языке пишут приложения для устройств, работающих под управлением ОС Android.
             На Java создают клиентские приложения. Простой и близкий разработчикам пример: IDE NetBeans написано на «джаве».
             Также Java применяется для работы с Big Data, разработки программ для научных целей, например, обработки естественных языков, программирования приборов — от бытовых девайсов до промышленных установок.
             То есть на Java можно писать разные типы приложений: веб, мобильный и десктопный софт, игры и так далее. Традиционно у этого языка сильные позиции в промышленном программировании, в сегменте крупных компаний (т.н. энтерпрайз).
             Промежуточный итог: Java — язык программирования общего назначения. Имеет си-подобный синтаксис. Используется для создания приложений в разных областях: от веба до разработки игр, от мобильного ПО до программ для корпораций и научных институтов.
             3.2 Среда разработки
             NetBeans IDE - бесплатная интегрированная среда разработки с открытым исходным кодом для разработчиков программного обеспечения. Среда предоставляет все средства, необходимые для создания профессиональных десктоп приложений, корпоративных, мобильных и веб-приложений на платформе Java, а также C/C++, PHP, JavaScript, Groovy и Ruby.
             Официальный сайт: http://netbeans.org/index_ru.html
             Основные характеристики NetBeans IDE:
             Рабочая область среды IDE является полностью настраиваемой - существует возможность пользовательской настройки действий, выполняемых с помощью панели, назначения "горячих" клавиш и т.д.
             IDE имеет в своем составе расширенный многоязыковой редактор для различных языков программирования - Java, C/C++, Ruby, Groovy, PHP, JavaScript, CSS, XML, HTML, RHTML, JSP, документацию Javadoc. Существует возможность расширения функций редактора с целью поддержки любого другого языка.
             Редактор NetBeans делает отступы строк, проверяет соответствие скобок и слов, подсвечивает синтаксис исходного кода.
             Производится проверка ошибок во время ввода, отображение вариантов для автозавершения кода и фрагментов документации по требуемому языку программирования.
             Редактор может генерировать и вставлять в исходный код стандартные фрагменты кода на Java или других языках.


             Рисунок 11


             Браузер классов позволяет просматривать иерархию и структуру любого класса Java - отображаются интерфейсы, базовые классы, производные классы и члены классов.
             Существует возможность перемещения любой вкладки редактора в пределах рабочего пространства IDE и за её пределы, создавая независимое окно, которое можно переместить на второй экран.
             Возможность группирования связанных проектов - создавая группы проектов, можно быстро открывать и закрывать несколько сгруппированных проектов одновременно.
             Расширенные средства для выполнения контекстно-зависимого поиска по всей среде IDE, справочным материалам и всем открытым проектам, и файлам.
             Существует возможность создания проектов в свободном формате или начинать работу с проектом с шаблона. В комплекте со средой IDE поставляются шаблоны и примеры проектов для приложений Java SE, мобильных, веб-приложений и приложений уровня предприятия, приложений JavaFX, подключаемых модулей NetBeans, приложений Groovy, PHP, C/C++, Ruby и Ruby on Rails.
             NetBeans IDE является платформой для построения десктоп приложений с функциональным пользовательским интерфейсом, т.к. представляет из себя фреймворк к Java библиотеке Swing.
             NetBeans имеет встроенную поддержку CVS, Mercurial и Subversion. Для просмотра изменений используется редактор с цветовыми обозначениями.

             Возможности программирования в NetBeans:
             Разработка Java десктоп приложений с профессиональными графическими интерфейсами пользователя. Используется визуальный редактор - Swing GUI Builder. Работа осуществляется путем перетаскивания элементов графического интерфейса из палитры на холст. Предварительное позиционирование элементов можно осуществлять с помощью указателя мыши. Панель свойств и инспектор компонентов предоставляют возможность тонкой настройки каждого компонента интерфейса.


             Рисунок 12


             Создание веб-приложений и корпоративных приложений в соответствии со стандартами. Среда NetBeans предоставляет полную поддержку Java EE 6. Позволяет разрабатывать веб-страницы, сервлеты, веб-сервисы, Enterprise Java Beans (EJB), проекты Java EE с использованием JavaServer Faces 2.0 (Facelets), Spring, Struts и Hibernate.
             Программирование на PHP, поддержка всех сопутствующих языков программирования, технологий и веб-стандартов. Возможность создавать проекты PHP на основе платформы Zend или Symfony. Редактор PHP динамически интегрирован с функциями редактирования HTML, JavaScript и CSS. Проекты PHP могут быть развёрнуты из среды NetBeans на локальном или удаленном сервере при взаимодействии через FTP или SFTP.
             Возможность создания, тестирования, отладки и внедрения приложений, функционирующих на мобильных телефонах, карманных компьютерах, телеприставках и встраиваемых системах. Visual Mobile Designer (VMD) создает всю необходимую модульную инфраструктуру проекта и обеспечивает быструю разработку графических интерфейсов путём перетаскивания в рабочую область компонентов - экран ожидания, экран входа в систему, обозреватель файлов, средство составления сообщений SMS и экран заставки. Возможность создания пользовательского интерфейса на основе SVG.
             Использование JavaFX Composer для визуального структурирования приложения JavaFX с графическим интерфейсом, аналогично конструктору GUI Swing для Java десктоп приложений.
             Возможность разработки профессиональных приложений на языках C, C++ для различных платформ - Windows, Linux, Mac и Solaris. Поддерживаются все широко используемые компиляторы - GNU, Cygwin и MinGW. Существует возможность установки требуемого компилятора, определений препроцессора, параметров времени компиляции и т.д.
             Расширенные возможности по работе с базами данных - встроенный клиент к базам данных - MySQL, Postgres, Oracle и др., редактор запросов SQL, возможность редактировать таблицы баз данных напрямую через редактор таблиц.


             Рисунок 13


             Интеграция с серверами приложений и контейнерами сервлетов - автоматическое развёртывание приложений, управление сервером - запуск, остановка, перезапуск.
             Многоязычный пользовательский интерфейс с поддержкой русского языка.
             Расширение функциональности с помощью подключаемых модулей, гибкая система управления компонентами, модулями, обновление и загрузка модулей через интернет.
             Проектная часть
             1.Общая структура программы
             Для реализации графического интерфейса программы была использована среда IDE NET Beans 12.00. В данной программе содержатся следующие компоненты библиотеки swing: Jtable, JButton, JScrollPane, jTextField, JFrame
             Расположение основных компонентов можно наблюдать на схеме (рисунок 14).

             Рисунок 14
             Для наиболее эффективной работы программы и реализации кода был введёт конструктор класса Class1(double v, double l, double n, double x, double y), который выполняет обработку параметров, введённых пользователем.
             При всём вышесказанном структура программы достаточно сложна, но при этом крайне оптимально структурирована за счёт использования возможностей ООП, которым является Java. Множество классов для реализации программы взято из готовых библиотек, в частность для реализации графического интерфейса это библиотека «swing». Связь между классами осуществляется преимущественно композицией с соответствующими отношениями. Для детализации разработки программы по расчёту баллистической таблицы была создана диаграмма классов, описывающую основные моменты создания программы с использованием ООП. (рисунок 22)

             Рисунок 22

             2.Структура программных блоков и реализации программы
             Пользователю предлагается ввести параметры угла вектора скорости к горизонту, начальную скорость, шаг измерения координат снаряда по времени и начальные координаты снаряда. (рисунок 16)
             При нажатии кнопки «Рассчитать» обрабатывается событие «jButton1MouseClicked». В данном событии считываются данные из jTextField1, jTextField2, jTextField3, jTextField4, jTextField5 и присваиваются соответствующим переменным v, l, n, x, y, которые относятся к типу данных double. Так как пользователь мог внести символы, не соответствующие типу double, в данный код интегрирована обработка исключительных ситуаций. Так же проверяются следующие параметры считываемых данных: l<=0, l>=PI, v<=0, n<=0, x<0, y<0. Если хотя бы одно условие выполняется, то срабатывает всплывающее окно JOptionPane.showMessageDialog (null,"Недопустимое начение!","Ошибка",JOptionPane.ERROR_MESSAGE) (рисунок 15)
             Рисунок 15

             Рисунок 16
             Если же все условия оператора разветвления ложны, то создаётся объект класса Class1 objFirst и вызывается конструктор класса, которому задаются считанные с текстовых полей значения.
             Реализация события «jButton1MouseClicked» представлена на блок-схеме (рисунок 17)

             Рисунок 17
             При вызове конструктора класса Class1(double v, double l, double n, double x, double y) начинается обработка заданных пользователем параметров. Задаются переменные с плавающей запятой T, t1, t2, g, H, t, S типа double и целочисленный элемент m типа int. g-характеризует значение свободного падения и ему присваивается приближённое значение 9.8. Далее мы вычисляем ключевые показатели полёта снаряда:
             t1=sin(l)*v/g;
             H=sin(l)*v*t1-g*pow(t1,2)/2;
             t2=sqrt(2*(H+y)/g);
             T=t1+t2;
             Выполняется проверка T<=n посредством оператора ветвления if. Если условие выполняется, то возникает ошибка и выводится пользователю в виде всплывающего окна. (рисунок 15)
             Запускаем цикл условия T>0, в нём программа вычисляет количество шагов по времени для вычисления координат снаряда в каждый такой момент времени. В цикле мы проводим следующие операции:
             T-=n;
             m+=1;
             m-число шагов. Далее мы восстанавливаем значение общего времени полёта снаряда T=t1+t2 и задаём значение аргумента функции расчёта координат снаряда по времени t=0.0;
             Данный блок программы представлен на блок-схеме (рисунок 18)

             Рисунок 18
             Создаём модель таблицы DefaultTableModel model = new DefaultTableModel.
             И массив элементов с плавающей запятой XY с 1-ой строкой и 3-мя столбцами, для вывода строки таблицы значения аргумента момента времени и соответствующих координат снаряда этому времени.
             Для инициализации массива создаём двойной цикл for
             for(int i=0; i<m; i++){
                 for( int j=0; j<3; j++) XY[i][j]=0.0; XY[i][j]=0.0;
             }
             Теперь создаём целочисленные переменные i,j равные 1 и вводим значения колонок таблицы:
             model.addColumn("Время t(c)");
             model.addColumn("X(t)");
             model.addColumn("Y(t)");
             Теперь мы заполняем баллистическую таблицу соответствующими значениями. Для этого создаётся цикл с условием t<T, в котором задаётся значения момента времени и координаты снаряды в этот момент времени. Увеличиваем момент времени на шаг n, который задал пользователь.
             XY[i][j]=t;
                 XY[i][j+1]=cos(l)*v*t+x;
               XY[i][j+2]=abs(sin(l)*t*v-g*pow(t,2)/2+y);
               t+=n;
             В этом же цикле мы выполняем округление значений элементов массива XY до 3-х знаков после запятой посредством round(), где округляемый элемент умножается на 1000, а после округления целится на 1000, тут же выводим значение массива XY в новую строку таблицы
             model.addRow(XY[i]);
             Данный программный блок представлен на блок-схеме. (рисунок 19)


             Рисунок 19
             На финальном этапе расчётов вычисляется расстояние, пройденное по горизонтальной проекции снарядом, и рассчитывается, после чего выводится, последняя строка таблицы с аргументом времени равном всему времени полёта снаряда. Полученные результаты округляются до 3-х знаков после запятой посредством round(), где округляемый элемент умножается на 1000, а после округления целится на 1000. Далее строится таблица jTable1 по заданной модели Model:
             jTable1.setModel(model);
             Округляем до 3-х знаков после запятой ключевые значения баллистического расчёта t1, t2, H, S и присваиваем соответствующие текстовые и числовые значения лейблам, которые ранее были не видны пользователю: jLabel4, jLabel5, jLabel6, jLabel7, jLabel8, jLabel11.
             Данный программный блок представлен на блок-схеме. (рисунок 20)


             Рисунок 20
             После завершения всех вышеперечисленных программных процедур пользователь увидит баллистическую таблицу с координатами снаряда в каждый момент времени от 0с до полного времени полёта с заданным шагом, а также появятся ключевые значения баллистического полёта снаряда, такие так: время полёта вверх по вертикали, время полёта вниз по вертикали, общее время полёта снаряда, максимальная высота подъёма, путь по горизонтальной проекции пройденный снарядом за всё время полёта. (рисунок 21)

             Рисунок 21
             3.Технические требования и характеристики
             Для IDE NET Beans необходимы следующие технические требования ЭВМ, а, следовательно, и для программы по расчёту баллистической траектории.
             Минимальные требования к комплектации оборудования:
             	Microsoft Windows XP Professional SP3:
             	Процессор: Intel Pentium III 800 МГц или эквивалент
             	Память: 512 MБ
             	Дисковое пространство: 750 MБ свободного дискового пространства
             	Microsoft Windows Vista SP1:
             	Процессор: Intel Pentium III 800 МГц или эквивалент
             	Память: 512 MБ
             	Дисковое пространство: 750 MБ свободного дискового пространства
             	Microsoft Windows 7:
             	Процессор: Intel Pentium III 800 МГц или эквивалент
             	Память: 512 MБ
             	Дисковое пространство: 750 MБ свободного дискового пространства
             	Ubuntu 9.04:
             	Процессор: Intel Pentium III 800 МГц или эквивалент
             	Память: 512 MБ
             	Дисковое пространство: 650 MБ свободного дискового пространства
             	ОС Solaris, версия 10 (SPARC):
             	Процессор: UltraSPARC II 450 МГц
             	Память: 512 MБ
             	Дисковое пространство: 650 MБ свободного дискового пространства
             	ОС Solaris, версия 10 (версия для платформы x86/x64):
             	Процессор: AMD Opteron 1200 Series 1,8 ГГц
             	Память: 512 МБ
             	Дисковое пространство: 650 МБ свободного дискового пространства
             	Macintosh OS X 10.5 Intel:
             	Процессор: Dual-Core Intel
             	Память: 512 МБ
             	Дисковое пространство: 650 МБ свободного дискового пространства
             	Macintosh OS X 10.5 PPC:
             	Процессор: PowerPC G4
             	Память: 512 МБ
             	Дисковое пространство: 650 МБ свободного дискового пространства
             Рекомендуемая комплектация оборудования:
             	Microsoft Windows XP Professional SP3:
             	Процессор: Intel Pentium IV 2,6 ГГц или эквивалент
             	Память: 2 ГБ
             	Дисковое пространство: 1 ГБ свободного дискового пространства
             	Microsoft Windows Vista SP1:
             	Процессор: Intel Pentium IV 2,6 ГГц или эквивалент
             	Память: 2 ГБ
             	Дисковое пространство: 1 ГБ свободного дискового пространства
             	Microsoft Windows 7:
             	Процессор: Intel Pentium IV 2,6 ГГц или эквивалент
             	Память: 2 ГБ
             	Дисковое пространство: 1 ГБ свободного дискового пространства
             	Ubuntu 9.04:
             	Процессор: Intel Pentium IV 2,6 ГГц или эквивалент
             	Память: 2 ГБ
             	Дисковое пространство: 850 МБ свободного дискового пространства
             	ОС Solaris, версия 10 (SPARC):
             	Процессор: UltraSPARC IIIi 1 ГГц
             	Память: 2 ГБ
             	Дисковое пространство: 850 МБ свободного дискового пространства
             	ОС Solaris, версия 10 (версия для платформы x86/x64):
             	Процессор: AMD Opteron серии 1200, 2,8 ГГц
             	Память: 2 ГБ
             	Дисковое пВведение
                          # Основные компоненты и используемые технологии
                          Для WF–системы была выбрана следующая общая архитектура (в целом соответствует архитектуре, предлагаемой коалицией WfMC):

                          Компоненты системы:

                          Ядро системы
                          Содержит набор определений бизнес-процессов
                          Содержит набор выполняющихся экземпляров бизнес–процессов
                          Компонент, "назначающий" исполнителей для действий
                          Клиент
                          Список заданий (набор графических форм, содержит очереди поступивших работ, сортировки и фильтры)
                          Проигрыватель форм (отображает формы, разработанные в Среде разработки)
                          Административный интерфейс
                          Показывает состояния процессов, позволяет фильтровать и останавливать процессы
                          Позволяет загружать-выгружать процессы
                          Позволяет заводить-удалять пользователей
                          Позволяет задавать различные права
                          Редактор назначения заместителей
                          Среда разработки
                          Конструктор графических форм
                          Бот станции, содержащие ботов (Боты - приложения специального вида, которые также как и обычные пользователи могут выполнять задания)
                          Подсистема управления правами доступа (авторизация и аутентификация)
                          # Платформа программирования и используемые программные средства
                          В качестве платформы программирования используется J2EE.

                          Используемые программные средства:

                          Сервер приложений - JBOSS (http://www.jboss.org).
                          Среда разработки - любая, например Eclipse от IBM (http://www.eclipse.org).
                          Система контроля версий - git
                          Сборщик приложений – maven.
                          Сервер баз данных – поддерживаются сервера БД:
                          MS SQL Server (http://www.microsoft.com/sql/evaluation/default.mspx)
                          HSQL (http://hsqldb.org)
                          Oracle (http://www.oracle.com)
                          PostgreSQL (http://postgresql.com)
                          Операционная система — поддерживаются следующие ОС:
                          Windows (Server 2000-2008, XP, Vista, 7)
                          ALTLinux
                          Mandriva Linux
                          Fedora
                          Debian/Ubuntu
                          # Описание проектов
                          Название проекта	Обязателен при сборке	Обязателен при работе	Зависимости	Описание
                          wfe-alfresco	нет	нет	runawfe-app	Интеграция с Alfresco
                          wfe-app	да	да	wfe-ear, wfe-cactus-it	Проект для организации сборки maven
                          wfe-appserver	нет	нет	 ?	Не используется
                          wfe-bots	да	да	wfe-service	Подсистема ботов
                          wfe-cactus-it	да	нет	wfe-service	Интеграционные тесты
                          wfe-core	да	да	-	Основные компоненты системы
                          wfe-ear	да	да	wfe-service, wfe-bots, wfe-office, wfe-web	Проект для сборки runawfe.ear
                          wfe-office	да	нет	wfe-core	Обработчики для работы с Word, Excel
                          wfe-service	да	да	wfe-core	Сервисы (EJB + WebServices), представляющие собой публичное API приложения
                          wfe-web	да	да	wfe-bots	Визуальная часть приложения
                          wfe-webservice-client	нет	нет	 ?	Авто-генерации клиентской библиотеки на основе WSDL серверных сервисов. В нем же есть примеры использования веб-служб из Java клиента.
                          # Описание слоев архитектуры системы
                          Каждый компонент состоит из нескольких уровней (слоев).

                          Список слоев:

                          delegate
                          service
                          logic
                          DAO
                          hibernate
                          # Слой Delegate
                          Delegate-классы, реализующие сервисные интерфейсы представляют собой pattern проектирования BusinessDelegate, упрощающий доступ к серверному API системы. Клиентское приложение взаимодействует с системой только через Delegate-классы. Delegate-классы получаются посредством запроса фабрики Delegates, которая в зависимости от конфигурации возвращает нужную реализацию. Классы Delegate являются частью клиентского API.

                          Список основных Delegate-классов:

                          AuthenticationServiceDelegate – содержит методы для аутентификации пользователей в системе (с использованием логина/пароля, Kerberos и т.п.)
                          AuthorizationServiceDelegate — содержит методы для работы с полномочиями пользователей (назначение полномочий, проверка на допустимость операции для пользователя и т.п.)
                          BotServiceDelegate — содержит методы для работы с бот станциями и ботами
                          ExecutorServiceDelegate — содержит методы для работы с исполнителями. Позволяет создавать/удалять/изменять исполнителей а так же включать их в группы
                          ProfileServiceDelegate — содержит методы для работы с профайлам пользователей
                          SubstitutionServiceDelegate — содержит методы для управления правилами замещения
                          SystemServiceDelegate — содержит методы для входа/выхода пользователя в систему
                          DefinitionServiceDelegate — содержит методы для работы с определениями процессов
                          ExecutionServiceDelegate — содержит методы для работы с исполняемыми экземплярами процессов
                          Все существующие в данный момент Delegate-классы реализуют требуемую функциональность при помощи технологии EJB.

                          # Слой Service
                          Слой service – это серверное API доступа к системе. Реализации Delegate интерфейсов обращаются именно к этому слою. Каждый Delegate работает с одним соответствующим классом Service. В настоящее время все разработанные service классы и интерфейсы ориентированы на EJB-технологию, однако в будущем возможны и другие реализации. Реализации классов Service являются Stateless Session Bean EJB, которые декларативно поддерживают транзакционность вызовов и запрашивают соответствующие классы из слоя Logic.

                          Таким образом, классы Delegate – Service - Logic образуют как бы «транспорт» между клиентом и сервером.

                          # Слой Logic
                          Слой Logic – это реализация бизнес логики работы системы. Слой работает с классами слоя DAO для доступа к постоянному хранилищу.

                          # Слой DAO
                          Слой DAO – это интерфейсы и классы, обеспечивающие доступ к данным, находящимся в постоянном хранилище (базе данных). В настоящее время все DAO-классы системы реализованы при помощи ORM-средства Hibernate.

                          # Использование Hibernate
                          Hibernate – ORM (Object/Relational Mapping) средство. Отображает объектную архитектуру на реляционную структуру данных. Допускает настройку (не меняя разработанного кода) на большинство существующих серверов реляционных баз данных.

                          Поддерживает работу с распределенными транзакциями, автоматически создает таблицы для новых классов и т.д. Вся работа с данными внутри системы ведется только через Hibernate.

                          Все компоненты, предоставляющие клиентское API построены с использованием описанных выше слоев. В целях оптимизации в некоторых компонентах применяется кеширование, которое может встречаться на уровне logic или DAO. Основная функциональность по управлению кешами находится в классах CachingLogic, CacheInterceptor и классах соответствующих кешей. Изменения в кешируемых объектах перехватываются и сообщаются посредством CachingLogic всем подписавшимся на изменения классам кешей. Транзакция, изменяющая кеш, считается закрытой по окончанию обработки ejb вызова.

                          # Обновление базы данных
                          см. описание системы патчей.

                          # API
                          Система представляет API для интеграции с другими системами:

                          # Java API
                          Реализация (снизу вверх): БД - Hibernate3 - EJB3

                          Документацию можно смотреть в исходном коде (javadocs в *Service.java).

                          # WebServices API
                          Реализация (снизу вверх): БД - Hibernate3 - JAX-WS

                          Документация: WebServicesDeveloperGuide

                          # Scripting API
                          Реализация (снизу вверх): БД - Hibernate3 - XML Script

                          Документация: AdminScriptGuide

                          # Процесс сборки из исходного кода
                          Исходный код системы доступен в открытом репозитории на github.

                          Сервер можно собирать как средствами maven используя командную строку, так и используя среду Eclipse IDE.

                          В результате сборки будет сформирован runawfe.ear, который теоретически можно запустить на любом сервере приложений. Начиная с версии 4.3.0 введена поддержка JAVA версии 8, и отказ от JAVA 6. В дальнейшем планируется отказ от java7, поэтому рекомендуется использовать сервер приложений wildfly.

                          # Процесс сборки на примере Eclipse IDE
                          # Необходимое программное обеспечение для сборки
                          В отличие от Среды разработки для сборки сервера можно использовать Eclipse IDE любой версии и редакции.

                          установите плагин m2eclipse
                          используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу: http://maven.apache.org/
                          добавьте путь к Apache Maven директории bin в переменную окружения Path
                          # Импорт проектов
                          Импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server.

                          Eclipse srv proj.png

                          # Установка maven артефактов
                          Выполните

                          ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                          ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                          или другим способом установите артефакты в локальный репозиторий

                          # Сборка
                          Заведите конфигурацию запуска на основе maven как показано на рисунке

                          Maven.build.configuration.png

                          Запустите конфигурацию.

                          Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\eclipse-workspace\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"

                          # Сборка из командной строки
                          используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу http://maven.apache.org/
                          добавьте путь к Apache Maven директории bin в переменную окружения Path
                          импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server
                          выполните обновление зависимостей
                          ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                          ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                          откройте командную строку
                          перейдите в директорию ${wfe}/wfe-app/
                          выполните команду для сборки
                          mvn clean package -Dmaven.test.skip=true
                          Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"


                          Для установки артефактов в локальный репозиторий используйте команду

                          mvn clean install -Dmaven.test.skip=true
                          # Использование ear на сервере приложений
                          cкачайте текущую версию RunaWFE в виде файл-архива исполняемых java файлов runawfe-wildfly-java8-*.zip (на базе wildfly, java8)
                          распакуйте архив
                          обновите runawfe.ear на версию полученную в результате сборки
                          # Расширение функциональности
                          # Точки расширения системы
                          Обработчики позволяют исполнить код в процессах (элементы "Обработчик", "Задача сценария") и ботах
                          Форматы переменных определяют тип переменных и правила преобразования значений к текстовому представлению и обратно
                          Организационные функции используются при назначении ролей и в правилах замещения для определения заместителя
                          Критерии замещения используются в подсистеме замещения для определения заместителя при построении списка заданий
                          Валидаторы обеспечивают проверку переменных при выполнении задания (в т.ч. введенные значения форм)
                          Freemarker теги форм генерируют html код для отображения на форме
                          Ajax команды предоставляют доступ к функциональности сервера из JavaScript
                          # Процесс разработки расширений
                          Создайте новый java-проект и подключите необходимые зависимости (wfe-core, wfe-service).

                          Реализуйте в нем требуемые расширения и соберите его в виде jar-файла.

                          Замечание. Использование maven облегчит процесс управления зависимостями.

                          Разместить собранный jar на сервере вы можете:

                          положив его в runawfe.ear!/lib
                          положив его в директорию deploy (только для jboss4)
                          положив его в ${jboss.server.base.dir}/wfe.custom (только для jboss7)
                          положив его в ${jboss.server.base.dir}/${jboss.server.name}/wfe.custom (только для jboss4)
                          # Обработчики
                          Обработчик в процессе – компонент процесса (элементы "Обработчик", "Задача сценария"), использующийся для выполнения каких-либо действий при возникновении определенных событий (проход по определенному переходу в процессе, приход или уход управления из узла и т.п.).

                          Обработчик должен реализовывать интерфейс ru.runa.wfe.extension.ActionHandler. Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов Spring контекста (например с помощью аннотации @Autowired).

                          При написании нового обработчика рекомендуется наследовать его от абстрактного класса ru.runa.wfe.extension.handler.CommonHandler или ru.runa.wfe.extension.handler.CommonParamBasedHandler. В методе setConfiguration обработчик должен запомнить свои параметры (если обработчик их ожидает), а в методе execute происходит непосредственная обработка и выполнение требуемых действий.

                          В случае, если при выполнении обработчика произошла ошибка, произойдет откат транзакции и состояние процесса будет возвращено к заданию, исполнение которого повлекло вызов обработчика. В интерфейсе обработчика для бота ru.runa.wfe.extension.TaskHandler предусмотрен метод onRollback для работы с не-транзакционными ресурсами.

                          Эти обработчики удобно использовать для простых операций (например для отправки оповещений в виде SMS-сообщений если процесс попал в определенное состояние). Но у них есть несколько ограничений. Прежде всего у них нет соответствующего объекта контекста безопасности (security context). Это означает, что в них нельзя выполнять защищенные методы (запуск процессов, выполнение задач, создание пользователей и т.п.) Ошибочным решением в них будет блокирование выполнения процесса (например с Thread::Sleep(...)). Например, если в обработчике отправляется e-mail, а SMTP сервер недоступен, обработчику нельзя "задерживать" свое выполнение.

                          Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                          # Специфика обработчиков для ботов
                          Бот - это сокращение от робот. В системе боты - это особый тип исполнителей. Система не отличает ботов от людей. У каждого бота есть свои права на вход в систему, он периодически просыпается, проверяет свой список задачи и выполняет обнаруженные там задачи.

                          Каждая задача бота обрабатывается при помощи соответствующего обработчика. Чтобы написать новый обработчик нужно реализовать интерфейс ru.runa.wfe.extension.TaskHandler.

                          Обратите внимание, что этот вид обработчиков выполняется в контексте безопасности (security context) пользователя-бота, и здесь может выполнятся любая операция (если у бота есть на это права).

                          Обработчики задач ботов могут блокировать выполнение процесса.

                          Например, обработчик задач, отправляющий e-mail может блокировать выполнение бизнес процесса до тех пор, пока обработчик не удостоверится, что SMTP сервер принял сообщение для последующей доставки.

                          Обработчики задач вызываются периодически, когда боты проверяют свои списки задач.

                          # Специфика обработчика для элемента ветвление
                          Обработчик для Decision является java-классом, реализующим интерфейс ru.runa.wfe.extension.DecisionHandler. Интерфейс содержит один метод decide(ExecutionContext executionContext), который возвращает имя выбранного перехода (одного из выходящих из данного ветвления). Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов контекста спринга (например с помощью аннотации @Autowired).

                          Обработчик принимает ExecutionContext в качестве входящего параметра и должен сделать выбор перехода исходя из значений переменных бизнес процесса и условий, указанных в конфигурации обработчика. Точно также как обработчики действия (action handler) обработчики выбора (decision handlers) не могут использовать защищенные (secured) методы, не могут обрабатывать ошибки и откладывать выбор перехода до лучших времен.

                          По умолчанию используется ru.runa.wfe.extension.decision.GroovyDecisionHandler.

                          # Использование ru.runa.wfe.extension.handler.CommonParamBasedHandler в качестве базового класса
                          Этот класс инкапсулирует в себе парсинг XML конфигурации определенного формата. Его удобно использовать если обработчик имеет фиксированное число параметров. Пример конфигурации:

                          <?xml version="1.0" encoding="UTF-8"?>
                          <config>
                           <input>
                             <param name="typeName" variable="тип отсутствия" />
                             <param name="employee" variable="сотрудник" />
                             <param name="requester" variable="подавший заявку" />
                             <param name="from" variable="дата с" />
                             <param name="to" variable="дата по" />
                             <param name="cause" variable="причина" />
                             <param name="comment" variable="комментарий" />
                             <param name="confirmation" variable="дата подтверждения" />
                             <param name="firmCode" value="111" />
                             <param name="firmPositionCode" variable="код должности" />
                             <param name="firmDepartmentCode" variable="код подразделения" />
                           </input>
                           <output>
                             <param name="uuid" variable="идентификатор объекта" />
                           </output>
                          </config>
                          Использование обработчика Groovy
                          См. соответствующий раздел в руководстве по работе с Groovy.

                          # Как написать функцию над организационной структурой
                          Функции над организационной структурой в системе применяются, например, при инициализации Ролей-Дорожек и в правилах замещения.

                          Класс, соответствующий функции над организационной структурой, должен реализовывать интерфейс ru.runa.wfe.extension.OrgFunction.

                          Интерфейс содержит один метод

                          List<? extends Executor> getExecutors(Object... parameters)
                          Этот метод должен возвращать список исполнителей.

                          В бизнес-процессе обработчик функции над оргструктурой используются при определении Ролей-Дорожек: указывается внутри тега swimlane, в теле тега <assignment>.В качестве параметра class тега <assignment> указывается класс-обработчик для инициализации swimlane: ru.runa.wfe.extension.AssignmentHandler. Внутри тега <assignment> содержится конфигурация для этого класса, которая представляет собой имя класса-наследника интерфейса OrgFunction и список параметров в скобках. В качестве параметра может выступать конкретное значение или имя переменной бизнес процесса в фигурных скобках, перед которым стоит значок $

                          Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                          Если есть планы по использованию функции в подсистеме замещений - её можно зарегистрировать в substitutions.xml.

                          # Как написать критерий замещения
                          Критерии замещения в системе применяются в правилах замещения. Класс, соответствующий критерию замещения, должен наследоваться от ru.runa.wfe.ss.SubstitutionCriteria.

                          Для создания на основе него конечных критериев замещения с конфигурациями - его нужно зарегистрировать в substitution.criterias.xml.

                          Как реализовать класс-формат для переменных бизнес-процесса
                          См. соответствующий раздел в руководстве по работе с переменными.

                          # Как реализовать валидатор переменных
                          Классы, расширяющие абстрактный класс ru.runa.wfe.validation.FieldValidator, в системе применяются для проверки переменных при выполнении задания или старте процесса.

                          Пример:

                          public class OvertimeWorkRequestTimeCheck extends FieldValidator {
                             @Override
                             public void validate() {
                                 Date date = (Date) getFieldValue();
                                 if (date == null) {
                                     return;
                                 }
                                 boolean testMode = getVariableProvider().getValueNotNull(boolean.class, "тестовый режим");
                                 if (testMode) {
                                     return;
                                 }
                                 Calendar calendar = CalendarUtil.dateToCalendar(date);
                                 if (calendar.before(Calendar.getInstance())) {
                                     addError("Заявка не может быть оформлена задним числом");
                                     return;
                                 }
                                 CalendarUtil.setTimeFromCalendar(calendar, DemoProperties.getOvertimeWorkRequestMaximumStartTime());
                                 Utils.adjustCalendarForHolidaysInOvertimwWork(calendar);
                                 if (calendar.before(Calendar.getInstance())) {
                                     addError("Заявка на этот день не может быть подана, время подачи истекло " + CalendarUtil.formatDateTime(calendar));
                                 }
                             }
                          }

                          Связь между Средой разработки и сервером осуществляется по имени валидатора, регистрация требуется на стороне сервера в файле validators.xml, а в среде разработки - в plugin.xml.

                          # Как реализовать FreeMarker тег для формы
                          FreemarkerForms#Components

                          # Как реализовать Ajax команду
                          Классы, расширяющие абстрактный класс ru.runa.wfe.commons.web.JsonAjaxCommand, (или реализующие ru.runa.wfe.commons.web.AjaxCommand) в системе применяются для доступа к функциональности сервера из JavaScript, например при отображении форм задания.

                          Регистрация команды происходит любым из двух способов:

                          в файле ajax.commands.xml, ей присваивается определенное имя
                          в контексте приложения, именем является id spring-бина
                          Затем по этому имени её можно выполнить используя JavaScript.

                          Пример команды

                          public class GetOrganizationNamesCommand extends JsonAjaxCommand {
                             @Autowired
                             private OrganizationDAO organizationDAO;
                             @Override
                             protected JSONAware execute(User user, HttpServletRequest request) throws Exception {
                                 String term = request.getParameter("term");
                                 if (term == null) {
                                     term = "";
                                 }
                                 List<Organization> organizations = organizationDAO.getAll();
                                 JSONArray array = new JSONArray();
                                 for (Organization organization : organizations) {
                                     if (organization.getName().startsWith(term)) {
                                         array.add(organization.getName());
                                     }
                                 }
                                 return array;
                             }
                          }
                          Регистрация в wfe.custom.ajax.commands.xml

                          <?xml version="1.0" encoding="UTF-8" ?>
                          <configuration xmlns="http://runa.ru/xml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://runa.ru/xml">
                           <command name="getOrganizationNames" class="ru.runa.rkdemo.web.ajax.GetOrganizationNamesCommand" />
                          </configuration>
                          Её использование со скрипта формы (autocomplete input)

                          $(document).ready(function() {
                           $('#editLinkedLists').on("onRowAdded", function(event, rowIndex) {
                            $("input[name='названия организаций["+rowIndex+"]']").autocomplete( {
                             delay: 300,
                             minLength: 0,
                             source: "/wfe/ajaxcmd?command=getOrganizationNames"
                            });
                            $("input[name='названия организаций["+rowIndex+"]']").focus(function() {
                             $(this).autocomplete("search", $(this).val());
                            });
                           });
                          });Введение
                             # Основные компоненты и используемые технологии
                             Для WF–системы была выбрана следующая общая архитектура (в целом соответствует архитектуре, предлагаемой коалицией WfMC):

                             Компоненты системы:

                             Ядро системы
                             Содержит набор определений бизнес-процессов
                             Содержит набор выполняющихся экземпляров бизнес–процессов
                             Компонент, "назначающий" исполнителей для действий
                             Клиент
                             Список заданий (набор графических форм, содержит очереди поступивших работ, сортировки и фильтры)
                             Проигрыватель форм (отображает формы, разработанные в Среде разработки)
                             Административный интерфейс
                             Показывает состояния процессов, позволяет фильтровать и останавливать процессы
                             Позволяет загружать-выгружать процессы
                             Позволяет заводить-удалять пользователей
                             Позволяет задавать различные права
                             Редактор назначения заместителей
                             Среда разработки
                             Конструктор графических форм
                             Бот станции, содержащие ботов (Боты - приложения специального вида, которые также как и обычные пользователи могут выполнять задания)
                             Подсистема управления правами доступа (авторизация и аутентификация)
                             # Платформа программирования и используемые программные средства
                             В качестве платформы программирования используется J2EE.

                             Используемые программные средства:

                             Сервер приложений - JBOSS (http://www.jboss.org).
                             Среда разработки - любая, например Eclipse от IBM (http://www.eclipse.org).
                             Система контроля версий - git
                             Сборщик приложений – maven.
                             Сервер баз данных – поддерживаются сервера БД:
                             MS SQL Server (http://www.microsoft.com/sql/evaluation/default.mspx)
                             HSQL (http://hsqldb.org)
                             Oracle (http://www.oracle.com)
                             PostgreSQL (http://postgresql.com)
                             Операционная система — поддерживаются следующие ОС:
                             Windows (Server 2000-2008, XP, Vista, 7)
                             ALTLinux
                             Mandriva Linux
                             Fedora
                             Debian/Ubuntu
                             # Описание проектов
                             Название проекта	Обязателен при сборке	Обязателен при работе	Зависимости	Описание
                             wfe-alfresco	нет	нет	runawfe-app	Интеграция с Alfresco
                             wfe-app	да	да	wfe-ear, wfe-cactus-it	Проект для организации сборки maven
                             wfe-appserver	нет	нет	 ?	Не используется
                             wfe-bots	да	да	wfe-service	Подсистема ботов
                             wfe-cactus-it	да	нет	wfe-service	Интеграционные тесты
                             wfe-core	да	да	-	Основные компоненты системы
                             wfe-ear	да	да	wfe-service, wfe-bots, wfe-office, wfe-web	Проект для сборки runawfe.ear
                             wfe-office	да	нет	wfe-core	Обработчики для работы с Word, Excel
                             wfe-service	да	да	wfe-core	Сервисы (EJB + WebServices), представляющие собой публичное API приложения
                             wfe-web	да	да	wfe-bots	Визуальная часть приложения
                             wfe-webservice-client	нет	нет	 ?	Авто-генерации клиентской библиотеки на основе WSDL серверных сервисов. В нем же есть примеры использования веб-служб из Java клиента.
                             # Описание слоев архитектуры системы
                             Каждый компонент состоит из нескольких уровней (слоев).

                             Список слоев:

                             delegate
                             service
                             logic
                             DAO
                             hibernate
                             # Слой Delegate
                             Delegate-классы, реализующие сервисные интерфейсы представляют собой pattern проектирования BusinessDelegate, упрощающий доступ к серверному API системы. Клиентское приложение взаимодействует с системой только через Delegate-классы. Delegate-классы получаются посредством запроса фабрики Delegates, которая в зависимости от конфигурации возвращает нужную реализацию. Классы Delegate являются частью клиентского API.

                             Список основных Delegate-классов:

                             AuthenticationServiceDelegate – содержит методы для аутентификации пользователей в системе (с использованием логина/пароля, Kerberos и т.п.)
                             AuthorizationServiceDelegate — содержит методы для работы с полномочиями пользователей (назначение полномочий, проверка на допустимость операции для пользователя и т.п.)
                             BotServiceDelegate — содержит методы для работы с бот станциями и ботами
                             ExecutorServiceDelegate — содержит методы для работы с исполнителями. Позволяет создавать/удалять/изменять исполнителей а так же включать их в группы
                             ProfileServiceDelegate — содержит методы для работы с профайлам пользователей
                             SubstitutionServiceDelegate — содержит методы для управления правилами замещения
                             SystemServiceDelegate — содержит методы для входа/выхода пользователя в систему
                             DefinitionServiceDelegate — содержит методы для работы с определениями процессов
                             ExecutionServiceDelegate — содержит методы для работы с исполняемыми экземплярами процессов
                             Все существующие в данный момент Delegate-классы реализуют требуемую функциональность при помощи технологии EJB.

                             # Слой Service
                             Слой service – это серверное API доступа к системе. Реализации Delegate интерфейсов обращаются именно к этому слою. Каждый Delegate работает с одним соответствующим классом Service. В настоящее время все разработанные service классы и интерфейсы ориентированы на EJB-технологию, однако в будущем возможны и другие реализации. Реализации классов Service являются Stateless Session Bean EJB, которые декларативно поддерживают транзакционность вызовов и запрашивают соответствующие классы из слоя Logic.

                             Таким образом, классы Delegate – Service - Logic образуют как бы «транспорт» между клиентом и сервером.

                             # Слой Logic
                             Слой Logic – это реализация бизнес логики работы системы. Слой работает с классами слоя DAO для доступа к постоянному хранилищу.

                             # Слой DAO
                             Слой DAO – это интерфейсы и классы, обеспечивающие доступ к данным, находящимся в постоянном хранилище (базе данных). В настоящее время все DAO-классы системы реализованы при помощи ORM-средства Hibernate.

                             # Использование Hibernate
                             Hibernate – ORM (Object/Relational Mapping) средство. Отображает объектную архитектуру на реляционную структуру данных. Допускает настройку (не меняя разработанного кода) на большинство существующих серверов реляционных баз данных.

                             Поддерживает работу с распределенными транзакциями, автоматически создает таблицы для новых классов и т.д. Вся работа с данными внутри системы ведется только через Hibernate.

                             Все компоненты, предоставляющие клиентское API построены с использованием описанных выше слоев. В целях оптимизации в некоторых компонентах применяется кеширование, которое может встречаться на уровне logic или DAO. Основная функциональность по управлению кешами находится в классах CachingLogic, CacheInterceptor и классах соответствующих кешей. Изменения в кешируемых объектах перехватываются и сообщаются посредством CachingLogic всем подписавшимся на изменения классам кешей. Транзакция, изменяющая кеш, считается закрытой по окончанию обработки ejb вызова.

                             # Обновление базы данных
                             см. описание системы патчей.

                             # API
                             Система представляет API для интеграции с другими системами:

                             # Java API
                             Реализация (снизу вверх): БД - Hibernate3 - EJB3

                             Документацию можно смотреть в исходном коде (javadocs в *Service.java).

                             # WebServices API
                             Реализация (снизу вверх): БД - Hibernate3 - JAX-WS

                             Документация: WebServicesDeveloperGuide

                             # Scripting API
                             Реализация (снизу вверх): БД - Hibernate3 - XML Script

                             Документация: AdminScriptGuide

                             # Процесс сборки из исходного кода
                             Исходный код системы доступен в открытом репозитории на github.

                             Сервер можно собирать как средствами maven используя командную строку, так и используя среду Eclipse IDE.

                             В результате сборки будет сформирован runawfe.ear, который теоретически можно запустить на любом сервере приложений. Начиная с версии 4.3.0 введена поддержка JAVA версии 8, и отказ от JAVA 6. В дальнейшем планируется отказ от java7, поэтому рекомендуется использовать сервер приложений wildfly.

                             # Процесс сборки на примере Eclipse IDE
                             # Необходимое программное обеспечение для сборки
                             В отличие от Среды разработки для сборки сервера можно использовать Eclipse IDE любой версии и редакции.

                             установите плагин m2eclipse
                             используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу: http://maven.apache.org/
                             добавьте путь к Apache Maven директории bin в переменную окружения Path
                             # Импорт проектов
                             Импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server.

                             Eclipse srv proj.png

                             # Установка maven артефактов
                             Выполните

                             ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                             ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                             или другим способом установите артефакты в локальный репозиторий

                             # Сборка
                             Заведите конфигурацию запуска на основе maven как показано на рисунке

                             Maven.build.configuration.png

                             Запустите конфигурацию.

                             Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\eclipse-workspace\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"

                             # Сборка из командной строки
                             используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу http://maven.apache.org/
                             добавьте путь к Apache Maven директории bin в переменную окружения Path
                             импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server
                             выполните обновление зависимостей
                             ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                             ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                             откройте командную строку
                             перейдите в директорию ${wfe}/wfe-app/
                             выполните команду для сборки
                             mvn clean package -Dmaven.test.skip=true
                             Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"


                             Для установки артефактов в локальный репозиторий используйте команду

                             mvn clean install -Dmaven.test.skip=true
                             # Использование ear на сервере приложений
                             cкачайте текущую версию RunaWFE в виде файл-архива исполняемых java файлов runawfe-wildfly-java8-*.zip (на базе wildfly, java8)
                             распакуйте архив
                             обновите runawfe.ear на версию полученную в результате сборки
                             # Расширение функциональности
                             # Точки расширения системы
                             Обработчики позволяют исполнить код в процессах (элементы "Обработчик", "Задача сценария") и ботах
                             Форматы переменных определяют тип переменных и правила преобразования значений к текстовому представлению и обратно
                             Организационные функции используются при назначении ролей и в правилах замещения для определения заместителя
                             Критерии замещения используются в подсистеме замещения для определения заместителя при построении списка заданий
                             Валидаторы обеспечивают проверку переменных при выполнении задания (в т.ч. введенные значения форм)
                             Freemarker теги форм генерируют html код для отображения на форме
                             Ajax команды предоставляют доступ к функциональности сервера из JavaScript
                             # Процесс разработки расширений
                             Создайте новый java-проект и подключите необходимые зависимости (wfe-core, wfe-service).

                             Реализуйте в нем требуемые расширения и соберите его в виде jar-файла.

                             Замечание. Использование maven облегчит процесс управления зависимостями.

                             Разместить собранный jar на сервере вы можете:

                             положив его в runawfe.ear!/lib
                             положив его в директорию deploy (только для jboss4)
                             положив его в ${jboss.server.base.dir}/wfe.custom (только для jboss7)
                             положив его в ${jboss.server.base.dir}/${jboss.server.name}/wfe.custom (только для jboss4)
                             # Обработчики
                             Обработчик в процессе – компонент процесса (элементы "Обработчик", "Задача сценария"), использующийся для выполнения каких-либо действий при возникновении определенных событий (проход по определенному переходу в процессе, приход или уход управления из узла и т.п.).

                             Обработчик должен реализовывать интерфейс ru.runa.wfe.extension.ActionHandler. Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов Spring контекста (например с помощью аннотации @Autowired).

                             При написании нового обработчика рекомендуется наследовать его от абстрактного класса ru.runa.wfe.extension.handler.CommonHandler или ru.runa.wfe.extension.handler.CommonParamBasedHandler. В методе setConfiguration обработчик должен запомнить свои параметры (если обработчик их ожидает), а в методе execute происходит непосредственная обработка и выполнение требуемых действий.

                             В случае, если при выполнении обработчика произошла ошибка, произойдет откат транзакции и состояние процесса будет возвращено к заданию, исполнение которого повлекло вызов обработчика. В интерфейсе обработчика для бота ru.runa.wfe.extension.TaskHandler предусмотрен метод onRollback для работы с не-транзакционными ресурсами.

                             Эти обработчики удобно использовать для простых операций (например для отправки оповещений в виде SMS-сообщений если процесс попал в определенное состояние). Но у них есть несколько ограничений. Прежде всего у них нет соответствующего объекта контекста безопасности (security context). Это означает, что в них нельзя выполнять защищенные методы (запуск процессов, выполнение задач, создание пользователей и т.п.) Ошибочным решением в них будет блокирование выполнения процесса (например с Thread::Sleep(...)). Например, если в обработчике отправляется e-mail, а SMTP сервер недоступен, обработчику нельзя "задерживать" свое выполнение.

                             Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                             # Специфика обработчиков для ботов
                             Бот - это сокращение от робот. В системе боты - это особый тип исполнителей. Система не отличает ботов от людей. У каждого бота есть свои права на вход в систему, он периодически просыпается, проверяет свой список задачи и выполняет обнаруженные там задачи.

                             Каждая задача бота обрабатывается при помощи соответствующего обработчика. Чтобы написать новый обработчик нужно реализовать интерфейс ru.runa.wfe.extension.TaskHandler.

                             Обратите внимание, что этот вид обработчиков выполняется в контексте безопасности (security context) пользователя-бота, и здесь может выполнятся любая операция (если у бота есть на это права).

                             Обработчики задач ботов могут блокировать выполнение процесса.

                             Например, обработчик задач, отправляющий e-mail может блокировать выполнение бизнес процесса до тех пор, пока обработчик не удостоверится, что SMTP сервер принял сообщение для последующей доставки.

                             Обработчики задач вызываются периодически, когда боты проверяют свои списки задач.

                             # Специфика обработчика для элемента ветвление
                             Обработчик для Decision является java-классом, реализующим интерфейс ru.runa.wfe.extension.DecisionHandler. Интерфейс содержит один метод decide(ExecutionContext executionContext), который возвращает имя выбранного перехода (одного из выходящих из данного ветвления). Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов контекста спринга (например с помощью аннотации @Autowired).

                             Обработчик принимает ExecutionContext в качестве входящего параметра и должен сделать выбор перехода исходя из значений переменных бизнес процесса и условий, указанных в конфигурации обработчика. Точно также как обработчики действия (action handler) обработчики выбора (decision handlers) не могут использовать защищенные (secured) методы, не могут обрабатывать ошибки и откладывать выбор перехода до лучших времен.

                             По умолчанию используется ru.runa.wfe.extension.decision.GroovyDecisionHandler.

                             # Использование ru.runa.wfe.extension.handler.CommonParamBasedHandler в качестве базового класса
                             Этот класс инкапсулирует в себе парсинг XML конфигурации определенного формата. Его удобно использовать если обработчик имеет фиксированное число параметров. Пример конфигурации:

                             <?xml version="1.0" encoding="UTF-8"?>
                             <config>
                              <input>
                                <param name="typeName" variable="тип отсутствия" />
                                <param name="employee" variable="сотрудник" />
                                <param name="requester" variable="подавший заявку" />
                                <param name="from" variable="дата с" />
                                <param name="to" variable="дата по" />
                                <param name="cause" variable="причина" />
                                <param name="comment" variable="комментарий" />
                                <param name="confirmation" variable="дата подтверждения" />
                                <param name="firmCode" value="111" />
                                <param name="firmPositionCode" variable="код должности" />
                                <param name="firmDepartmentCode" variable="код подразделения" />
                              </input>
                              <output>
                                <param name="uuid" variable="идентификатор объекта" />
                              </output>
                             </config>
                             Использование обработчика Groovy
                             См. соответствующий раздел в руководстве по работе с Groovy.

                             # Как написать функцию над организационной структурой
                             Функции над организационной структурой в системе применяются, например, при инициализации Ролей-Дорожек и в правилах замещения.

                             Класс, соответствующий функции над организационной структурой, должен реализовывать интерфейс ru.runa.wfe.extension.OrgFunction.

                             Интерфейс содержит один метод

                             List<? extends Executor> getExecutors(Object... parameters)
                             Этот метод должен возвращать список исполнителей.

                             В бизнес-процессе обработчик функции над оргструктурой используются при определении Ролей-Дорожек: указывается внутри тега swimlane, в теле тега <assignment>.В качестве параметра class тега <assignment> указывается класс-обработчик для инициализации swimlane: ru.runa.wfe.extension.AssignmentHandler. Внутри тега <assignment> содержится конфигурация для этого класса, которая представляет собой имя класса-наследника интерфейса OrgFunction и список параметров в скобках. В качестве параметра может выступать конкретное значение или имя переменной бизнес процесса в фигурных скобках, перед которым стоит значок $

                             Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                             Если есть планы по использованию функции в подсистеме замещений - её можно зарегистрировать в substitutions.xml.

                             # Как написать критерий замещения
                             Критерии замещения в системе применяются в правилах замещения. Класс, соответствующий критерию замещения, должен наследоваться от ru.runa.wfe.ss.SubstitutionCriteria.

                             Для создания на основе него конечных критериев замещения с конфигурациями - его нужно зарегистрировать в substitution.criterias.xml.

                             Как реализовать класс-формат для переменных бизнес-процесса
                             См. соответствующий раздел в руководстве по работе с переменными.

                             # Как реализовать валидатор переменных
                             Классы, расширяющие абстрактный класс ru.runa.wfe.validation.FieldValidator, в системе применяются для проверки переменных при выполнении задания или старте процесса.

                             Пример:

                             public class OvertimeWorkRequestTimeCheck extends FieldValidator {
                                @Override
                                public void validate() {
                                    Date date = (Date) getFieldValue();
                                    if (date == null) {
                                        return;
                                    }
                                    boolean testMode = getVariableProvider().getValueNotNull(boolean.class, "тестовый режим");
                                    if (testMode) {
                                        return;
                                    }
                                    Calendar calendar = CalendarUtil.dateToCalendar(date);
                                    if (calendar.before(Calendar.getInstance())) {
                                        addError("Заявка не может быть оформлена задним числом");
                                        return;
                                    }
                                    CalendarUtil.setTimeFromCalendar(calendar, DemoProperties.getOvertimeWorkRequestMaximumStartTime());
                                    Utils.adjustCalendarForHolidaysInOvertimwWork(calendar);
                                    if (calendar.before(Calendar.getInstance())) {
                                        addError("Заявка на этот день не может быть подана, время подачи истекло " + CalendarUtil.formatDateTime(calendar));
                                    }
                                }
                             }

                             Связь между Средой разработки и сервером осуществляется по имени валидатора, регистрация требуется на стороне сервера в файле validators.xml, а в среде разработки - в plugin.xml.

                             # Как реализовать FreeMarker тег для формы
                             FreemarkerForms#Components

                             # Как реализовать Ajax команду
                             Классы, расширяющие абстрактный класс ru.runa.wfe.commons.web.JsonAjaxCommand, (или реализующие ru.runa.wfe.commons.web.AjaxCommand) в системе применяются для доступа к функциональности сервера из JavaScript, например при отображении форм задания.

                             Регистрация команды происходит любым из двух способов:

                             в файле ajax.commands.xml, ей присваивается определенное имя
                             в контексте приложения, именем является id spring-бина
                             Затем по этому имени её можно выполнить используя JavaScript.

                             Пример команды

                             public class GetOrganizationNamesCommand extends JsonAjaxCommand {
                                @Autowired
                                private OrganizationDAO organizationDAO;
                                @Override
                                protected JSONAware execute(User user, HttpServletRequest request) throws Exception {
                                    String term = request.getParameter("term");
                                    if (term == null) {
                                        term = "";
                                    }
                                    List<Organization> organizations = organizationDAO.getAll();
                                    JSONArray array = new JSONArray();
                                    for (Organization organization : organizations) {
                                        if (organization.getName().startsWith(term)) {
                                            array.add(organization.getName());
                                        }
                                    }
                                    return array;
                                }
                             }
                             Регистрация в wfe.custom.ajax.commands.xml

                             <?xml version="1.0" encoding="UTF-8" ?>
                             <configuration xmlns="http://runa.ru/xml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://runa.ru/xml">
                              <command name="getOrganizationNames" class="ru.runa.rkdemo.web.ajax.GetOrganizationNamesCommand" />
                             </configuration>
                             Её использование со скрипта формы (autocomplete input)

                             $(document).ready(function() {
                              $('#editLinkedLists').on("onRowAdded", function(event, rowIndex) {
                               $("input[name='названия организаций["+rowIndex+"]']").autocomplete( {
                                delay: 300,
                                minLength: 0,
                                source: "/wfe/ajaxcmd?command=getOrganizationNames"
                               });
                               $("input[name='названия организаций["+rowIndex+"]']").focus(function() {
                                $(this).autocomplete("search", $(this).val());
                               });
                              });
                             });Введение
                                # Основные компоненты и используемые технологии
                                Для WF–системы была выбрана следующая общая архитектура (в целом соответствует архитектуре, предлагаемой коалицией WfMC):

                                Компоненты системы:

                                Ядро системы
                                Содержит набор определений бизнес-процессов
                                Содержит набор выполняющихся экземпляров бизнес–процессов
                                Компонент, "назначающий" исполнителей для действий
                                Клиент
                                Список заданий (набор графических форм, содержит очереди поступивших работ, сортировки и фильтры)
                                Проигрыватель форм (отображает формы, разработанные в Среде разработки)
                                Административный интерфейс
                                Показывает состояния процессов, позволяет фильтровать и останавливать процессы
                                Позволяет загружать-выгружать процессы
                                Позволяет заводить-удалять пользователей
                                Позволяет задавать различные права
                                Редактор назначения заместителей
                                Среда разработки
                                Конструктор графических форм
                                Бот станции, содержащие ботов (Боты - приложения специального вида, которые также как и обычные пользователи могут выполнять задания)
                                Подсистема управления правами доступа (авторизация и аутентификация)
                                # Платформа программирования и используемые программные средства
                                В качестве платформы программирования используется J2EE.

                                Используемые программные средства:

                                Сервер приложений - JBOSS (http://www.jboss.org).
                                Среда разработки - любая, например Eclipse от IBM (http://www.eclipse.org).
                                Система контроля версий - git
                                Сборщик приложений – maven.
                                Сервер баз данных – поддерживаются сервера БД:
                                MS SQL Server (http://www.microsoft.com/sql/evaluation/default.mspx)
                                HSQL (http://hsqldb.org)
                                Oracle (http://www.oracle.com)
                                PostgreSQL (http://postgresql.com)
                                Операционная система — поддерживаются следующие ОС:
                                Windows (Server 2000-2008, XP, Vista, 7)
                                ALTLinux
                                Mandriva Linux
                                Fedora
                                Debian/Ubuntu
                                # Описание проектов
                                Название проекта	Обязателен при сборке	Обязателен при работе	Зависимости	Описание
                                wfe-alfresco	нет	нет	runawfe-app	Интеграция с Alfresco
                                wfe-app	да	да	wfe-ear, wfe-cactus-it	Проект для организации сборки maven
                                wfe-appserver	нет	нет	 ?	Не используется
                                wfe-bots	да	да	wfe-service	Подсистема ботов
                                wfe-cactus-it	да	нет	wfe-service	Интеграционные тесты
                                wfe-core	да	да	-	Основные компоненты системы
                                wfe-ear	да	да	wfe-service, wfe-bots, wfe-office, wfe-web	Проект для сборки runawfe.ear
                                wfe-office	да	нет	wfe-core	Обработчики для работы с Word, Excel
                                wfe-service	да	да	wfe-core	Сервисы (EJB + WebServices), представляющие собой публичное API приложения
                                wfe-web	да	да	wfe-bots	Визуальная часть приложения
                                wfe-webservice-client	нет	нет	 ?	Авто-генерации клиентской библиотеки на основе WSDL серверных сервисов. В нем же есть примеры использования веб-служб из Java клиента.
                                # Описание слоев архитектуры системы
                                Каждый компонент состоит из нескольких уровней (слоев).

                                Список слоев:

                                delegate
                                service
                                logic
                                DAO
                                hibernate
                                # Слой Delegate
                                Delegate-классы, реализующие сервисные интерфейсы представляют собой pattern проектирования BusinessDelegate, упрощающий доступ к серверному API системы. Клиентское приложение взаимодействует с системой только через Delegate-классы. Delegate-классы получаются посредством запроса фабрики Delegates, которая в зависимости от конфигурации возвращает нужную реализацию. Классы Delegate являются частью клиентского API.

                                Список основных Delegate-классов:

                                AuthenticationServiceDelegate – содержит методы для аутентификации пользователей в системе (с использованием логина/пароля, Kerberos и т.п.)
                                AuthorizationServiceDelegate — содержит методы для работы с полномочиями пользователей (назначение полномочий, проверка на допустимость операции для пользователя и т.п.)
                                BotServiceDelegate — содержит методы для работы с бот станциями и ботами
                                ExecutorServiceDelegate — содержит методы для работы с исполнителями. Позволяет создавать/удалять/изменять исполнителей а так же включать их в группы
                                ProfileServiceDelegate — содержит методы для работы с профайлам пользователей
                                SubstitutionServiceDelegate — содержит методы для управления правилами замещения
                                SystemServiceDelegate — содержит методы для входа/выхода пользователя в систему
                                DefinitionServiceDelegate — содержит методы для работы с определениями процессов
                                ExecutionServiceDelegate — содержит методы для работы с исполняемыми экземплярами процессов
                                Все существующие в данный момент Delegate-классы реализуют требуемую функциональность при помощи технологии EJB.

                                # Слой Service
                                Слой service – это серверное API доступа к системе. Реализации Delegate интерфейсов обращаются именно к этому слою. Каждый Delegate работает с одним соответствующим классом Service. В настоящее время все разработанные service классы и интерфейсы ориентированы на EJB-технологию, однако в будущем возможны и другие реализации. Реализации классов Service являются Stateless Session Bean EJB, которые декларативно поддерживают транзакционность вызовов и запрашивают соответствующие классы из слоя Logic.

                                Таким образом, классы Delegate – Service - Logic образуют как бы «транспорт» между клиентом и сервером.

                                # Слой Logic
                                Слой Logic – это реализация бизнес логики работы системы. Слой работает с классами слоя DAO для доступа к постоянному хранилищу.

                                # Слой DAO
                                Слой DAO – это интерфейсы и классы, обеспечивающие доступ к данным, находящимся в постоянном хранилище (базе данных). В настоящее время все DAO-классы системы реализованы при помощи ORM-средства Hibernate.

                                # Использование Hibernate
                                Hibernate – ORM (Object/Relational Mapping) средство. Отображает объектную архитектуру на реляционную структуру данных. Допускает настройку (не меняя разработанного кода) на большинство существующих серверов реляционных баз данных.

                                Поддерживает работу с распределенными транзакциями, автоматически создает таблицы для новых классов и т.д. Вся работа с данными внутри системы ведется только через Hibernate.

                                Все компоненты, предоставляющие клиентское API построены с использованием описанных выше слоев. В целях оптимизации в некоторых компонентах применяется кеширование, которое может встречаться на уровне logic или DAO. Основная функциональность по управлению кешами находится в классах CachingLogic, CacheInterceptor и классах соответствующих кешей. Изменения в кешируемых объектах перехватываются и сообщаются посредством CachingLogic всем подписавшимся на изменения классам кешей. Транзакция, изменяющая кеш, считается закрытой по окончанию обработки ejb вызова.

                                # Обновление базы данных
                                см. описание системы патчей.

                                # API
                                Система представляет API для интеграции с другими системами:

                                # Java API
                                Реализация (снизу вверх): БД - Hibernate3 - EJB3

                                Документацию можно смотреть в исходном коде (javadocs в *Service.java).

                                # WebServices API
                                Реализация (снизу вверх): БД - Hibernate3 - JAX-WS

                                Документация: WebServicesDeveloperGuide

                                # Scripting API
                                Реализация (снизу вверх): БД - Hibernate3 - XML Script

                                Документация: AdminScriptGuide

                                # Процесс сборки из исходного кода
                                Исходный код системы доступен в открытом репозитории на github.

                                Сервер можно собирать как средствами maven используя командную строку, так и используя среду Eclipse IDE.

                                В результате сборки будет сформирован runawfe.ear, который теоретически можно запустить на любом сервере приложений. Начиная с версии 4.3.0 введена поддержка JAVA версии 8, и отказ от JAVA 6. В дальнейшем планируется отказ от java7, поэтому рекомендуется использовать сервер приложений wildfly.

                                # Процесс сборки на примере Eclipse IDE
                                # Необходимое программное обеспечение для сборки
                                В отличие от Среды разработки для сборки сервера можно использовать Eclipse IDE любой версии и редакции.

                                установите плагин m2eclipse
                                используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу: http://maven.apache.org/
                                добавьте путь к Apache Maven директории bin в переменную окружения Path
                                # Импорт проектов
                                Импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server.

                                Eclipse srv proj.png

                                # Установка maven артефактов
                                Выполните

                                ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                                ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                                или другим способом установите артефакты в локальный репозиторий

                                # Сборка
                                Заведите конфигурацию запуска на основе maven как показано на рисунке

                                Maven.build.configuration.png

                                Запустите конфигурацию.

                                Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\eclipse-workspace\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"

                                # Сборка из командной строки
                                используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу http://maven.apache.org/
                                добавьте путь к Apache Maven директории bin в переменную окружения Path
                                импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server
                                выполните обновление зависимостей
                                ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                                ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                                откройте командную строку
                                перейдите в директорию ${wfe}/wfe-app/
                                выполните команду для сборки
                                mvn clean package -Dmaven.test.skip=true
                                Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"


                                Для установки артефактов в локальный репозиторий используйте команду

                                mvn clean install -Dmaven.test.skip=true
                                # Использование ear на сервере приложений
                                cкачайте текущую версию RunaWFE в виде файл-архива исполняемых java файлов runawfe-wildfly-java8-*.zip (на базе wildfly, java8)
                                распакуйте архив
                                обновите runawfe.ear на версию полученную в результате сборки
                                # Расширение функциональности
                                # Точки расширения системы
                                Обработчики позволяют исполнить код в процессах (элементы "Обработчик", "Задача сценария") и ботах
                                Форматы переменных определяют тип переменных и правила преобразования значений к текстовому представлению и обратно
                                Организационные функции используются при назначении ролей и в правилах замещения для определения заместителя
                                Критерии замещения используются в подсистеме замещения для определения заместителя при построении списка заданий
                                Валидаторы обеспечивают проверку переменных при выполнении задания (в т.ч. введенные значения форм)
                                Freemarker теги форм генерируют html код для отображения на форме
                                Ajax команды предоставляют доступ к функциональности сервера из JavaScript
                                # Процесс разработки расширений
                                Создайте новый java-проект и подключите необходимые зависимости (wfe-core, wfe-service).

                                Реализуйте в нем требуемые расширения и соберите его в виде jar-файла.

                                Замечание. Использование maven облегчит процесс управления зависимостями.

                                Разместить собранный jar на сервере вы можете:

                                положив его в runawfe.ear!/lib
                                положив его в директорию deploy (только для jboss4)
                                положив его в ${jboss.server.base.dir}/wfe.custom (только для jboss7)
                                положив его в ${jboss.server.base.dir}/${jboss.server.name}/wfe.custom (только для jboss4)
                                # Обработчики
                                Обработчик в процессе – компонент процесса (элементы "Обработчик", "Задача сценария"), использующийся для выполнения каких-либо действий при возникновении определенных событий (проход по определенному переходу в процессе, приход или уход управления из узла и т.п.).

                                Обработчик должен реализовывать интерфейс ru.runa.wfe.extension.ActionHandler. Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов Spring контекста (например с помощью аннотации @Autowired).

                                При написании нового обработчика рекомендуется наследовать его от абстрактного класса ru.runa.wfe.extension.handler.CommonHandler или ru.runa.wfe.extension.handler.CommonParamBasedHandler. В методе setConfiguration обработчик должен запомнить свои параметры (если обработчик их ожидает), а в методе execute происходит непосредственная обработка и выполнение требуемых действий.

                                В случае, если при выполнении обработчика произошла ошибка, произойдет откат транзакции и состояние процесса будет возвращено к заданию, исполнение которого повлекло вызов обработчика. В интерфейсе обработчика для бота ru.runa.wfe.extension.TaskHandler предусмотрен метод onRollback для работы с не-транзакционными ресурсами.

                                Эти обработчики удобно использовать для простых операций (например для отправки оповещений в виде SMS-сообщений если процесс попал в определенное состояние). Но у них есть несколько ограничений. Прежде всего у них нет соответствующего объекта контекста безопасности (security context). Это означает, что в них нельзя выполнять защищенные методы (запуск процессов, выполнение задач, создание пользователей и т.п.) Ошибочным решением в них будет блокирование выполнения процесса (например с Thread::Sleep(...)). Например, если в обработчике отправляется e-mail, а SMTP сервер недоступен, обработчику нельзя "задерживать" свое выполнение.

                                Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                                # Специфика обработчиков для ботов
                                Бот - это сокращение от робот. В системе боты - это особый тип исполнителей. Система не отличает ботов от людей. У каждого бота есть свои права на вход в систему, он периодически просыпается, проверяет свой список задачи и выполняет обнаруженные там задачи.

                                Каждая задача бота обрабатывается при помощи соответствующего обработчика. Чтобы написать новый обработчик нужно реализовать интерфейс ru.runa.wfe.extension.TaskHandler.

                                Обратите внимание, что этот вид обработчиков выполняется в контексте безопасности (security context) пользователя-бота, и здесь может выполнятся любая операция (если у бота есть на это права).

                                Обработчики задач ботов могут блокировать выполнение процесса.

                                Например, обработчик задач, отправляющий e-mail может блокировать выполнение бизнес процесса до тех пор, пока обработчик не удостоверится, что SMTP сервер принял сообщение для последующей доставки.

                                Обработчики задач вызываются периодически, когда боты проверяют свои списки задач.

                                # Специфика обработчика для элемента ветвление
                                Обработчик для Decision является java-классом, реализующим интерфейс ru.runa.wfe.extension.DecisionHandler. Интерфейс содержит один метод decide(ExecutionContext executionContext), который возвращает имя выбранного перехода (одного из выходящих из данного ветвления). Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов контекста спринга (например с помощью аннотации @Autowired).

                                Обработчик принимает ExecutionContext в качестве входящего параметра и должен сделать выбор перехода исходя из значений переменных бизнес процесса и условий, указанных в конфигурации обработчика. Точно также как обработчики действия (action handler) обработчики выбора (decision handlers) не могут использовать защищенные (secured) методы, не могут обрабатывать ошибки и откладывать выбор перехода до лучших времен.

                                По умолчанию используется ru.runa.wfe.extension.decision.GroovyDecisionHandler.

                                # Использование ru.runa.wfe.extension.handler.CommonParamBasedHandler в качестве базового класса
                                Этот класс инкапсулирует в себе парсинг XML конфигурации определенного формата. Его удобно использовать если обработчик имеет фиксированное число параметров. Пример конфигурации:

                                <?xml version="1.0" encoding="UTF-8"?>
                                <config>
                                 <input>
                                   <param name="typeName" variable="тип отсутствия" />
                                   <param name="employee" variable="сотрудник" />
                                   <param name="requester" variable="подавший заявку" />
                                   <param name="from" variable="дата с" />
                                   <param name="to" variable="дата по" />
                                   <param name="cause" variable="причина" />
                                   <param name="comment" variable="комментарий" />
                                   <param name="confirmation" variable="дата подтверждения" />
                                   <param name="firmCode" value="111" />
                                   <param name="firmPositionCode" variable="код должности" />
                                   <param name="firmDepartmentCode" variable="код подразделения" />
                                 </input>
                                 <output>
                                   <param name="uuid" variable="идентификатор объекта" />
                                 </output>
                                </config>
                                Использование обработчика Groovy
                                См. соответствующий раздел в руководстве по работе с Groovy.

                                # Как написать функцию над организационной структурой
                                Функции над организационной структурой в системе применяются, например, при инициализации Ролей-Дорожек и в правилах замещения.

                                Класс, соответствующий функции над организационной структурой, должен реализовывать интерфейс ru.runa.wfe.extension.OrgFunction.

                                Интерфейс содержит один метод

                                List<? extends Executor> getExecutors(Object... parameters)
                                Этот метод должен возвращать список исполнителей.

                                В бизнес-процессе обработчик функции над оргструктурой используются при определении Ролей-Дорожек: указывается внутри тега swimlane, в теле тега <assignment>.В качестве параметра class тега <assignment> указывается класс-обработчик для инициализации swimlane: ru.runa.wfe.extension.AssignmentHandler. Внутри тега <assignment> содержится конфигурация для этого класса, которая представляет собой имя класса-наследника интерфейса OrgFunction и список параметров в скобках. В качестве параметра может выступать конкретное значение или имя переменной бизнес процесса в фигурных скобках, перед которым стоит значок $

                                Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                                Если есть планы по использованию функции в подсистеме замещений - её можно зарегистрировать в substitutions.xml.

                                # Как написать критерий замещения
                                Критерии замещения в системе применяются в правилах замещения. Класс, соответствующий критерию замещения, должен наследоваться от ru.runa.wfe.ss.SubstitutionCriteria.

                                Для создания на основе него конечных критериев замещения с конфигурациями - его нужно зарегистрировать в substitution.criterias.xml.

                                Как реализовать класс-формат для переменных бизнес-процесса
                                См. соответствующий раздел в руководстве по работе с переменными.

                                # Как реализовать валидатор переменных
                                Классы, расширяющие абстрактный класс ru.runa.wfe.validation.FieldValidator, в системе применяются для проверки переменных при выполнении задания или старте процесса.

                                Пример:

                                public class OvertimeWorkRequestTimeCheck extends FieldValidator {
                                   @Override
                                   public void validate() {
                                       Date date = (Date) getFieldValue();
                                       if (date == null) {
                                           return;
                                       }
                                       boolean testMode = getVariableProvider().getValueNotNull(boolean.class, "тестовый режим");
                                       if (testMode) {
                                           return;
                                       }
                                       Calendar calendar = CalendarUtil.dateToCalendar(date);
                                       if (calendar.before(Calendar.getInstance())) {
                                           addError("Заявка не может быть оформлена задним числом");
                                           return;
                                       }
                                       CalendarUtil.setTimeFromCalendar(calendar, DemoProperties.getOvertimeWorkRequestMaximumStartTime());
                                       Utils.adjustCalendarForHolidaysInOvertimwWork(calendar);
                                       if (calendar.before(Calendar.getInstance())) {
                                           addError("Заявка на этот день не может быть подана, время подачи истекло " + CalendarUtil.formatDateTime(calendar));
                                       }
                                   }
                                }

                                Связь между Средой разработки и сервером осуществляется по имени валидатора, регистрация требуется на стороне сервера в файле validators.xml, а в среде разработки - в plugin.xml.

                                # Как реализовать FreeMarker тег для формы
                                FreemarkerForms#Components

                                # Как реализовать Ajax команду
                                Классы, расширяющие абстрактный класс ru.runa.wfe.commons.web.JsonAjaxCommand, (или реализующие ru.runa.wfe.commons.web.AjaxCommand) в системе применяются для доступа к функциональности сервера из JavaScript, например при отображении форм задания.

                                Регистрация команды происходит любым из двух способов:

                                в файле ajax.commands.xml, ей присваивается определенное имя
                                в контексте приложения, именем является id spring-бина
                                Затем по этому имени её можно выполнить используя JavaScript.

                                Пример команды

                                public class GetOrganizationNamesCommand extends JsonAjaxCommand {
                                   @Autowired
                                   private OrganizationDAO organizationDAO;
                                   @Override
                                   protected JSONAware execute(User user, HttpServletRequest request) throws Exception {
                                       String term = request.getParameter("term");
                                       if (term == null) {
                                           term = "";
                                       }
                                       List<Organization> organizations = organizationDAO.getAll();
                                       JSONArray array = new JSONArray();
                                       for (Organization organization : organizations) {
                                           if (organization.getName().startsWith(term)) {
                                               array.add(organization.getName());
                                           }
                                       }
                                       return array;
                                   }
                                }
                                Регистрация в wfe.custom.ajax.commands.xml

                                <?xml version="1.0" encoding="UTF-8" ?>
                                <configuration xmlns="http://runa.ru/xml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://runa.ru/xml">
                                 <command name="getOrganizationNames" class="ru.runa.rkdemo.web.ajax.GetOrganizationNamesCommand" />
                                </configuration>
                                Её использование со скрипта формы (autocomplete input)

                                $(document).ready(function() {
                                 $('#editLinkedLists').on("onRowAdded", function(event, rowIndex) {
                                  $("input[name='названия организаций["+rowIndex+"]']").autocomplete( {
                                   delay: 300,
                                   minLength: 0,
                                   source: "/wfe/ajaxcmd?command=getOrganizationNames"
                                  });
                                  $("input[name='названия организаций["+rowIndex+"]']").focus(function() {
                                   $(this).autocomplete("search", $(this).val());
                                  });
                                 });
                                });Введение
                                   # Основные компоненты и используемые технологии
                                   Для WF–системы была выбрана следующая общая архитектура (в целом соответствует архитектуре, предлагаемой коалицией WfMC):

                                   Компоненты системы:

                                   Ядро системы
                                   Содержит набор определений бизнес-процессов
                                   Содержит набор выполняющихся экземпляров бизнес–процессов
                                   Компонент, "назначающий" исполнителей для действий
                                   Клиент
                                   Список заданий (набор графических форм, содержит очереди поступивших работ, сортировки и фильтры)
                                   Проигрыватель форм (отображает формы, разработанные в Среде разработки)
                                   Административный интерфейс
                                   Показывает состояния процессов, позволяет фильтровать и останавливать процессы
                                   Позволяет загружать-выгружать процессы
                                   Позволяет заводить-удалять пользователей
                                   Позволяет задавать различные права
                                   Редактор назначения заместителей
                                   Среда разработки
                                   Конструктор графических форм
                                   Бот станции, содержащие ботов (Боты - приложения специального вида, которые также как и обычные пользователи могут выполнять задания)
                                   Подсистема управления правами доступа (авторизация и аутентификация)
                                   # Платформа программирования и используемые программные средства
                                   В качестве платформы программирования используется J2EE.

                                   Используемые программные средства:

                                   Сервер приложений - JBOSS (http://www.jboss.org).
                                   Среда разработки - любая, например Eclipse от IBM (http://www.eclipse.org).
                                   Система контроля версий - git
                                   Сборщик приложений – maven.
                                   Сервер баз данных – поддерживаются сервера БД:
                                   MS SQL Server (http://www.microsoft.com/sql/evaluation/default.mspx)
                                   HSQL (http://hsqldb.org)
                                   Oracle (http://www.oracle.com)
                                   PostgreSQL (http://postgresql.com)
                                   Операционная система — поддерживаются следующие ОС:
                                   Windows (Server 2000-2008, XP, Vista, 7)
                                   ALTLinux
                                   Mandriva Linux
                                   Fedora
                                   Debian/Ubuntu
                                   # Описание проектов
                                   Название проекта	Обязателен при сборке	Обязателен при работе	Зависимости	Описание
                                   wfe-alfresco	нет	нет	runawfe-app	Интеграция с Alfresco
                                   wfe-app	да	да	wfe-ear, wfe-cactus-it	Проект для организации сборки maven
                                   wfe-appserver	нет	нет	 ?	Не используется
                                   wfe-bots	да	да	wfe-service	Подсистема ботов
                                   wfe-cactus-it	да	нет	wfe-service	Интеграционные тесты
                                   wfe-core	да	да	-	Основные компоненты системы
                                   wfe-ear	да	да	wfe-service, wfe-bots, wfe-office, wfe-web	Проект для сборки runawfe.ear
                                   wfe-office	да	нет	wfe-core	Обработчики для работы с Word, Excel
                                   wfe-service	да	да	wfe-core	Сервисы (EJB + WebServices), представляющие собой публичное API приложения
                                   wfe-web	да	да	wfe-bots	Визуальная часть приложения
                                   wfe-webservice-client	нет	нет	 ?	Авто-генерации клиентской библиотеки на основе WSDL серверных сервисов. В нем же есть примеры использования веб-служб из Java клиента.
                                   # Описание слоев архитектуры системы
                                   Каждый компонент состоит из нескольких уровней (слоев).

                                   Список слоев:

                                   delegate
                                   service
                                   logic
                                   DAO
                                   hibernate
                                   # Слой Delegate
                                   Delegate-классы, реализующие сервисные интерфейсы представляют собой pattern проектирования BusinessDelegate, упрощающий доступ к серверному API системы. Клиентское приложение взаимодействует с системой только через Delegate-классы. Delegate-классы получаются посредством запроса фабрики Delegates, которая в зависимости от конфигурации возвращает нужную реализацию. Классы Delegate являются частью клиентского API.

                                   Список основных Delegate-классов:

                                   AuthenticationServiceDelegate – содержит методы для аутентификации пользователей в системе (с использованием логина/пароля, Kerberos и т.п.)
                                   AuthorizationServiceDelegate — содержит методы для работы с полномочиями пользователей (назначение полномочий, проверка на допустимость операции для пользователя и т.п.)
                                   BotServiceDelegate — содержит методы для работы с бот станциями и ботами
                                   ExecutorServiceDelegate — содержит методы для работы с исполнителями. Позволяет создавать/удалять/изменять исполнителей а так же включать их в группы
                                   ProfileServiceDelegate — содержит методы для работы с профайлам пользователей
                                   SubstitutionServiceDelegate — содержит методы для управления правилами замещения
                                   SystemServiceDelegate — содержит методы для входа/выхода пользователя в систему
                                   DefinitionServiceDelegate — содержит методы для работы с определениями процессов
                                   ExecutionServiceDelegate — содержит методы для работы с исполняемыми экземплярами процессов
                                   Все существующие в данный момент Delegate-классы реализуют требуемую функциональность при помощи технологии EJB.

                                   # Слой Service
                                   Слой service – это серверное API доступа к системе. Реализации Delegate интерфейсов обращаются именно к этому слою. Каждый Delegate работает с одним соответствующим классом Service. В настоящее время все разработанные service классы и интерфейсы ориентированы на EJB-технологию, однако в будущем возможны и другие реализации. Реализации классов Service являются Stateless Session Bean EJB, которые декларативно поддерживают транзакционность вызовов и запрашивают соответствующие классы из слоя Logic.

                                   Таким образом, классы Delegate – Service - Logic образуют как бы «транспорт» между клиентом и сервером.

                                   # Слой Logic
                                   Слой Logic – это реализация бизнес логики работы системы. Слой работает с классами слоя DAO для доступа к постоянному хранилищу.

                                   # Слой DAO
                                   Слой DAO – это интерфейсы и классы, обеспечивающие доступ к данным, находящимся в постоянном хранилище (базе данных). В настоящее время все DAO-классы системы реализованы при помощи ORM-средства Hibernate.

                                   # Использование Hibernate
                                   Hibernate – ORM (Object/Relational Mapping) средство. Отображает объектную архитектуру на реляционную структуру данных. Допускает настройку (не меняя разработанного кода) на большинство существующих серверов реляционных баз данных.

                                   Поддерживает работу с распределенными транзакциями, автоматически создает таблицы для новых классов и т.д. Вся работа с данными внутри системы ведется только через Hibernate.

                                   Все компоненты, предоставляющие клиентское API построены с использованием описанных выше слоев. В целях оптимизации в некоторых компонентах применяется кеширование, которое может встречаться на уровне logic или DAO. Основная функциональность по управлению кешами находится в классах CachingLogic, CacheInterceptor и классах соответствующих кешей. Изменения в кешируемых объектах перехватываются и сообщаются посредством CachingLogic всем подписавшимся на изменения классам кешей. Транзакция, изменяющая кеш, считается закрытой по окончанию обработки ejb вызова.

                                   # Обновление базы данных
                                   см. описание системы патчей.

                                   # API
                                   Система представляет API для интеграции с другими системами:

                                   # Java API
                                   Реализация (снизу вверх): БД - Hibernate3 - EJB3

                                   Документацию можно смотреть в исходном коде (javadocs в *Service.java).

                                   # WebServices API
                                   Реализация (снизу вверх): БД - Hibernate3 - JAX-WS

                                   Документация: WebServicesDeveloperGuide

                                   # Scripting API
                                   Реализация (снизу вверх): БД - Hibernate3 - XML Script

                                   Документация: AdminScriptGuide

                                   # Процесс сборки из исходного кода
                                   Исходный код системы доступен в открытом репозитории на github.

                                   Сервер можно собирать как средствами maven используя командную строку, так и используя среду Eclipse IDE.

                                   В результате сборки будет сформирован runawfe.ear, который теоретически можно запустить на любом сервере приложений. Начиная с версии 4.3.0 введена поддержка JAVA версии 8, и отказ от JAVA 6. В дальнейшем планируется отказ от java7, поэтому рекомендуется использовать сервер приложений wildfly.

                                   # Процесс сборки на примере Eclipse IDE
                                   # Необходимое программное обеспечение для сборки
                                   В отличие от Среды разработки для сборки сервера можно использовать Eclipse IDE любой версии и редакции.

                                   установите плагин m2eclipse
                                   используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу: http://maven.apache.org/
                                   добавьте путь к Apache Maven директории bin в переменную окружения Path
                                   # Импорт проектов
                                   Импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server.

                                   Eclipse srv proj.png

                                   # Установка maven артефактов
                                   Выполните

                                   ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                                   ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                                   или другим способом установите артефакты в локальный репозиторий

                                   # Сборка
                                   Заведите конфигурацию запуска на основе maven как показано на рисунке

                                   Maven.build.configuration.png

                                   Запустите конфигурацию.

                                   Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\eclipse-workspace\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"

                                   # Сборка из командной строки
                                   используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу http://maven.apache.org/
                                   добавьте путь к Apache Maven директории bin в переменную окружения Path
                                   импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server
                                   выполните обновление зависимостей
                                   ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                                   ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                                   откройте командную строку
                                   перейдите в директорию ${wfe}/wfe-app/
                                   выполните команду для сборки
                                   mvn clean package -Dmaven.test.skip=true
                                   Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"


                                   Для установки артефактов в локальный репозиторий используйте команду

                                   mvn clean install -Dmaven.test.skip=true
                                   # Использование ear на сервере приложений
                                   cкачайте текущую версию RunaWFE в виде файл-архива исполняемых java файлов runawfe-wildfly-java8-*.zip (на базе wildfly, java8)
                                   распакуйте архив
                                   обновите runawfe.ear на версию полученную в результате сборки
                                   # Расширение функциональности
                                   # Точки расширения системы
                                   Обработчики позволяют исполнить код в процессах (элементы "Обработчик", "Задача сценария") и ботах
                                   Форматы переменных определяют тип переменных и правила преобразования значений к текстовому представлению и обратно
                                   Организационные функции используются при назначении ролей и в правилах замещения для определения заместителя
                                   Критерии замещения используются в подсистеме замещения для определения заместителя при построении списка заданий
                                   Валидаторы обеспечивают проверку переменных при выполнении задания (в т.ч. введенные значения форм)
                                   Freemarker теги форм генерируют html код для отображения на форме
                                   Ajax команды предоставляют доступ к функциональности сервера из JavaScript
                                   # Процесс разработки расширений
                                   Создайте новый java-проект и подключите необходимые зависимости (wfe-core, wfe-service).

                                   Реализуйте в нем требуемые расширения и соберите его в виде jar-файла.

                                   Замечание. Использование maven облегчит процесс управления зависимостями.

                                   Разместить собранный jar на сервере вы можете:

                                   положив его в runawfe.ear!/lib
                                   положив его в директорию deploy (только для jboss4)
                                   положив его в ${jboss.server.base.dir}/wfe.custom (только для jboss7)
                                   положив его в ${jboss.server.base.dir}/${jboss.server.name}/wfe.custom (только для jboss4)
                                   # Обработчики
                                   Обработчик в процессе – компонент процесса (элементы "Обработчик", "Задача сценария"), использующийся для выполнения каких-либо действий при возникновении определенных событий (проход по определенному переходу в процессе, приход или уход управления из узла и т.п.).

                                   Обработчик должен реализовывать интерфейс ru.runa.wfe.extension.ActionHandler. Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов Spring контекста (например с помощью аннотации @Autowired).

                                   При написании нового обработчика рекомендуется наследовать его от абстрактного класса ru.runa.wfe.extension.handler.CommonHandler или ru.runa.wfe.extension.handler.CommonParamBasedHandler. В методе setConfiguration обработчик должен запомнить свои параметры (если обработчик их ожидает), а в методе execute происходит непосредственная обработка и выполнение требуемых действий.

                                   В случае, если при выполнении обработчика произошла ошибка, произойдет откат транзакции и состояние процесса будет возвращено к заданию, исполнение которого повлекло вызов обработчика. В интерфейсе обработчика для бота ru.runa.wfe.extension.TaskHandler предусмотрен метод onRollback для работы с не-транзакционными ресурсами.

                                   Эти обработчики удобно использовать для простых операций (например для отправки оповещений в виде SMS-сообщений если процесс попал в определенное состояние). Но у них есть несколько ограничений. Прежде всего у них нет соответствующего объекта контекста безопасности (security context). Это означает, что в них нельзя выполнять защищенные методы (запуск процессов, выполнение задач, создание пользователей и т.п.) Ошибочным решением в них будет блокирование выполнения процесса (например с Thread::Sleep(...)). Например, если в обработчике отправляется e-mail, а SMTP сервер недоступен, обработчику нельзя "задерживать" свое выполнение.

                                   Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                                   # Специфика обработчиков для ботов
                                   Бот - это сокращение от робот. В системе боты - это особый тип исполнителей. Система не отличает ботов от людей. У каждого бота есть свои права на вход в систему, он периодически просыпается, проверяет свой список задачи и выполняет обнаруженные там задачи.

                                   Каждая задача бота обрабатывается при помощи соответствующего обработчика. Чтобы написать новый обработчик нужно реализовать интерфейс ru.runa.wfe.extension.TaskHandler.

                                   Обратите внимание, что этот вид обработчиков выполняется в контексте безопасности (security context) пользователя-бота, и здесь может выполнятся любая операция (если у бота есть на это права).

                                   Обработчики задач ботов могут блокировать выполнение процесса.

                                   Например, обработчик задач, отправляющий e-mail может блокировать выполнение бизнес процесса до тех пор, пока обработчик не удостоверится, что SMTP сервер принял сообщение для последующей доставки.

                                   Обработчики задач вызываются периодически, когда боты проверяют свои списки задач.

                                   # Специфика обработчика для элемента ветвление
                                   Обработчик для Decision является java-классом, реализующим интерфейс ru.runa.wfe.extension.DecisionHandler. Интерфейс содержит один метод decide(ExecutionContext executionContext), который возвращает имя выбранного перехода (одного из выходящих из данного ветвления). Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов контекста спринга (например с помощью аннотации @Autowired).

                                   Обработчик принимает ExecutionContext в качестве входящего параметра и должен сделать выбор перехода исходя из значений переменных бизнес процесса и условий, указанных в конфигурации обработчика. Точно также как обработчики действия (action handler) обработчики выбора (decision handlers) не могут использовать защищенные (secured) методы, не могут обрабатывать ошибки и откладывать выбор перехода до лучших времен.

                                   По умолчанию используется ru.runa.wfe.extension.decision.GroovyDecisionHandler.

                                   # Использование ru.runa.wfe.extension.handler.CommonParamBasedHandler в качестве базового класса
                                   Этот класс инкапсулирует в себе парсинг XML конфигурации определенного формата. Его удобно использовать если обработчик имеет фиксированное число параметров. Пример конфигурации:

                                   <?xml version="1.0" encoding="UTF-8"?>
                                   <config>
                                    <input>
                                      <param name="typeName" variable="тип отсутствия" />
                                      <param name="employee" variable="сотрудник" />
                                      <param name="requester" variable="подавший заявку" />
                                      <param name="from" variable="дата с" />
                                      <param name="to" variable="дата по" />
                                      <param name="cause" variable="причина" />
                                      <param name="comment" variable="комментарий" />
                                      <param name="confirmation" variable="дата подтверждения" />
                                      <param name="firmCode" value="111" />
                                      <param name="firmPositionCode" variable="код должности" />
                                      <param name="firmDepartmentCode" variable="код подразделения" />
                                    </input>
                                    <output>
                                      <param name="uuid" variable="идентификатор объекта" />
                                    </output>
                                   </config>
                                   Использование обработчика Groovy
                                   См. соответствующий раздел в руководстве по работе с Groovy.

                                   # Как написать функцию над организационной структурой
                                   Функции над организационной структурой в системе применяются, например, при инициализации Ролей-Дорожек и в правилах замещения.

                                   Класс, соответствующий функции над организационной структурой, должен реализовывать интерфейс ru.runa.wfe.extension.OrgFunction.

                                   Интерфейс содержит один метод

                                   List<? extends Executor> getExecutors(Object... parameters)
                                   Этот метод должен возвращать список исполнителей.

                                   В бизнес-процессе обработчик функции над оргструктурой используются при определении Ролей-Дорожек: указывается внутри тега swimlane, в теле тега <assignment>.В качестве параметра class тега <assignment> указывается класс-обработчик для инициализации swimlane: ru.runa.wfe.extension.AssignmentHandler. Внутри тега <assignment> содержится конфигурация для этого класса, которая представляет собой имя класса-наследника интерфейса OrgFunction и список параметров в скобках. В качестве параметра может выступать конкретное значение или имя переменной бизнес процесса в фигурных скобках, перед которым стоит значок $

                                   Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                                   Если есть планы по использованию функции в подсистеме замещений - её можно зарегистрировать в substitutions.xml.

                                   # Как написать критерий замещения
                                   Критерии замещения в системе применяются в правилах замещения. Класс, соответствующий критерию замещения, должен наследоваться от ru.runa.wfe.ss.SubstitutionCriteria.

                                   Для создания на основе него конечных критериев замещения с конфигурациями - его нужно зарегистрировать в substitution.criterias.xml.

                                   Как реализовать класс-формат для переменных бизнес-процесса
                                   См. соответствующий раздел в руководстве по работе с переменными.

                                   # Как реализовать валидатор переменных
                                   Классы, расширяющие абстрактный класс ru.runa.wfe.validation.FieldValidator, в системе применяются для проверки переменных при выполнении задания или старте процесса.

                                   Пример:

                                   public class OvertimeWorkRequestTimeCheck extends FieldValidator {
                                      @Override
                                      public void validate() {
                                          Date date = (Date) getFieldValue();
                                          if (date == null) {
                                              return;
                                          }
                                          boolean testMode = getVariableProvider().getValueNotNull(boolean.class, "тестовый режим");
                                          if (testMode) {
                                              return;
                                          }
                                          Calendar calendar = CalendarUtil.dateToCalendar(date);
                                          if (calendar.before(Calendar.getInstance())) {
                                              addError("Заявка не может быть оформлена задним числом");
                                              return;
                                          }
                                          CalendarUtil.setTimeFromCalendar(calendar, DemoProperties.getOvertimeWorkRequestMaximumStartTime());
                                          Utils.adjustCalendarForHolidaysInOvertimwWork(calendar);
                                          if (calendar.before(Calendar.getInstance())) {
                                              addError("Заявка на этот день не может быть подана, время подачи истекло " + CalendarUtil.formatDateTime(calendar));
                                          }
                                      }
                                   }

                                   Связь между Средой разработки и сервером осуществляется по имени валидатора, регистрация требуется на стороне сервера в файле validators.xml, а в среде разработки - в plugin.xml.

                                   # Как реализовать FreeMarker тег для формы
                                   FreemarkerForms#Components

                                   # Как реализовать Ajax команду
                                   Классы, расширяющие абстрактный класс ru.runa.wfe.commons.web.JsonAjaxCommand, (или реализующие ru.runa.wfe.commons.web.AjaxCommand) в системе применяются для доступа к функциональности сервера из JavaScript, например при отображении форм задания.

                                   Регистрация команды происходит любым из двух способов:

                                   в файле ajax.commands.xml, ей присваивается определенное имя
                                   в контексте приложения, именем является id spring-бина
                                   Затем по этому имени её можно выполнить используя JavaScript.

                                   Пример команды

                                   public class GetOrganizationNamesCommand extends JsonAjaxCommand {
                                      @Autowired
                                      private OrganizationDAO organizationDAO;
                                      @Override
                                      protected JSONAware execute(User user, HttpServletRequest request) throws Exception {
                                          String term = request.getParameter("term");
                                          if (term == null) {
                                              term = "";
                                          }
                                          List<Organization> organizations = organizationDAO.getAll();
                                          JSONArray array = new JSONArray();
                                          for (Organization organization : organizations) {
                                              if (organization.getName().startsWith(term)) {
                                                  array.add(organization.getName());
                                              }
                                          }
                                          return array;
                                      }
                                   }
                                   Регистрация в wfe.custom.ajax.commands.xml

                                   <?xml version="1.0" encoding="UTF-8" ?>
                                   <configuration xmlns="http://runa.ru/xml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://runa.ru/xml">
                                    <command name="getOrganizationNames" class="ru.runa.rkdemo.web.ajax.GetOrganizationNamesCommand" />
                                   </configuration>
                                   Её использование со скрипта формы (autocomplete input)

                                   $(document).ready(function() {
                                    $('#editLinkedLists').on("onRowAdded", function(event, rowIndex) {
                                     $("input[name='названия организаций["+rowIndex+"]']").autocomplete( {
                                      delay: 300,
                                      minLength: 0,
                                      source: "/wfe/ajaxcmd?command=getOrganizationNames"
                                     });
                                     $("input[name='названия организаций["+rowIndex+"]']").focus(function() {
                                      $(this).autocomplete("search", $(this).val());
                                     });
                                    });
                                   });Введение
                                      # Основные компоненты и используемые технологии
                                      Для WF–системы была выбрана следующая общая архитектура (в целом соответствует архитектуре, предлагаемой коалицией WfMC):

                                      Компоненты системы:

                                      Ядро системы
                                      Содержит набор определений бизнес-процессов
                                      Содержит набор выполняющихся экземпляров бизнес–процессов
                                      Компонент, "назначающий" исполнителей для действий
                                      Клиент
                                      Список заданий (набор графических форм, содержит очереди поступивших работ, сортировки и фильтры)
                                      Проигрыватель форм (отображает формы, разработанные в Среде разработки)
                                      Административный интерфейс
                                      Показывает состояния процессов, позволяет фильтровать и останавливать процессы
                                      Позволяет загружать-выгружать процессы
                                      Позволяет заводить-удалять пользователей
                                      Позволяет задавать различные права
                                      Редактор назначения заместителей
                                      Среда разработки
                                      Конструктор графических форм
                                      Бот станции, содержащие ботов (Боты - приложения специального вида, которые также как и обычные пользователи могут выполнять задания)
                                      Подсистема управления правами доступа (авторизация и аутентификация)
                                      # Платформа программирования и используемые программные средства
                                      В качестве платформы программирования используется J2EE.

                                      Используемые программные средства:

                                      Сервер приложений - JBOSS (http://www.jboss.org).
                                      Среда разработки - любая, например Eclipse от IBM (http://www.eclipse.org).
                                      Система контроля версий - git
                                      Сборщик приложений – maven.
                                      Сервер баз данных – поддерживаются сервера БД:
                                      MS SQL Server (http://www.microsoft.com/sql/evaluation/default.mspx)
                                      HSQL (http://hsqldb.org)
                                      Oracle (http://www.oracle.com)
                                      PostgreSQL (http://postgresql.com)
                                      Операционная система — поддерживаются следующие ОС:
                                      Windows (Server 2000-2008, XP, Vista, 7)
                                      ALTLinux
                                      Mandriva Linux
                                      Fedora
                                      Debian/Ubuntu
                                      # Описание проектов
                                      Название проекта	Обязателен при сборке	Обязателен при работе	Зависимости	Описание
                                      wfe-alfresco	нет	нет	runawfe-app	Интеграция с Alfresco
                                      wfe-app	да	да	wfe-ear, wfe-cactus-it	Проект для организации сборки maven
                                      wfe-appserver	нет	нет	 ?	Не используется
                                      wfe-bots	да	да	wfe-service	Подсистема ботов
                                      wfe-cactus-it	да	нет	wfe-service	Интеграционные тесты
                                      wfe-core	да	да	-	Основные компоненты системы
                                      wfe-ear	да	да	wfe-service, wfe-bots, wfe-office, wfe-web	Проект для сборки runawfe.ear
                                      wfe-office	да	нет	wfe-core	Обработчики для работы с Word, Excel
                                      wfe-service	да	да	wfe-core	Сервисы (EJB + WebServices), представляющие собой публичное API приложения
                                      wfe-web	да	да	wfe-bots	Визуальная часть приложения
                                      wfe-webservice-client	нет	нет	 ?	Авто-генерации клиентской библиотеки на основе WSDL серверных сервисов. В нем же есть примеры использования веб-служб из Java клиента.
                                      # Описание слоев архитектуры системы
                                      Каждый компонент состоит из нескольких уровней (слоев).

                                      Список слоев:

                                      delegate
                                      service
                                      logic
                                      DAO
                                      hibernate
                                      # Слой Delegate
                                      Delegate-классы, реализующие сервисные интерфейсы представляют собой pattern проектирования BusinessDelegate, упрощающий доступ к серверному API системы. Клиентское приложение взаимодействует с системой только через Delegate-классы. Delegate-классы получаются посредством запроса фабрики Delegates, которая в зависимости от конфигурации возвращает нужную реализацию. Классы Delegate являются частью клиентского API.

                                      Список основных Delegate-классов:

                                      AuthenticationServiceDelegate – содержит методы для аутентификации пользователей в системе (с использованием логина/пароля, Kerberos и т.п.)
                                      AuthorizationServiceDelegate — содержит методы для работы с полномочиями пользователей (назначение полномочий, проверка на допустимость операции для пользователя и т.п.)
                                      BotServiceDelegate — содержит методы для работы с бот станциями и ботами
                                      ExecutorServiceDelegate — содержит методы для работы с исполнителями. Позволяет создавать/удалять/изменять исполнителей а так же включать их в группы
                                      ProfileServiceDelegate — содержит методы для работы с профайлам пользователей
                                      SubstitutionServiceDelegate — содержит методы для управления правилами замещения
                                      SystemServiceDelegate — содержит методы для входа/выхода пользователя в систему
                                      DefinitionServiceDelegate — содержит методы для работы с определениями процессов
                                      ExecutionServiceDelegate — содержит методы для работы с исполняемыми экземплярами процессов
                                      Все существующие в данный момент Delegate-классы реализуют требуемую функциональность при помощи технологии EJB.

                                      # Слой Service
                                      Слой service – это серверное API доступа к системе. Реализации Delegate интерфейсов обращаются именно к этому слою. Каждый Delegate работает с одним соответствующим классом Service. В настоящее время все разработанные service классы и интерфейсы ориентированы на EJB-технологию, однако в будущем возможны и другие реализации. Реализации классов Service являются Stateless Session Bean EJB, которые декларативно поддерживают транзакционность вызовов и запрашивают соответствующие классы из слоя Logic.

                                      Таким образом, классы Delegate – Service - Logic образуют как бы «транспорт» между клиентом и сервером.

                                      # Слой Logic
                                      Слой Logic – это реализация бизнес логики работы системы. Слой работает с классами слоя DAO для доступа к постоянному хранилищу.

                                      # Слой DAO
                                      Слой DAO – это интерфейсы и классы, обеспечивающие доступ к данным, находящимся в постоянном хранилище (базе данных). В настоящее время все DAO-классы системы реализованы при помощи ORM-средства Hibernate.

                                      # Использование Hibernate
                                      Hibernate – ORM (Object/Relational Mapping) средство. Отображает объектную архитектуру на реляционную структуру данных. Допускает настройку (не меняя разработанного кода) на большинство существующих серверов реляционных баз данных.

                                      Поддерживает работу с распределенными транзакциями, автоматически создает таблицы для новых классов и т.д. Вся работа с данными внутри системы ведется только через Hibernate.

                                      Все компоненты, предоставляющие клиентское API построены с использованием описанных выше слоев. В целях оптимизации в некоторых компонентах применяется кеширование, которое может встречаться на уровне logic или DAO. Основная функциональность по управлению кешами находится в классах CachingLogic, CacheInterceptor и классах соответствующих кешей. Изменения в кешируемых объектах перехватываются и сообщаются посредством CachingLogic всем подписавшимся на изменения классам кешей. Транзакция, изменяющая кеш, считается закрытой по окончанию обработки ejb вызова.

                                      # Обновление базы данных
                                      см. описание системы патчей.

                                      # API
                                      Система представляет API для интеграции с другими системами:

                                      # Java API
                                      Реализация (снизу вверх): БД - Hibernate3 - EJB3

                                      Документацию можно смотреть в исходном коде (javadocs в *Service.java).

                                      # WebServices API
                                      Реализация (снизу вверх): БД - Hibernate3 - JAX-WS

                                      Документация: WebServicesDeveloperGuide

                                      # Scripting API
                                      Реализация (снизу вверх): БД - Hibernate3 - XML Script

                                      Документация: AdminScriptGuide

                                      # Процесс сборки из исходного кода
                                      Исходный код системы доступен в открытом репозитории на github.

                                      Сервер можно собирать как средствами maven используя командную строку, так и используя среду Eclipse IDE.

                                      В результате сборки будет сформирован runawfe.ear, который теоретически можно запустить на любом сервере приложений. Начиная с версии 4.3.0 введена поддержка JAVA версии 8, и отказ от JAVA 6. В дальнейшем планируется отказ от java7, поэтому рекомендуется использовать сервер приложений wildfly.

                                      # Процесс сборки на примере Eclipse IDE
                                      # Необходимое программное обеспечение для сборки
                                      В отличие от Среды разработки для сборки сервера можно использовать Eclipse IDE любой версии и редакции.

                                      установите плагин m2eclipse
                                      используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу: http://maven.apache.org/
                                      добавьте путь к Apache Maven директории bin в переменную окружения Path
                                      # Импорт проектов
                                      Импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server.

                                      Eclipse srv proj.png

                                      # Установка maven артефактов
                                      Выполните

                                      ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                                      ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                                      или другим способом установите артефакты в локальный репозиторий

                                      # Сборка
                                      Заведите конфигурацию запуска на основе maven как показано на рисунке

                                      Maven.build.configuration.png

                                      Запустите конфигурацию.

                                      Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\eclipse-workspace\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"

                                      # Сборка из командной строки
                                      используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу http://maven.apache.org/
                                      добавьте путь к Apache Maven директории bin в переменную окружения Path
                                      импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server
                                      выполните обновление зависимостей
                                      ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                                      ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                                      откройте командную строку
                                      перейдите в директорию ${wfe}/wfe-app/
                                      выполните команду для сборки
                                      mvn clean package -Dmaven.test.skip=true
                                      Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"


                                      Для установки артефактов в локальный репозиторий используйте команду

                                      mvn clean install -Dmaven.test.skip=true
                                      # Использование ear на сервере приложений
                                      cкачайте текущую версию RunaWFE в виде файл-архива исполняемых java файлов runawfe-wildfly-java8-*.zip (на базе wildfly, java8)
                                      распакуйте архив
                                      обновите runawfe.ear на версию полученную в результате сборки
                                      # Расширение функциональности
                                      # Точки расширения системы
                                      Обработчики позволяют исполнить код в процессах (элементы "Обработчик", "Задача сценария") и ботах
                                      Форматы переменных определяют тип переменных и правила преобразования значений к текстовому представлению и обратно
                                      Организационные функции используются при назначении ролей и в правилах замещения для определения заместителя
                                      Критерии замещения используются в подсистеме замещения для определения заместителя при построении списка заданий
                                      Валидаторы обеспечивают проверку переменных при выполнении задания (в т.ч. введенные значения форм)
                                      Freemarker теги форм генерируют html код для отображения на форме
                                      Ajax команды предоставляют доступ к функциональности сервера из JavaScript
                                      # Процесс разработки расширений
                                      Создайте новый java-проект и подключите необходимые зависимости (wfe-core, wfe-service).

                                      Реализуйте в нем требуемые расширения и соберите его в виде jar-файла.

                                      Замечание. Использование maven облегчит процесс управления зависимостями.

                                      Разместить собранный jar на сервере вы можете:

                                      положив его в runawfe.ear!/lib
                                      положив его в директорию deploy (только для jboss4)
                                      положив его в ${jboss.server.base.dir}/wfe.custom (только для jboss7)
                                      положив его в ${jboss.server.base.dir}/${jboss.server.name}/wfe.custom (только для jboss4)
                                      # Обработчики
                                      Обработчик в процессе – компонент процесса (элементы "Обработчик", "Задача сценария"), использующийся для выполнения каких-либо действий при возникновении определенных событий (проход по определенному переходу в процессе, приход или уход управления из узла и т.п.).

                                      Обработчик должен реализовывать интерфейс ru.runa.wfe.extension.ActionHandler. Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов Spring контекста (например с помощью аннотации @Autowired).

                                      При написании нового обработчика рекомендуется наследовать его от абстрактного класса ru.runa.wfe.extension.handler.CommonHandler или ru.runa.wfe.extension.handler.CommonParamBasedHandler. В методе setConfiguration обработчик должен запомнить свои параметры (если обработчик их ожидает), а в методе execute происходит непосредственная обработка и выполнение требуемых действий.

                                      В случае, если при выполнении обработчика произошла ошибка, произойдет откат транзакции и состояние процесса будет возвращено к заданию, исполнение которого повлекло вызов обработчика. В интерфейсе обработчика для бота ru.runa.wfe.extension.TaskHandler предусмотрен метод onRollback для работы с не-транзакционными ресурсами.

                                      Эти обработчики удобно использовать для простых операций (например для отправки оповещений в виде SMS-сообщений если процесс попал в определенное состояние). Но у них есть несколько ограничений. Прежде всего у них нет соответствующего объекта контекста безопасности (security context). Это означает, что в них нельзя выполнять защищенные методы (запуск процессов, выполнение задач, создание пользователей и т.п.) Ошибочным решением в них будет блокирование выполнения процесса (например с Thread::Sleep(...)). Например, если в обработчике отправляется e-mail, а SMTP сервер недоступен, обработчику нельзя "задерживать" свое выполнение.

                                      Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                                      # Специфика обработчиков для ботов
                                      Бот - это сокращение от робот. В системе боты - это особый тип исполнителей. Система не отличает ботов от людей. У каждого бота есть свои права на вход в систему, он периодически просыпается, проверяет свой список задачи и выполняет обнаруженные там задачи.

                                      Каждая задача бота обрабатывается при помощи соответствующего обработчика. Чтобы написать новый обработчик нужно реализовать интерфейс ru.runa.wfe.extension.TaskHandler.

                                      Обратите внимание, что этот вид обработчиков выполняется в контексте безопасности (security context) пользователя-бота, и здесь может выполнятся любая операция (если у бота есть на это права).

                                      Обработчики задач ботов могут блокировать выполнение процесса.

                                      Например, обработчик задач, отправляющий e-mail может блокировать выполнение бизнес процесса до тех пор, пока обработчик не удостоверится, что SMTP сервер принял сообщение для последующей доставки.

                                      Обработчики задач вызываются периодически, когда боты проверяют свои списки задач.

                                      # Специфика обработчика для элемента ветвление
                                      Обработчик для Decision является java-классом, реализующим интерфейс ru.runa.wfe.extension.DecisionHandler. Интерфейс содержит один метод decide(ExecutionContext executionContext), который возвращает имя выбранного перехода (одного из выходящих из данного ветвления). Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов контекста спринга (например с помощью аннотации @Autowired).

                                      Обработчик принимает ExecutionContext в качестве входящего параметра и должен сделать выбор перехода исходя из значений переменных бизнес процесса и условий, указанных в конфигурации обработчика. Точно также как обработчики действия (action handler) обработчики выбора (decision handlers) не могут использовать защищенные (secured) методы, не могут обрабатывать ошибки и откладывать выбор перехода до лучших времен.

                                      По умолчанию используется ru.runa.wfe.extension.decision.GroovyDecisionHandler.

                                      # Использование ru.runa.wfe.extension.handler.CommonParamBasedHandler в качестве базового класса
                                      Этот класс инкапсулирует в себе парсинг XML конфигурации определенного формата. Его удобно использовать если обработчик имеет фиксированное число параметров. Пример конфигурации:

                                      <?xml version="1.0" encoding="UTF-8"?>
                                      <config>
                                       <input>
                                         <param name="typeName" variable="тип отсутствия" />
                                         <param name="employee" variable="сотрудник" />
                                         <param name="requester" variable="подавший заявку" />
                                         <param name="from" variable="дата с" />
                                         <param name="to" variable="дата по" />
                                         <param name="cause" variable="причина" />
                                         <param name="comment" variable="комментарий" />
                                         <param name="confirmation" variable="дата подтверждения" />
                                         <param name="firmCode" value="111" />
                                         <param name="firmPositionCode" variable="код должности" />
                                         <param name="firmDepartmentCode" variable="код подразделения" />
                                       </input>
                                       <output>
                                         <param name="uuid" variable="идентификатор объекта" />
                                       </output>
                                      </config>
                                      Использование обработчика Groovy
                                      См. соответствующий раздел в руководстве по работе с Groovy.

                                      # Как написать функцию над организационной структурой
                                      Функции над организационной структурой в системе применяются, например, при инициализации Ролей-Дорожек и в правилах замещения.

                                      Класс, соответствующий функции над организационной структурой, должен реализовывать интерфейс ru.runa.wfe.extension.OrgFunction.

                                      Интерфейс содержит один метод

                                      List<? extends Executor> getExecutors(Object... parameters)
                                      Этот метод должен возвращать список исполнителей.

                                      В бизнес-процессе обработчик функции над оргструктурой используются при определении Ролей-Дорожек: указывается внутри тега swimlane, в теле тега <assignment>.В качестве параметра class тега <assignment> указывается класс-обработчик для инициализации swimlane: ru.runa.wfe.extension.AssignmentHandler. Внутри тега <assignment> содержится конфигурация для этого класса, которая представляет собой имя класса-наследника интерфейса OrgFunction и список параметров в скобках. В качестве параметра может выступать конкретное значение или имя переменной бизнес процесса в фигурных скобках, перед которым стоит значок $

                                      Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                                      Если есть планы по использованию функции в подсистеме замещений - её можно зарегистрировать в substitutions.xml.

                                      # Как написать критерий замещения
                                      Критерии замещения в системе применяются в правилах замещения. Класс, соответствующий критерию замещения, должен наследоваться от ru.runa.wfe.ss.SubstitutionCriteria.

                                      Для создания на основе него конечных критериев замещения с конфигурациями - его нужно зарегистрировать в substitution.criterias.xml.

                                      Как реализовать класс-формат для переменных бизнес-процесса
                                      См. соответствующий раздел в руководстве по работе с переменными.

                                      # Как реализовать валидатор переменных
                                      Классы, расширяющие абстрактный класс ru.runa.wfe.validation.FieldValidator, в системе применяются для проверки переменных при выполнении задания или старте процесса.

                                      Пример:

                                      public class OvertimeWorkRequestTimeCheck extends FieldValidator {
                                         @Override
                                         public void validate() {
                                             Date date = (Date) getFieldValue();
                                             if (date == null) {
                                                 return;
                                             }
                                             boolean testMode = getVariableProvider().getValueNotNull(boolean.class, "тестовый режим");
                                             if (testMode) {
                                                 return;
                                             }
                                             Calendar calendar = CalendarUtil.dateToCalendar(date);
                                             if (calendar.before(Calendar.getInstance())) {
                                                 addError("Заявка не может быть оформлена задним числом");
                                                 return;
                                             }
                                             CalendarUtil.setTimeFromCalendar(calendar, DemoProperties.getOvertimeWorkRequestMaximumStartTime());
                                             Utils.adjustCalendarForHolidaysInOvertimwWork(calendar);
                                             if (calendar.before(Calendar.getInstance())) {
                                                 addError("Заявка на этот день не может быть подана, время подачи истекло " + CalendarUtil.formatDateTime(calendar));
                                             }
                                         }
                                      }

                                      Связь между Средой разработки и сервером осуществляется по имени валидатора, регистрация требуется на стороне сервера в файле validators.xml, а в среде разработки - в plugin.xml.

                                      # Как реализовать FreeMarker тег для формы
                                      FreemarkerForms#Components

                                      # Как реализовать Ajax команду
                                      Классы, расширяющие абстрактный класс ru.runa.wfe.commons.web.JsonAjaxCommand, (или реализующие ru.runa.wfe.commons.web.AjaxCommand) в системе применяются для доступа к функциональности сервера из JavaScript, например при отображении форм задания.

                                      Регистрация команды происходит любым из двух способов:

                                      в файле ajax.commands.xml, ей присваивается определенное имя
                                      в контексте приложения, именем является id spring-бина
                                      Затем по этому имени её можно выполнить используя JavaScript.

                                      Пример команды

                                      public class GetOrganizationNamesCommand extends JsonAjaxCommand {
                                         @Autowired
                                         private OrganizationDAO organizationDAO;
                                         @Override
                                         protected JSONAware execute(User user, HttpServletRequest request) throws Exception {
                                             String term = request.getParameter("term");
                                             if (term == null) {
                                                 term = "";
                                             }
                                             List<Organization> organizations = organizationDAO.getAll();
                                             JSONArray array = new JSONArray();
                                             for (Organization organization : organizations) {
                                                 if (organization.getName().startsWith(term)) {
                                                     array.add(organization.getName());
                                                 }
                                             }
                                             return array;
                                         }
                                      }
                                      Регистрация в wfe.custom.ajax.commands.xml

                                      <?xml version="1.0" encoding="UTF-8" ?>
                                      <configuration xmlns="http://runa.ru/xml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://runa.ru/xml">
                                       <command name="getOrganizationNames" class="ru.runa.rkdemo.web.ajax.GetOrganizationNamesCommand" />
                                      </configuration>
                                      Её использование со скрипта формы (autocomplete input)

                                      $(document).ready(function() {
                                       $('#editLinkedLists').on("onRowAdded", function(event, rowIndex) {
                                        $("input[name='названия организаций["+rowIndex+"]']").autocomplete( {
                                         delay: 300,
                                         minLength: 0,
                                         source: "/wfe/ajaxcmd?command=getOrganizationNames"
                                        });
                                        $("input[name='названия организаций["+rowIndex+"]']").focus(function() {
                                         $(this).autocomplete("search", $(this).val());
                                        });
                                       });
                                      });Введение
                                         # Основные компоненты и используемые технологии
                                         Для WF–системы была выбрана следующая общая архитектура (в целом соответствует архитектуре, предлагаемой коалицией WfMC):

                                         Компоненты системы:

                                         Ядро системы
                                         Содержит набор определений бизнес-процессов
                                         Содержит набор выполняющихся экземпляров бизнес–процессов
                                         Компонент, "назначающий" исполнителей для действий
                                         Клиент
                                         Список заданий (набор графических форм, содержит очереди поступивших работ, сортировки и фильтры)
                                         Проигрыватель форм (отображает формы, разработанные в Среде разработки)
                                         Административный интерфейс
                                         Показывает состояния процессов, позволяет фильтровать и останавливать процессы
                                         Позволяет загружать-выгружать процессы
                                         Позволяет заводить-удалять пользователей
                                         Позволяет задавать различные права
                                         Редактор назначения заместителей
                                         Среда разработки
                                         Конструктор графических форм
                                         Бот станции, содержащие ботов (Боты - приложения специального вида, которые также как и обычные пользователи могут выполнять задания)
                                         Подсистема управления правами доступа (авторизация и аутентификация)
                                         # Платформа программирования и используемые программные средства
                                         В качестве платформы программирования используется J2EE.

                                         Используемые программные средства:

                                         Сервер приложений - JBOSS (http://www.jboss.org).
                                         Среда разработки - любая, например Eclipse от IBM (http://www.eclipse.org).
                                         Система контроля версий - git
                                         Сборщик приложений – maven.
                                         Сервер баз данных – поддерживаются сервера БД:
                                         MS SQL Server (http://www.microsoft.com/sql/evaluation/default.mspx)
                                         HSQL (http://hsqldb.org)
                                         Oracle (http://www.oracle.com)
                                         PostgreSQL (http://postgresql.com)
                                         Операционная система — поддерживаются следующие ОС:
                                         Windows (Server 2000-2008, XP, Vista, 7)
                                         ALTLinux
                                         Mandriva Linux
                                         Fedora
                                         Debian/Ubuntu
                                         # Описание проектов
                                         Название проекта	Обязателен при сборке	Обязателен при работе	Зависимости	Описание
                                         wfe-alfresco	нет	нет	runawfe-app	Интеграция с Alfresco
                                         wfe-app	да	да	wfe-ear, wfe-cactus-it	Проект для организации сборки maven
                                         wfe-appserver	нет	нет	 ?	Не используется
                                         wfe-bots	да	да	wfe-service	Подсистема ботов
                                         wfe-cactus-it	да	нет	wfe-service	Интеграционные тесты
                                         wfe-core	да	да	-	Основные компоненты системы
                                         wfe-ear	да	да	wfe-service, wfe-bots, wfe-office, wfe-web	Проект для сборки runawfe.ear
                                         wfe-office	да	нет	wfe-core	Обработчики для работы с Word, Excel
                                         wfe-service	да	да	wfe-core	Сервисы (EJB + WebServices), представляющие собой публичное API приложения
                                         wfe-web	да	да	wfe-bots	Визуальная часть приложения
                                         wfe-webservice-client	нет	нет	 ?	Авто-генерации клиентской библиотеки на основе WSDL серверных сервисов. В нем же есть примеры использования веб-служб из Java клиента.
                                         # Описание слоев архитектуры системы
                                         Каждый компонент состоит из нескольких уровней (слоев).

                                         Список слоев:

                                         delegate
                                         service
                                         logic
                                         DAO
                                         hibernate
                                         # Слой Delegate
                                         Delegate-классы, реализующие сервисные интерфейсы представляют собой pattern проектирования BusinessDelegate, упрощающий доступ к серверному API системы. Клиентское приложение взаимодействует с системой только через Delegate-классы. Delegate-классы получаются посредством запроса фабрики Delegates, которая в зависимости от конфигурации возвращает нужную реализацию. Классы Delegate являются частью клиентского API.

                                         Список основных Delegate-классов:

                                         AuthenticationServiceDelegate – содержит методы для аутентификации пользователей в системе (с использованием логина/пароля, Kerberos и т.п.)
                                         AuthorizationServiceDelegate — содержит методы для работы с полномочиями пользователей (назначение полномочий, проверка на допустимость операции для пользователя и т.п.)
                                         BotServiceDelegate — содержит методы для работы с бот станциями и ботами
                                         ExecutorServiceDelegate — содержит методы для работы с исполнителями. Позволяет создавать/удалять/изменять исполнителей а так же включать их в группы
                                         ProfileServiceDelegate — содержит методы для работы с профайлам пользователей
                                         SubstitutionServiceDelegate — содержит методы для управления правилами замещения
                                         SystemServiceDelegate — содержит методы для входа/выхода пользователя в систему
                                         DefinitionServiceDelegate — содержит методы для работы с определениями процессов
                                         ExecutionServiceDelegate — содержит методы для работы с исполняемыми экземплярами процессов
                                         Все существующие в данный момент Delegate-классы реализуют требуемую функциональность при помощи технологии EJB.

                                         # Слой Service
                                         Слой service – это серверное API доступа к системе. Реализации Delegate интерфейсов обращаются именно к этому слою. Каждый Delegate работает с одним соответствующим классом Service. В настоящее время все разработанные service классы и интерфейсы ориентированы на EJB-технологию, однако в будущем возможны и другие реализации. Реализации классов Service являются Stateless Session Bean EJB, которые декларативно поддерживают транзакционность вызовов и запрашивают соответствующие классы из слоя Logic.

                                         Таким образом, классы Delegate – Service - Logic образуют как бы «транспорт» между клиентом и сервером.

                                         # Слой Logic
                                         Слой Logic – это реализация бизнес логики работы системы. Слой работает с классами слоя DAO для доступа к постоянному хранилищу.

                                         # Слой DAO
                                         Слой DAO – это интерфейсы и классы, обеспечивающие доступ к данным, находящимся в постоянном хранилище (базе данных). В настоящее время все DAO-классы системы реализованы при помощи ORM-средства Hibernate.

                                         # Использование Hibernate
                                         Hibernate – ORM (Object/Relational Mapping) средство. Отображает объектную архитектуру на реляционную структуру данных. Допускает настройку (не меняя разработанного кода) на большинство существующих серверов реляционных баз данных.

                                         Поддерживает работу с распределенными транзакциями, автоматически создает таблицы для новых классов и т.д. Вся работа с данными внутри системы ведется только через Hibernate.

                                         Все компоненты, предоставляющие клиентское API построены с использованием описанных выше слоев. В целях оптимизации в некоторых компонентах применяется кеширование, которое может встречаться на уровне logic или DAO. Основная функциональность по управлению кешами находится в классах CachingLogic, CacheInterceptor и классах соответствующих кешей. Изменения в кешируемых объектах перехватываются и сообщаются посредством CachingLogic всем подписавшимся на изменения классам кешей. Транзакция, изменяющая кеш, считается закрытой по окончанию обработки ejb вызова.

                                         # Обновление базы данных
                                         см. описание системы патчей.

                                         # API
                                         Система представляет API для интеграции с другими системами:

                                         # Java API
                                         Реализация (снизу вверх): БД - Hibernate3 - EJB3

                                         Документацию можно смотреть в исходном коде (javadocs в *Service.java).

                                         # WebServices API
                                         Реализация (снизу вверх): БД - Hibernate3 - JAX-WS

                                         Документация: WebServicesDeveloperGuide

                                         # Scripting API
                                         Реализация (снизу вверх): БД - Hibernate3 - XML Script

                                         Документация: AdminScriptGuide

                                         # Процесс сборки из исходного кода
                                         Исходный код системы доступен в открытом репозитории на github.

                                         Сервер можно собирать как средствами maven используя командную строку, так и используя среду Eclipse IDE.

                                         В результате сборки будет сформирован runawfe.ear, который теоретически можно запустить на любом сервере приложений. Начиная с версии 4.3.0 введена поддержка JAVA версии 8, и отказ от JAVA 6. В дальнейшем планируется отказ от java7, поэтому рекомендуется использовать сервер приложений wildfly.

                                         # Процесс сборки на примере Eclipse IDE
                                         # Необходимое программное обеспечение для сборки
                                         В отличие от Среды разработки для сборки сервера можно использовать Eclipse IDE любой версии и редакции.

                                         установите плагин m2eclipse
                                         используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу: http://maven.apache.org/
                                         добавьте путь к Apache Maven директории bin в переменную окружения Path
                                         # Импорт проектов
                                         Импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server.

                                         Eclipse srv proj.png

                                         # Установка maven артефактов
                                         Выполните

                                         ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                                         ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                                         или другим способом установите артефакты в локальный репозиторий

                                         # Сборка
                                         Заведите конфигурацию запуска на основе maven как показано на рисунке

                                         Maven.build.configuration.png

                                         Запустите конфигурацию.

                                         Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\eclipse-workspace\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"

                                         # Сборка из командной строки
                                         используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу http://maven.apache.org/
                                         добавьте путь к Apache Maven директории bin в переменную окружения Path
                                         импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server
                                         выполните обновление зависимостей
                                         ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                                         ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                                         откройте командную строку
                                         перейдите в директорию ${wfe}/wfe-app/
                                         выполните команду для сборки
                                         mvn clean package -Dmaven.test.skip=true
                                         Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"


                                         Для установки артефактов в локальный репозиторий используйте команду

                                         mvn clean install -Dmaven.test.skip=true
                                         # Использование ear на сервере приложений
                                         cкачайте текущую версию RunaWFE в виде файл-архива исполняемых java файлов runawfe-wildfly-java8-*.zip (на базе wildfly, java8)
                                         распакуйте архив
                                         обновите runawfe.ear на версию полученную в результате сборки
                                         # Расширение функциональности
                                         # Точки расширения системы
                                         Обработчики позволяют исполнить код в процессах (элементы "Обработчик", "Задача сценария") и ботах
                                         Форматы переменных определяют тип переменных и правила преобразования значений к текстовому представлению и обратно
                                         Организационные функции используются при назначении ролей и в правилах замещения для определения заместителя
                                         Критерии замещения используются в подсистеме замещения для определения заместителя при построении списка заданий
                                         Валидаторы обеспечивают проверку переменных при выполнении задания (в т.ч. введенные значения форм)
                                         Freemarker теги форм генерируют html код для отображения на форме
                                         Ajax команды предоставляют доступ к функциональности сервера из JavaScript
                                         # Процесс разработки расширений
                                         Создайте новый java-проект и подключите необходимые зависимости (wfe-core, wfe-service).

                                         Реализуйте в нем требуемые расширения и соберите его в виде jar-файла.

                                         Замечание. Использование maven облегчит процесс управления зависимостями.

                                         Разместить собранный jar на сервере вы можете:

                                         положив его в runawfe.ear!/lib
                                         положив его в директорию deploy (только для jboss4)
                                         положив его в ${jboss.server.base.dir}/wfe.custom (только для jboss7)
                                         положив его в ${jboss.server.base.dir}/${jboss.server.name}/wfe.custom (только для jboss4)
                                         # Обработчики
                                         Обработчик в процессе – компонент процесса (элементы "Обработчик", "Задача сценария"), использующийся для выполнения каких-либо действий при возникновении определенных событий (проход по определенному переходу в процессе, приход или уход управления из узла и т.п.).

                                         Обработчик должен реализовывать интерфейс ru.runa.wfe.extension.ActionHandler. Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов Spring контекста (например с помощью аннотации @Autowired).

                                         При написании нового обработчика рекомендуется наследовать его от абстрактного класса ru.runa.wfe.extension.handler.CommonHandler или ru.runa.wfe.extension.handler.CommonParamBasedHandler. В методе setConfiguration обработчик должен запомнить свои параметры (если обработчик их ожидает), а в методе execute происходит непосредственная обработка и выполнение требуемых действий.

                                         В случае, если при выполнении обработчика произошла ошибка, произойдет откат транзакции и состояние процесса будет возвращено к заданию, исполнение которого повлекло вызов обработчика. В интерфейсе обработчика для бота ru.runa.wfe.extension.TaskHandler предусмотрен метод onRollback для работы с не-транзакционными ресурсами.

                                         Эти обработчики удобно использовать для простых операций (например для отправки оповещений в виде SMS-сообщений если процесс попал в определенное состояние). Но у них есть несколько ограничений. Прежде всего у них нет соответствующего объекта контекста безопасности (security context). Это означает, что в них нельзя выполнять защищенные методы (запуск процессов, выполнение задач, создание пользователей и т.п.) Ошибочным решением в них будет блокирование выполнения процесса (например с Thread::Sleep(...)). Например, если в обработчике отправляется e-mail, а SMTP сервер недоступен, обработчику нельзя "задерживать" свое выполнение.

                                         Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                                         # Специфика обработчиков для ботов
                                         Бот - это сокращение от робот. В системе боты - это особый тип исполнителей. Система не отличает ботов от людей. У каждого бота есть свои права на вход в систему, он периодически просыпается, проверяет свой список задачи и выполняет обнаруженные там задачи.

                                         Каждая задача бота обрабатывается при помощи соответствующего обработчика. Чтобы написать новый обработчик нужно реализовать интерфейс ru.runa.wfe.extension.TaskHandler.

                                         Обратите внимание, что этот вид обработчиков выполняется в контексте безопасности (security context) пользователя-бота, и здесь может выполнятся любая операция (если у бота есть на это права).

                                         Обработчики задач ботов могут блокировать выполнение процесса.

                                         Например, обработчик задач, отправляющий e-mail может блокировать выполнение бизнес процесса до тех пор, пока обработчик не удостоверится, что SMTP сервер принял сообщение для последующей доставки.

                                         Обработчики задач вызываются периодически, когда боты проверяют свои списки задач.

                                         # Специфика обработчика для элемента ветвление
                                         Обработчик для Decision является java-классом, реализующим интерфейс ru.runa.wfe.extension.DecisionHandler. Интерфейс содержит один метод decide(ExecutionContext executionContext), который возвращает имя выбранного перехода (одного из выходящих из данного ветвления). Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов контекста спринга (например с помощью аннотации @Autowired).

                                         Обработчик принимает ExecutionContext в качестве входящего параметра и должен сделать выбор перехода исходя из значений переменных бизнес процесса и условий, указанных в конфигурации обработчика. Точно также как обработчики действия (action handler) обработчики выбора (decision handlers) не могут использовать защищенные (secured) методы, не могут обрабатывать ошибки и откладывать выбор перехода до лучших времен.

                                         По умолчанию используется ru.runa.wfe.extension.decision.GroovyDecisionHandler.

                                         # Использование ru.runa.wfe.extension.handler.CommonParamBasedHandler в качестве базового класса
                                         Этот класс инкапсулирует в себе парсинг XML конфигурации определенного формата. Его удобно использовать если обработчик имеет фиксированное число параметров. Пример конфигурации:

                                         <?xml version="1.0" encoding="UTF-8"?>
                                         <config>
                                          <input>
                                            <param name="typeName" variable="тип отсутствия" />
                                            <param name="employee" variable="сотрудник" />
                                            <param name="requester" variable="подавший заявку" />
                                            <param name="from" variable="дата с" />
                                            <param name="to" variable="дата по" />
                                            <param name="cause" variable="причина" />
                                            <param name="comment" variable="комментарий" />
                                            <param name="confirmation" variable="дата подтверждения" />
                                            <param name="firmCode" value="111" />
                                            <param name="firmPositionCode" variable="код должности" />
                                            <param name="firmDepartmentCode" variable="код подразделения" />
                                          </input>
                                          <output>
                                            <param name="uuid" variable="идентификатор объекта" />
                                          </output>
                                         </config>
                                         Использование обработчика Groovy
                                         См. соответствующий раздел в руководстве по работе с Groovy.

                                         # Как написать функцию над организационной структурой
                                         Функции над организационной структурой в системе применяются, например, при инициализации Ролей-Дорожек и в правилах замещения.

                                         Класс, соответствующий функции над организационной структурой, должен реализовывать интерфейс ru.runa.wfe.extension.OrgFunction.

                                         Интерфейс содержит один метод

                                         List<? extends Executor> getExecutors(Object... parameters)
                                         Этот метод должен возвращать список исполнителей.

                                         В бизнес-процессе обработчик функции над оргструктурой используются при определении Ролей-Дорожек: указывается внутри тега swimlane, в теле тега <assignment>.В качестве параметра class тега <assignment> указывается класс-обработчик для инициализации swimlane: ru.runa.wfe.extension.AssignmentHandler. Внутри тега <assignment> содержится конфигурация для этого класса, которая представляет собой имя класса-наследника интерфейса OrgFunction и список параметров в скобках. В качестве параметра может выступать конкретное значение или имя переменной бизнес процесса в фигурных скобках, перед которым стоит значок $

                                         Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                                         Если есть планы по использованию функции в подсистеме замещений - её можно зарегистрировать в substitutions.xml.

                                         # Как написать критерий замещения
                                         Критерии замещения в системе применяются в правилах замещения. Класс, соответствующий критерию замещения, должен наследоваться от ru.runa.wfe.ss.SubstitutionCriteria.

                                         Для создания на основе него конечных критериев замещения с конфигурациями - его нужно зарегистрировать в substitution.criterias.xml.

                                         Как реализовать класс-формат для переменных бизнес-процесса
                                         См. соответствующий раздел в руководстве по работе с переменными.

                                         # Как реализовать валидатор переменных
                                         Классы, расширяющие абстрактный класс ru.runa.wfe.validation.FieldValidator, в системе применяются для проверки переменных при выполнении задания или старте процесса.

                                         Пример:

                                         public class OvertimeWorkRequestTimeCheck extends FieldValidator {
                                            @Override
                                            public void validate() {
                                                Date date = (Date) getFieldValue();
                                                if (date == null) {
                                                    return;
                                                }
                                                boolean testMode = getVariableProvider().getValueNotNull(boolean.class, "тестовый режим");
                                                if (testMode) {
                                                    return;
                                                }
                                                Calendar calendar = CalendarUtil.dateToCalendar(date);
                                                if (calendar.before(Calendar.getInstance())) {
                                                    addError("Заявка не может быть оформлена задним числом");
                                                    return;
                                                }
                                                CalendarUtil.setTimeFromCalendar(calendar, DemoProperties.getOvertimeWorkRequestMaximumStartTime());
                                                Utils.adjustCalendarForHolidaysInOvertimwWork(calendar);
                                                if (calendar.before(Calendar.getInstance())) {
                                                    addError("Заявка на этот день не может быть подана, время подачи истекло " + CalendarUtil.formatDateTime(calendar));
                                                }
                                            }
                                         }

                                         Связь между Средой разработки и сервером осуществляется по имени валидатора, регистрация требуется на стороне сервера в файле validators.xml, а в среде разработки - в plugin.xml.

                                         # Как реализовать FreeMarker тег для формы
                                         FreemarkerForms#Components

                                         # Как реализовать Ajax команду
                                         Классы, расширяющие абстрактный класс ru.runa.wfe.commons.web.JsonAjaxCommand, (или реализующие ru.runa.wfe.commons.web.AjaxCommand) в системе применяются для доступа к функциональности сервера из JavaScript, например при отображении форм задания.

                                         Регистрация команды происходит любым из двух способов:

                                         в файле ajax.commands.xml, ей присваивается определенное имя
                                         в контексте приложения, именем является id spring-бина
                                         Затем по этому имени её можно выполнить используя JavaScript.

                                         Пример команды

                                         public class GetOrganizationNamesCommand extends JsonAjaxCommand {
                                            @Autowired
                                            private OrganizationDAO organizationDAO;
                                            @Override
                                            protected JSONAware execute(User user, HttpServletRequest request) throws Exception {
                                                String term = request.getParameter("term");
                                                if (term == null) {
                                                    term = "";
                                                }
                                                List<Organization> organizations = organizationDAO.getAll();
                                                JSONArray array = new JSONArray();
                                                for (Organization organization : organizations) {
                                                    if (organization.getName().startsWith(term)) {
                                                        array.add(organization.getName());
                                                    }
                                                }
                                                return array;
                                            }
                                         }
                                         Регистрация в wfe.custom.ajax.commands.xml

                                         <?xml version="1.0" encoding="UTF-8" ?>
                                         <configuration xmlns="http://runa.ru/xml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://runa.ru/xml">
                                          <command name="getOrganizationNames" class="ru.runa.rkdemo.web.ajax.GetOrganizationNamesCommand" />
                                         </configuration>
                                         Её использование со скрипта формы (autocomplete input)

                                         $(document).ready(function() {
                                          $('#editLinkedLists').on("onRowAdded", function(event, rowIndex) {
                                           $("input[name='названия организаций["+rowIndex+"]']").autocomplete( {
                                            delay: 300,
                                            minLength: 0,
                                            source: "/wfe/ajaxcmd?command=getOrganizationNames"
                                           });
                                           $("input[name='названия организаций["+rowIndex+"]']").focus(function() {
                                            $(this).autocomplete("search", $(this).val());
                                           });
                                          });
                                         });Введение
                                            # Основные компоненты и используемые технологии
                                            Для WF–системы была выбрана следующая общая архитектура (в целом соответствует архитектуре, предлагаемой коалицией WfMC):

                                            Компоненты системы:

                                            Ядро системы
                                            Содержит набор определений бизнес-процессов
                                            Содержит набор выполняющихся экземпляров бизнес–процессов
                                            Компонент, "назначающий" исполнителей для действий
                                            Клиент
                                            Список заданий (набор графических форм, содержит очереди поступивших работ, сортировки и фильтры)
                                            Проигрыватель форм (отображает формы, разработанные в Среде разработки)
                                            Административный интерфейс
                                            Показывает состояния процессов, позволяет фильтровать и останавливать процессы
                                            Позволяет загружать-выгружать процессы
                                            Позволяет заводить-удалять пользователей
                                            Позволяет задавать различные права
                                            Редактор назначения заместителей
                                            Среда разработки
                                            Конструктор графических форм
                                            Бот станции, содержащие ботов (Боты - приложения специального вида, которые также как и обычные пользователи могут выполнять задания)
                                            Подсистема управления правами доступа (авторизация и аутентификация)
                                            # Платформа программирования и используемые программные средства
                                            В качестве платформы программирования используется J2EE.

                                            Используемые программные средства:

                                            Сервер приложений - JBOSS (http://www.jboss.org).
                                            Среда разработки - любая, например Eclipse от IBM (http://www.eclipse.org).
                                            Система контроля версий - git
                                            Сборщик приложений – maven.
                                            Сервер баз данных – поддерживаются сервера БД:
                                            MS SQL Server (http://www.microsoft.com/sql/evaluation/default.mspx)
                                            HSQL (http://hsqldb.org)
                                            Oracle (http://www.oracle.com)
                                            PostgreSQL (http://postgresql.com)
                                            Операционная система — поддерживаются следующие ОС:
                                            Windows (Server 2000-2008, XP, Vista, 7)
                                            ALTLinux
                                            Mandriva Linux
                                            Fedora
                                            Debian/Ubuntu
                                            # Описание проектов
                                            Название проекта	Обязателен при сборке	Обязателен при работе	Зависимости	Описание
                                            wfe-alfresco	нет	нет	runawfe-app	Интеграция с Alfresco
                                            wfe-app	да	да	wfe-ear, wfe-cactus-it	Проект для организации сборки maven
                                            wfe-appserver	нет	нет	 ?	Не используется
                                            wfe-bots	да	да	wfe-service	Подсистема ботов
                                            wfe-cactus-it	да	нет	wfe-service	Интеграционные тесты
                                            wfe-core	да	да	-	Основные компоненты системы
                                            wfe-ear	да	да	wfe-service, wfe-bots, wfe-office, wfe-web	Проект для сборки runawfe.ear
                                            wfe-office	да	нет	wfe-core	Обработчики для работы с Word, Excel
                                            wfe-service	да	да	wfe-core	Сервисы (EJB + WebServices), представляющие собой публичное API приложения
                                            wfe-web	да	да	wfe-bots	Визуальная часть приложения
                                            wfe-webservice-client	нет	нет	 ?	Авто-генерации клиентской библиотеки на основе WSDL серверных сервисов. В нем же есть примеры использования веб-служб из Java клиента.
                                            # Описание слоев архитектуры системы
                                            Каждый компонент состоит из нескольких уровней (слоев).

                                            Список слоев:

                                            delegate
                                            service
                                            logic
                                            DAO
                                            hibernate
                                            # Слой Delegate
                                            Delegate-классы, реализующие сервисные интерфейсы представляют собой pattern проектирования BusinessDelegate, упрощающий доступ к серверному API системы. Клиентское приложение взаимодействует с системой только через Delegate-классы. Delegate-классы получаются посредством запроса фабрики Delegates, которая в зависимости от конфигурации возвращает нужную реализацию. Классы Delegate являются частью клиентского API.

                                            Список основных Delegate-классов:

                                            AuthenticationServiceDelegate – содержит методы для аутентификации пользователей в системе (с использованием логина/пароля, Kerberos и т.п.)
                                            AuthorizationServiceDelegate — содержит методы для работы с полномочиями пользователей (назначение полномочий, проверка на допустимость операции для пользователя и т.п.)
                                            BotServiceDelegate — содержит методы для работы с бот станциями и ботами
                                            ExecutorServiceDelegate — содержит методы для работы с исполнителями. Позволяет создавать/удалять/изменять исполнителей а так же включать их в группы
                                            ProfileServiceDelegate — содержит методы для работы с профайлам пользователей
                                            SubstitutionServiceDelegate — содержит методы для управления правилами замещения
                                            SystemServiceDelegate — содержит методы для входа/выхода пользователя в систему
                                            DefinitionServiceDelegate — содержит методы для работы с определениями процессов
                                            ExecutionServiceDelegate — содержит методы для работы с исполняемыми экземплярами процессов
                                            Все существующие в данный момент Delegate-классы реализуют требуемую функциональность при помощи технологии EJB.

                                            # Слой Service
                                            Слой service – это серверное API доступа к системе. Реализации Delegate интерфейсов обращаются именно к этому слою. Каждый Delegate работает с одним соответствующим классом Service. В настоящее время все разработанные service классы и интерфейсы ориентированы на EJB-технологию, однако в будущем возможны и другие реализации. Реализации классов Service являются Stateless Session Bean EJB, которые декларативно поддерживают транзакционность вызовов и запрашивают соответствующие классы из слоя Logic.

                                            Таким образом, классы Delegate – Service - Logic образуют как бы «транспорт» между клиентом и сервером.

                                            # Слой Logic
                                            Слой Logic – это реализация бизнес логики работы системы. Слой работает с классами слоя DAO для доступа к постоянному хранилищу.

                                            # Слой DAO
                                            Слой DAO – это интерфейсы и классы, обеспечивающие доступ к данным, находящимся в постоянном хранилище (базе данных). В настоящее время все DAO-классы системы реализованы при помощи ORM-средства Hibernate.

                                            # Использование Hibernate
                                            Hibernate – ORM (Object/Relational Mapping) средство. Отображает объектную архитектуру на реляционную структуру данных. Допускает настройку (не меняя разработанного кода) на большинство существующих серверов реляционных баз данных.

                                            Поддерживает работу с распределенными транзакциями, автоматически создает таблицы для новых классов и т.д. Вся работа с данными внутри системы ведется только через Hibernate.

                                            Все компоненты, предоставляющие клиентское API построены с использованием описанных выше слоев. В целях оптимизации в некоторых компонентах применяется кеширование, которое может встречаться на уровне logic или DAO. Основная функциональность по управлению кешами находится в классах CachingLogic, CacheInterceptor и классах соответствующих кешей. Изменения в кешируемых объектах перехватываются и сообщаются посредством CachingLogic всем подписавшимся на изменения классам кешей. Транзакция, изменяющая кеш, считается закрытой по окончанию обработки ejb вызова.

                                            # Обновление базы данных
                                            см. описание системы патчей.

                                            # API
                                            Система представляет API для интеграции с другими системами:

                                            # Java API
                                            Реализация (снизу вверх): БД - Hibernate3 - EJB3

                                            Документацию можно смотреть в исходном коде (javadocs в *Service.java).

                                            # WebServices API
                                            Реализация (снизу вверх): БД - Hibernate3 - JAX-WS

                                            Документация: WebServicesDeveloperGuide

                                            # Scripting API
                                            Реализация (снизу вверх): БД - Hibernate3 - XML Script

                                            Документация: AdminScriptGuide

                                            # Процесс сборки из исходного кода
                                            Исходный код системы доступен в открытом репозитории на github.

                                            Сервер можно собирать как средствами maven используя командную строку, так и используя среду Eclipse IDE.

                                            В результате сборки будет сформирован runawfe.ear, который теоретически можно запустить на любом сервере приложений. Начиная с версии 4.3.0 введена поддержка JAVA версии 8, и отказ от JAVA 6. В дальнейшем планируется отказ от java7, поэтому рекомендуется использовать сервер приложений wildfly.

                                            # Процесс сборки на примере Eclipse IDE
                                            # Необходимое программное обеспечение для сборки
                                            В отличие от Среды разработки для сборки сервера можно использовать Eclipse IDE любой версии и редакции.

                                            установите плагин m2eclipse
                                            используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу: http://maven.apache.org/
                                            добавьте путь к Apache Maven директории bin в переменную окружения Path
                                            # Импорт проектов
                                            Импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server.

                                            Eclipse srv proj.png

                                            # Установка maven артефактов
                                            Выполните

                                            ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                                            ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                                            или другим способом установите артефакты в локальный репозиторий

                                            # Сборка
                                            Заведите конфигурацию запуска на основе maven как показано на рисунке

                                            Maven.build.configuration.png

                                            Запустите конфигурацию.

                                            Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\eclipse-workspace\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"

                                            # Сборка из командной строки
                                            используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу http://maven.apache.org/
                                            добавьте путь к Apache Maven директории bin в переменную окружения Path
                                            импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server
                                            выполните обновление зависимостей
                                            ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                                            ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                                            откройте командную строку
                                            перейдите в директорию ${wfe}/wfe-app/
                                            выполните команду для сборки
                                            mvn clean package -Dmaven.test.skip=true
                                            Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"


                                            Для установки артефактов в локальный репозиторий используйте команду

                                            mvn clean install -Dmaven.test.skip=true
                                            # Использование ear на сервере приложений
                                            cкачайте текущую версию RunaWFE в виде файл-архива исполняемых java файлов runawfe-wildfly-java8-*.zip (на базе wildfly, java8)
                                            распакуйте архив
                                            обновите runawfe.ear на версию полученную в результате сборки
                                            # Расширение функциональности
                                            # Точки расширения системы
                                            Обработчики позволяют исполнить код в процессах (элементы "Обработчик", "Задача сценария") и ботах
                                            Форматы переменных определяют тип переменных и правила преобразования значений к текстовому представлению и обратно
                                            Организационные функции используются при назначении ролей и в правилах замещения для определения заместителя
                                            Критерии замещения используются в подсистеме замещения для определения заместителя при построении списка заданий
                                            Валидаторы обеспечивают проверку переменных при выполнении задания (в т.ч. введенные значения форм)
                                            Freemarker теги форм генерируют html код для отображения на форме
                                            Ajax команды предоставляют доступ к функциональности сервера из JavaScript
                                            # Процесс разработки расширений
                                            Создайте новый java-проект и подключите необходимые зависимости (wfe-core, wfe-service).

                                            Реализуйте в нем требуемые расширения и соберите его в виде jar-файла.

                                            Замечание. Использование maven облегчит процесс управления зависимостями.

                                            Разместить собранный jar на сервере вы можете:

                                            положив его в runawfe.ear!/lib
                                            положив его в директорию deploy (только для jboss4)
                                            положив его в ${jboss.server.base.dir}/wfe.custom (только для jboss7)
                                            положив его в ${jboss.server.base.dir}/${jboss.server.name}/wfe.custom (только для jboss4)
                                            # Обработчики
                                            Обработчик в процессе – компонент процесса (элементы "Обработчик", "Задача сценария"), использующийся для выполнения каких-либо действий при возникновении определенных событий (проход по определенному переходу в процессе, приход или уход управления из узла и т.п.).

                                            Обработчик должен реализовывать интерфейс ru.runa.wfe.extension.ActionHandler. Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов Spring контекста (например с помощью аннотации @Autowired).

                                            При написании нового обработчика рекомендуется наследовать его от абстрактного класса ru.runa.wfe.extension.handler.CommonHandler или ru.runa.wfe.extension.handler.CommonParamBasedHandler. В методе setConfiguration обработчик должен запомнить свои параметры (если обработчик их ожидает), а в методе execute происходит непосредственная обработка и выполнение требуемых действий.

                                            В случае, если при выполнении обработчика произошла ошибка, произойдет откат транзакции и состояние процесса будет возвращено к заданию, исполнение которого повлекло вызов обработчика. В интерфейсе обработчика для бота ru.runa.wfe.extension.TaskHandler предусмотрен метод onRollback для работы с не-транзакционными ресурсами.

                                            Эти обработчики удобно использовать для простых операций (например для отправки оповещений в виде SMS-сообщений если процесс попал в определенное состояние). Но у них есть несколько ограничений. Прежде всего у них нет соответствующего объекта контекста безопасности (security context). Это означает, что в них нельзя выполнять защищенные методы (запуск процессов, выполнение задач, создание пользователей и т.п.) Ошибочным решением в них будет блокирование выполнения процесса (например с Thread::Sleep(...)). Например, если в обработчике отправляется e-mail, а SMTP сервер недоступен, обработчику нельзя "задерживать" свое выполнение.

                                            Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                                            # Специфика обработчиков для ботов
                                            Бот - это сокращение от робот. В системе боты - это особый тип исполнителей. Система не отличает ботов от людей. У каждого бота есть свои права на вход в систему, он периодически просыпается, проверяет свой список задачи и выполняет обнаруженные там задачи.

                                            Каждая задача бота обрабатывается при помощи соответствующего обработчика. Чтобы написать новый обработчик нужно реализовать интерфейс ru.runa.wfe.extension.TaskHandler.

                                            Обратите внимание, что этот вид обработчиков выполняется в контексте безопасности (security context) пользователя-бота, и здесь может выполнятся любая операция (если у бота есть на это права).

                                            Обработчики задач ботов могут блокировать выполнение процесса.

                                            Например, обработчик задач, отправляющий e-mail может блокировать выполнение бизнес процесса до тех пор, пока обработчик не удостоверится, что SMTP сервер принял сообщение для последующей доставки.

                                            Обработчики задач вызываются периодически, когда боты проверяют свои списки задач.

                                            # Специфика обработчика для элемента ветвление
                                            Обработчик для Decision является java-классом, реализующим интерфейс ru.runa.wfe.extension.DecisionHandler. Интерфейс содержит один метод decide(ExecutionContext executionContext), который возвращает имя выбранного перехода (одного из выходящих из данного ветвления). Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов контекста спринга (например с помощью аннотации @Autowired).

                                            Обработчик принимает ExecutionContext в качестве входящего параметра и должен сделать выбор перехода исходя из значений переменных бизнес процесса и условий, указанных в конфигурации обработчика. Точно также как обработчики действия (action handler) обработчики выбора (decision handlers) не могут использовать защищенные (secured) методы, не могут обрабатывать ошибки и откладывать выбор перехода до лучших времен.

                                            По умолчанию используется ru.runa.wfe.extension.decision.GroovyDecisionHandler.

                                            # Использование ru.runa.wfe.extension.handler.CommonParamBasedHandler в качестве базового класса
                                            Этот класс инкапсулирует в себе парсинг XML конфигурации определенного формата. Его удобно использовать если обработчик имеет фиксированное число параметров. Пример конфигурации:

                                            <?xml version="1.0" encoding="UTF-8"?>
                                            <config>
                                             <input>
                                               <param name="typeName" variable="тип отсутствия" />
                                               <param name="employee" variable="сотрудник" />
                                               <param name="requester" variable="подавший заявку" />
                                               <param name="from" variable="дата с" />
                                               <param name="to" variable="дата по" />
                                               <param name="cause" variable="причина" />
                                               <param name="comment" variable="комментарий" />
                                               <param name="confirmation" variable="дата подтверждения" />
                                               <param name="firmCode" value="111" />
                                               <param name="firmPositionCode" variable="код должности" />
                                               <param name="firmDepartmentCode" variable="код подразделения" />
                                             </input>
                                             <output>
                                               <param name="uuid" variable="идентификатор объекта" />
                                             </output>
                                            </config>
                                            Использование обработчика Groovy
                                            См. соответствующий раздел в руководстве по работе с Groovy.

                                            # Как написать функцию над организационной структурой
                                            Функции над организационной структурой в системе применяются, например, при инициализации Ролей-Дорожек и в правилах замещения.

                                            Класс, соответствующий функции над организационной структурой, должен реализовывать интерфейс ru.runa.wfe.extension.OrgFunction.

                                            Интерфейс содержит один метод

                                            List<? extends Executor> getExecutors(Object... parameters)
                                            Этот метод должен возвращать список исполнителей.

                                            В бизнес-процессе обработчик функции над оргструктурой используются при определении Ролей-Дорожек: указывается внутри тега swimlane, в теле тега <assignment>.В качестве параметра class тега <assignment> указывается класс-обработчик для инициализации swimlane: ru.runa.wfe.extension.AssignmentHandler. Внутри тега <assignment> содержится конфигурация для этого класса, которая представляет собой имя класса-наследника интерфейса OrgFunction и список параметров в скобках. В качестве параметра может выступать конкретное значение или имя переменной бизнес процесса в фигурных скобках, перед которым стоит значок $

                                            Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                                            Если есть планы по использованию функции в подсистеме замещений - её можно зарегистрировать в substitutions.xml.

                                            # Как написать критерий замещения
                                            Критерии замещения в системе применяются в правилах замещения. Класс, соответствующий критерию замещения, должен наследоваться от ru.runa.wfe.ss.SubstitutionCriteria.

                                            Для создания на основе него конечных критериев замещения с конфигурациями - его нужно зарегистрировать в substitution.criterias.xml.

                                            Как реализовать класс-формат для переменных бизнес-процесса
                                            См. соответствующий раздел в руководстве по работе с переменными.

                                            # Как реализовать валидатор переменных
                                            Классы, расширяющие абстрактный класс ru.runa.wfe.validation.FieldValidator, в системе применяются для проверки переменных при выполнении задания или старте процесса.

                                            Пример:

                                            public class OvertimeWorkRequestTimeCheck extends FieldValidator {
                                               @Override
                                               public void validate() {
                                                   Date date = (Date) getFieldValue();
                                                   if (date == null) {
                                                       return;
                                                   }
                                                   boolean testMode = getVariableProvider().getValueNotNull(boolean.class, "тестовый режим");
                                                   if (testMode) {
                                                       return;
                                                   }
                                                   Calendar calendar = CalendarUtil.dateToCalendar(date);
                                                   if (calendar.before(Calendar.getInstance())) {
                                                       addError("Заявка не может быть оформлена задним числом");
                                                       return;
                                                   }
                                                   CalendarUtil.setTimeFromCalendar(calendar, DemoProperties.getOvertimeWorkRequestMaximumStartTime());
                                                   Utils.adjustCalendarForHolidaysInOvertimwWork(calendar);
                                                   if (calendar.before(Calendar.getInstance())) {
                                                       addError("Заявка на этот день не может быть подана, время подачи истекло " + CalendarUtil.formatDateTime(calendar));
                                                   }
                                               }
                                            }

                                            Связь между Средой разработки и сервером осуществляется по имени валидатора, регистрация требуется на стороне сервера в файле validators.xml, а в среде разработки - в plugin.xml.

                                            # Как реализовать FreeMarker тег для формы
                                            FreemarkerForms#Components

                                            # Как реализовать Ajax команду
                                            Классы, расширяющие абстрактный класс ru.runa.wfe.commons.web.JsonAjaxCommand, (или реализующие ru.runa.wfe.commons.web.AjaxCommand) в системе применяются для доступа к функциональности сервера из JavaScript, например при отображении форм задания.

                                            Регистрация команды происходит любым из двух способов:

                                            в файле ajax.commands.xml, ей присваивается определенное имя
                                            в контексте приложения, именем является id spring-бина
                                            Затем по этому имени её можно выполнить используя JavaScript.

                                            Пример команды

                                            public class GetOrganizationNamesCommand extends JsonAjaxCommand {
                                               @Autowired
                                               private OrganizationDAO organizationDAO;
                                               @Override
                                               protected JSONAware execute(User user, HttpServletRequest request) throws Exception {
                                                   String term = request.getParameter("term");
                                                   if (term == null) {
                                                       term = "";
                                                   }
                                                   List<Organization> organizations = organizationDAO.getAll();
                                                   JSONArray array = new JSONArray();
                                                   for (Organization organization : organizations) {
                                                       if (organization.getName().startsWith(term)) {
                                                           array.add(organization.getName());
                                                       }
                                                   }
                                                   return array;
                                               }
                                            }
                                            Регистрация в wfe.custom.ajax.commands.xml

                                            <?xml version="1.0" encoding="UTF-8" ?>
                                            <configuration xmlns="http://runa.ru/xml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://runa.ru/xml">
                                             <command name="getOrganizationNames" class="ru.runa.rkdemo.web.ajax.GetOrganizationNamesCommand" />
                                            </configuration>
                                            Её использование со скрипта формы (autocomplete input)

                                            $(document).ready(function() {
                                             $('#editLinkedLists').on("onRowAdded", function(event, rowIndex) {
                                              $("input[name='названия организаций["+rowIndex+"]']").autocomplete( {
                                               delay: 300,
                                               minLength: 0,
                                               source: "/wfe/ajaxcmd?command=getOrganizationNames"
                                              });
                                              $("input[name='названия организаций["+rowIndex+"]']").focus(function() {
                                               $(this).autocomplete("search", $(this).val());
                                              });
                                             });
                                            });Введение
                                               # Основные компоненты и используемые технологии
                                               Для WF–системы была выбрана следующая общая архитектура (в целом соответствует архитектуре, предлагаемой коалицией WfMC):

                                               Компоненты системы:

                                               Ядро системы
                                               Содержит набор определений бизнес-процессов
                                               Содержит набор выполняющихся экземпляров бизнес–процессов
                                               Компонент, "назначающий" исполнителей для действий
                                               Клиент
                                               Список заданий (набор графических форм, содержит очереди поступивших работ, сортировки и фильтры)
                                               Проигрыватель форм (отображает формы, разработанные в Среде разработки)
                                               Административный интерфейс
                                               Показывает состояния процессов, позволяет фильтровать и останавливать процессы
                                               Позволяет загружать-выгружать процессы
                                               Позволяет заводить-удалять пользователей
                                               Позволяет задавать различные права
                                               Редактор назначения заместителей
                                               Среда разработки
                                               Конструктор графических форм
                                               Бот станции, содержащие ботов (Боты - приложения специального вида, которые также как и обычные пользователи могут выполнять задания)
                                               Подсистема управления правами доступа (авторизация и аутентификация)
                                               # Платформа программирования и используемые программные средства
                                               В качестве платформы программирования используется J2EE.

                                               Используемые программные средства:

                                               Сервер приложений - JBOSS (http://www.jboss.org).
                                               Среда разработки - любая, например Eclipse от IBM (http://www.eclipse.org).
                                               Система контроля версий - git
                                               Сборщик приложений – maven.
                                               Сервер баз данных – поддерживаются сервера БД:
                                               MS SQL Server (http://www.microsoft.com/sql/evaluation/default.mspx)
                                               HSQL (http://hsqldb.org)
                                               Oracle (http://www.oracle.com)
                                               PostgreSQL (http://postgresql.com)
                                               Операционная система — поддерживаются следующие ОС:
                                               Windows (Server 2000-2008, XP, Vista, 7)
                                               ALTLinux
                                               Mandriva Linux
                                               Fedora
                                               Debian/Ubuntu
                                               # Описание проектов
                                               Название проекта	Обязателен при сборке	Обязателен при работе	Зависимости	Описание
                                               wfe-alfresco	нет	нет	runawfe-app	Интеграция с Alfresco
                                               wfe-app	да	да	wfe-ear, wfe-cactus-it	Проект для организации сборки maven
                                               wfe-appserver	нет	нет	 ?	Не используется
                                               wfe-bots	да	да	wfe-service	Подсистема ботов
                                               wfe-cactus-it	да	нет	wfe-service	Интеграционные тесты
                                               wfe-core	да	да	-	Основные компоненты системы
                                               wfe-ear	да	да	wfe-service, wfe-bots, wfe-office, wfe-web	Проект для сборки runawfe.ear
                                               wfe-office	да	нет	wfe-core	Обработчики для работы с Word, Excel
                                               wfe-service	да	да	wfe-core	Сервисы (EJB + WebServices), представляющие собой публичное API приложения
                                               wfe-web	да	да	wfe-bots	Визуальная часть приложения
                                               wfe-webservice-client	нет	нет	 ?	Авто-генерации клиентской библиотеки на основе WSDL серверных сервисов. В нем же есть примеры использования веб-служб из Java клиента.
                                               # Описание слоев архитектуры системы
                                               Каждый компонент состоит из нескольких уровней (слоев).

                                               Список слоев:

                                               delegate
                                               service
                                               logic
                                               DAO
                                               hibernate
                                               # Слой Delegate
                                               Delegate-классы, реализующие сервисные интерфейсы представляют собой pattern проектирования BusinessDelegate, упрощающий доступ к серверному API системы. Клиентское приложение взаимодействует с системой только через Delegate-классы. Delegate-классы получаются посредством запроса фабрики Delegates, которая в зависимости от конфигурации возвращает нужную реализацию. Классы Delegate являются частью клиентского API.

                                               Список основных Delegate-классов:

                                               AuthenticationServiceDelegate – содержит методы для аутентификации пользователей в системе (с использованием логина/пароля, Kerberos и т.п.)
                                               AuthorizationServiceDelegate — содержит методы для работы с полномочиями пользователей (назначение полномочий, проверка на допустимость операции для пользователя и т.п.)
                                               BotServiceDelegate — содержит методы для работы с бот станциями и ботами
                                               ExecutorServiceDelegate — содержит методы для работы с исполнителями. Позволяет создавать/удалять/изменять исполнителей а так же включать их в группы
                                               ProfileServiceDelegate — содержит методы для работы с профайлам пользователей
                                               SubstitutionServiceDelegate — содержит методы для управления правилами замещения
                                               SystemServiceDelegate — содержит методы для входа/выхода пользователя в систему
                                               DefinitionServiceDelegate — содержит методы для работы с определениями процессов
                                               ExecutionServiceDelegate — содержит методы для работы с исполняемыми экземплярами процессов
                                               Все существующие в данный момент Delegate-классы реализуют требуемую функциональность при помощи технологии EJB.

                                               # Слой Service
                                               Слой service – это серверное API доступа к системе. Реализации Delegate интерфейсов обращаются именно к этому слою. Каждый Delegate работает с одним соответствующим классом Service. В настоящее время все разработанные service классы и интерфейсы ориентированы на EJB-технологию, однако в будущем возможны и другие реализации. Реализации классов Service являются Stateless Session Bean EJB, которые декларативно поддерживают транзакционность вызовов и запрашивают соответствующие классы из слоя Logic.

                                               Таким образом, классы Delegate – Service - Logic образуют как бы «транспорт» между клиентом и сервером.

                                               # Слой Logic
                                               Слой Logic – это реализация бизнес логики работы системы. Слой работает с классами слоя DAO для доступа к постоянному хранилищу.

                                               # Слой DAO
                                               Слой DAO – это интерфейсы и классы, обеспечивающие доступ к данным, находящимся в постоянном хранилище (базе данных). В настоящее время все DAO-классы системы реализованы при помощи ORM-средства Hibernate.

                                               # Использование Hibernate
                                               Hibernate – ORM (Object/Relational Mapping) средство. Отображает объектную архитектуру на реляционную структуру данных. Допускает настройку (не меняя разработанного кода) на большинство существующих серверов реляционных баз данных.

                                               Поддерживает работу с распределенными транзакциями, автоматически создает таблицы для новых классов и т.д. Вся работа с данными внутри системы ведется только через Hibernate.

                                               Все компоненты, предоставляющие клиентское API построены с использованием описанных выше слоев. В целях оптимизации в некоторых компонентах применяется кеширование, которое может встречаться на уровне logic или DAO. Основная функциональность по управлению кешами находится в классах CachingLogic, CacheInterceptor и классах соответствующих кешей. Изменения в кешируемых объектах перехватываются и сообщаются посредством CachingLogic всем подписавшимся на изменения классам кешей. Транзакция, изменяющая кеш, считается закрытой по окончанию обработки ejb вызова.

                                               # Обновление базы данных
                                               см. описание системы патчей.

                                               # API
                                               Система представляет API для интеграции с другими системами:

                                               # Java API
                                               Реализация (снизу вверх): БД - Hibernate3 - EJB3

                                               Документацию можно смотреть в исходном коде (javadocs в *Service.java).

                                               # WebServices API
                                               Реализация (снизу вверх): БД - Hibernate3 - JAX-WS

                                               Документация: WebServicesDeveloperGuide

                                               # Scripting API
                                               Реализация (снизу вверх): БД - Hibernate3 - XML Script

                                               Документация: AdminScriptGuide

                                               # Процесс сборки из исходного кода
                                               Исходный код системы доступен в открытом репозитории на github.

                                               Сервер можно собирать как средствами maven используя командную строку, так и используя среду Eclipse IDE.

                                               В результате сборки будет сформирован runawfe.ear, который теоретически можно запустить на любом сервере приложений. Начиная с версии 4.3.0 введена поддержка JAVA версии 8, и отказ от JAVA 6. В дальнейшем планируется отказ от java7, поэтому рекомендуется использовать сервер приложений wildfly.

                                               # Процесс сборки на примере Eclipse IDE
                                               # Необходимое программное обеспечение для сборки
                                               В отличие от Среды разработки для сборки сервера можно использовать Eclipse IDE любой версии и редакции.

                                               установите плагин m2eclipse
                                               используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу: http://maven.apache.org/
                                               добавьте путь к Apache Maven директории bin в переменную окружения Path
                                               # Импорт проектов
                                               Импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server.

                                               Eclipse srv proj.png

                                               # Установка maven артефактов
                                               Выполните

                                               ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                                               ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                                               или другим способом установите артефакты в локальный репозиторий

                                               # Сборка
                                               Заведите конфигурацию запуска на основе maven как показано на рисунке

                                               Maven.build.configuration.png

                                               Запустите конфигурацию.

                                               Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\eclipse-workspace\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"

                                               # Сборка из командной строки
                                               используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу http://maven.apache.org/
                                               добавьте путь к Apache Maven директории bin в переменную окружения Path
                                               импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server
                                               выполните обновление зависимостей
                                               ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                                               ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                                               откройте командную строку
                                               перейдите в директорию ${wfe}/wfe-app/
                                               выполните команду для сборки
                                               mvn clean package -Dmaven.test.skip=true
                                               Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"


                                               Для установки артефактов в локальный репозиторий используйте команду

                                               mvn clean install -Dmaven.test.skip=true
                                               # Использование ear на сервере приложений
                                               cкачайте текущую версию RunaWFE в виде файл-архива исполняемых java файлов runawfe-wildfly-java8-*.zip (на базе wildfly, java8)
                                               распакуйте архив
                                               обновите runawfe.ear на версию полученную в результате сборки
                                               # Расширение функциональности
                                               # Точки расширения системы
                                               Обработчики позволяют исполнить код в процессах (элементы "Обработчик", "Задача сценария") и ботах
                                               Форматы переменных определяют тип переменных и правила преобразования значений к текстовому представлению и обратно
                                               Организационные функции используются при назначении ролей и в правилах замещения для определения заместителя
                                               Критерии замещения используются в подсистеме замещения для определения заместителя при построении списка заданий
                                               Валидаторы обеспечивают проверку переменных при выполнении задания (в т.ч. введенные значения форм)
                                               Freemarker теги форм генерируют html код для отображения на форме
                                               Ajax команды предоставляют доступ к функциональности сервера из JavaScript
                                               # Процесс разработки расширений
                                               Создайте новый java-проект и подключите необходимые зависимости (wfe-core, wfe-service).

                                               Реализуйте в нем требуемые расширения и соберите его в виде jar-файла.

                                               Замечание. Использование maven облегчит процесс управления зависимостями.

                                               Разместить собранный jar на сервере вы можете:

                                               положив его в runawfe.ear!/lib
                                               положив его в директорию deploy (только для jboss4)
                                               положив его в ${jboss.server.base.dir}/wfe.custom (только для jboss7)
                                               положив его в ${jboss.server.base.dir}/${jboss.server.name}/wfe.custom (только для jboss4)
                                               # Обработчики
                                               Обработчик в процессе – компонент процесса (элементы "Обработчик", "Задача сценария"), использующийся для выполнения каких-либо действий при возникновении определенных событий (проход по определенному переходу в процессе, приход или уход управления из узла и т.п.).

                                               Обработчик должен реализовывать интерфейс ru.runa.wfe.extension.ActionHandler. Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов Spring контекста (например с помощью аннотации @Autowired).

                                               При написании нового обработчика рекомендуется наследовать его от абстрактного класса ru.runa.wfe.extension.handler.CommonHandler или ru.runa.wfe.extension.handler.CommonParamBasedHandler. В методе setConfiguration обработчик должен запомнить свои параметры (если обработчик их ожидает), а в методе execute происходит непосредственная обработка и выполнение требуемых действий.

                                               В случае, если при выполнении обработчика произошла ошибка, произойдет откат транзакции и состояние процесса будет возвращено к заданию, исполнение которого повлекло вызов обработчика. В интерфейсе обработчика для бота ru.runa.wfe.extension.TaskHandler предусмотрен метод onRollback для работы с не-транзакционными ресурсами.

                                               Эти обработчики удобно использовать для простых операций (например для отправки оповещений в виде SMS-сообщений если процесс попал в определенное состояние). Но у них есть несколько ограничений. Прежде всего у них нет соответствующего объекта контекста безопасности (security context). Это означает, что в них нельзя выполнять защищенные методы (запуск процессов, выполнение задач, создание пользователей и т.п.) Ошибочным решением в них будет блокирование выполнения процесса (например с Thread::Sleep(...)). Например, если в обработчике отправляется e-mail, а SMTP сервер недоступен, обработчику нельзя "задерживать" свое выполнение.

                                               Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                                               # Специфика обработчиков для ботов
                                               Бот - это сокращение от робот. В системе боты - это особый тип исполнителей. Система не отличает ботов от людей. У каждого бота есть свои права на вход в систему, он периодически просыпается, проверяет свой список задачи и выполняет обнаруженные там задачи.

                                               Каждая задача бота обрабатывается при помощи соответствующего обработчика. Чтобы написать новый обработчик нужно реализовать интерфейс ru.runa.wfe.extension.TaskHandler.

                                               Обратите внимание, что этот вид обработчиков выполняется в контексте безопасности (security context) пользователя-бота, и здесь может выполнятся любая операция (если у бота есть на это права).

                                               Обработчики задач ботов могут блокировать выполнение процесса.

                                               Например, обработчик задач, отправляющий e-mail может блокировать выполнение бизнес процесса до тех пор, пока обработчик не удостоверится, что SMTP сервер принял сообщение для последующей доставки.

                                               Обработчики задач вызываются периодически, когда боты проверяют свои списки задач.

                                               # Специфика обработчика для элемента ветвление
                                               Обработчик для Decision является java-классом, реализующим интерфейс ru.runa.wfe.extension.DecisionHandler. Интерфейс содержит один метод decide(ExecutionContext executionContext), который возвращает имя выбранного перехода (одного из выходящих из данного ветвления). Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов контекста спринга (например с помощью аннотации @Autowired).

                                               Обработчик принимает ExecutionContext в качестве входящего параметра и должен сделать выбор перехода исходя из значений переменных бизнес процесса и условий, указанных в конфигурации обработчика. Точно также как обработчики действия (action handler) обработчики выбора (decision handlers) не могут использовать защищенные (secured) методы, не могут обрабатывать ошибки и откладывать выбор перехода до лучших времен.

                                               По умолчанию используется ru.runa.wfe.extension.decision.GroovyDecisionHandler.

                                               # Использование ru.runa.wfe.extension.handler.CommonParamBasedHandler в качестве базового класса
                                               Этот класс инкапсулирует в себе парсинг XML конфигурации определенного формата. Его удобно использовать если обработчик имеет фиксированное число параметров. Пример конфигурации:

                                               <?xml version="1.0" encoding="UTF-8"?>
                                               <config>
                                                <input>
                                                  <param name="typeName" variable="тип отсутствия" />
                                                  <param name="employee" variable="сотрудник" />
                                                  <param name="requester" variable="подавший заявку" />
                                                  <param name="from" variable="дата с" />
                                                  <param name="to" variable="дата по" />
                                                  <param name="cause" variable="причина" />
                                                  <param name="comment" variable="комментарий" />
                                                  <param name="confirmation" variable="дата подтверждения" />
                                                  <param name="firmCode" value="111" />
                                                  <param name="firmPositionCode" variable="код должности" />
                                                  <param name="firmDepartmentCode" variable="код подразделения" />
                                                </input>
                                                <output>
                                                  <param name="uuid" variable="идентификатор объекта" />
                                                </output>
                                               </config>
                                               Использование обработчика Groovy
                                               См. соответствующий раздел в руководстве по работе с Groovy.

                                               # Как написать функцию над организационной структурой
                                               Функции над организационной структурой в системе применяются, например, при инициализации Ролей-Дорожек и в правилах замещения.

                                               Класс, соответствующий функции над организационной структурой, должен реализовывать интерфейс ru.runa.wfe.extension.OrgFunction.

                                               Интерфейс содержит один метод

                                               List<? extends Executor> getExecutors(Object... parameters)
                                               Этот метод должен возвращать список исполнителей.

                                               В бизнес-процессе обработчик функции над оргструктурой используются при определении Ролей-Дорожек: указывается внутри тега swimlane, в теле тега <assignment>.В качестве параметра class тега <assignment> указывается класс-обработчик для инициализации swimlane: ru.runa.wfe.extension.AssignmentHandler. Внутри тега <assignment> содержится конфигурация для этого класса, которая представляет собой имя класса-наследника интерфейса OrgFunction и список параметров в скобках. В качестве параметра может выступать конкретное значение или имя переменной бизнес процесса в фигурных скобках, перед которым стоит значок $

                                               Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                                               Если есть планы по использованию функции в подсистеме замещений - её можно зарегистрировать в substitutions.xml.

                                               # Как написать критерий замещения
                                               Критерии замещения в системе применяются в правилах замещения. Класс, соответствующий критерию замещения, должен наследоваться от ru.runa.wfe.ss.SubstitutionCriteria.

                                               Для создания на основе него конечных критериев замещения с конфигурациями - его нужно зарегистрировать в substitution.criterias.xml.

                                               Как реализовать класс-формат для переменных бизнес-процесса
                                               См. соответствующий раздел в руководстве по работе с переменными.

                                               # Как реализовать валидатор переменных
                                               Классы, расширяющие абстрактный класс ru.runa.wfe.validation.FieldValidator, в системе применяются для проверки переменных при выполнении задания или старте процесса.

                                               Пример:

                                               public class OvertimeWorkRequestTimeCheck extends FieldValidator {
                                                  @Override
                                                  public void validate() {
                                                      Date date = (Date) getFieldValue();
                                                      if (date == null) {
                                                          return;
                                                      }
                                                      boolean testMode = getVariableProvider().getValueNotNull(boolean.class, "тестовый режим");
                                                      if (testMode) {
                                                          return;
                                                      }
                                                      Calendar calendar = CalendarUtil.dateToCalendar(date);
                                                      if (calendar.before(Calendar.getInstance())) {
                                                          addError("Заявка не может быть оформлена задним числом");
                                                          return;
                                                      }
                                                      CalendarUtil.setTimeFromCalendar(calendar, DemoProperties.getOvertimeWorkRequestMaximumStartTime());
                                                      Utils.adjustCalendarForHolidaysInOvertimwWork(calendar);
                                                      if (calendar.before(Calendar.getInstance())) {
                                                          addError("Заявка на этот день не может быть подана, время подачи истекло " + CalendarUtil.formatDateTime(calendar));
                                                      }
                                                  }
                                               }

                                               Связь между Средой разработки и сервером осуществляется по имени валидатора, регистрация требуется на стороне сервера в файле validators.xml, а в среде разработки - в plugin.xml.

                                               # Как реализовать FreeMarker тег для формы
                                               FreemarkerForms#Components

                                               # Как реализовать Ajax команду
                                               Классы, расширяющие абстрактный класс ru.runa.wfe.commons.web.JsonAjaxCommand, (или реализующие ru.runa.wfe.commons.web.AjaxCommand) в системе применяются для доступа к функциональности сервера из JavaScript, например при отображении форм задания.

                                               Регистрация команды происходит любым из двух способов:

                                               в файле ajax.commands.xml, ей присваивается определенное имя
                                               в контексте приложения, именем является id spring-бина
                                               Затем по этому имени её можно выполнить используя JavaScript.

                                               Пример команды

                                               public class GetOrganizationNamesCommand extends JsonAjaxCommand {
                                                  @Autowired
                                                  private OrganizationDAO organizationDAO;
                                                  @Override
                                                  protected JSONAware execute(User user, HttpServletRequest request) throws Exception {
                                                      String term = request.getParameter("term");
                                                      if (term == null) {
                                                          term = "";
                                                      }
                                                      List<Organization> organizations = organizationDAO.getAll();
                                                      JSONArray array = new JSONArray();
                                                      for (Organization organization : organizations) {
                                                          if (organization.getName().startsWith(term)) {
                                                              array.add(organization.getName());
                                                          }
                                                      }
                                                      return array;
                                                  }
                                               }
                                               Регистрация в wfe.custom.ajax.commands.xml

                                               <?xml version="1.0" encoding="UTF-8" ?>
                                               <configuration xmlns="http://runa.ru/xml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://runa.ru/xml">
                                                <command name="getOrganizationNames" class="ru.runa.rkdemo.web.ajax.GetOrganizationNamesCommand" />
                                               </configuration>
                                               Её использование со скрипта формы (autocomplete input)

                                               $(document).ready(function() {
                                                $('#editLinkedLists').on("onRowAdded", function(event, rowIndex) {
                                                 $("input[name='названия организаций["+rowIndex+"]']").autocomplete( {
                                                  delay: 300,
                                                  minLength: 0,
                                                  source: "/wfe/ajaxcmd?command=getOrganizationNames"
                                                 });
                                                 $("input[name='названия организаций["+rowIndex+"]']").focus(function() {
                                                  $(this).autocomplete("search", $(this).val());
                                                 });
                                                });
                                               });Введение
                                                  # Основные компоненты и используемые технологии
                                                  Для WF–системы была выбрана следующая общая архитектура (в целом соответствует архитектуре, предлагаемой коалицией WfMC):

                                                  Компоненты системы:

                                                  Ядро системы
                                                  Содержит набор определений бизнес-процессов
                                                  Содержит набор выполняющихся экземпляров бизнес–процессов
                                                  Компонент, "назначающий" исполнителей для действий
                                                  Клиент
                                                  Список заданий (набор графических форм, содержит очереди поступивших работ, сортировки и фильтры)
                                                  Проигрыватель форм (отображает формы, разработанные в Среде разработки)
                                                  Административный интерфейс
                                                  Показывает состояния процессов, позволяет фильтровать и останавливать процессы
                                                  Позволяет загружать-выгружать процессы
                                                  Позволяет заводить-удалять пользователей
                                                  Позволяет задавать различные права
                                                  Редактор назначения заместителей
                                                  Среда разработки
                                                  Конструктор графических форм
                                                  Бот станции, содержащие ботов (Боты - приложения специального вида, которые также как и обычные пользователи могут выполнять задания)
                                                  Подсистема управления правами доступа (авторизация и аутентификация)
                                                  # Платформа программирования и используемые программные средства
                                                  В качестве платформы программирования используется J2EE.

                                                  Используемые программные средства:

                                                  Сервер приложений - JBOSS (http://www.jboss.org).
                                                  Среда разработки - любая, например Eclipse от IBM (http://www.eclipse.org).
                                                  Система контроля версий - git
                                                  Сборщик приложений – maven.
                                                  Сервер баз данных – поддерживаются сервера БД:
                                                  MS SQL Server (http://www.microsoft.com/sql/evaluation/default.mspx)
                                                  HSQL (http://hsqldb.org)
                                                  Oracle (http://www.oracle.com)
                                                  PostgreSQL (http://postgresql.com)
                                                  Операционная система — поддерживаются следующие ОС:
                                                  Windows (Server 2000-2008, XP, Vista, 7)
                                                  ALTLinux
                                                  Mandriva Linux
                                                  Fedora
                                                  Debian/Ubuntu
                                                  # Описание проектов
                                                  Название проекта	Обязателен при сборке	Обязателен при работе	Зависимости	Описание
                                                  wfe-alfresco	нет	нет	runawfe-app	Интеграция с Alfresco
                                                  wfe-app	да	да	wfe-ear, wfe-cactus-it	Проект для организации сборки maven
                                                  wfe-appserver	нет	нет	 ?	Не используется
                                                  wfe-bots	да	да	wfe-service	Подсистема ботов
                                                  wfe-cactus-it	да	нет	wfe-service	Интеграционные тесты
                                                  wfe-core	да	да	-	Основные компоненты системы
                                                  wfe-ear	да	да	wfe-service, wfe-bots, wfe-office, wfe-web	Проект для сборки runawfe.ear
                                                  wfe-office	да	нет	wfe-core	Обработчики для работы с Word, Excel
                                                  wfe-service	да	да	wfe-core	Сервисы (EJB + WebServices), представляющие собой публичное API приложения
                                                  wfe-web	да	да	wfe-bots	Визуальная часть приложения
                                                  wfe-webservice-client	нет	нет	 ?	Авто-генерации клиентской библиотеки на основе WSDL серверных сервисов. В нем же есть примеры использования веб-служб из Java клиента.
                                                  # Описание слоев архитектуры системы
                                                  Каждый компонент состоит из нескольких уровней (слоев).

                                                  Список слоев:

                                                  delegate
                                                  service
                                                  logic
                                                  DAO
                                                  hibernate
                                                  # Слой Delegate
                                                  Delegate-классы, реализующие сервисные интерфейсы представляют собой pattern проектирования BusinessDelegate, упрощающий доступ к серверному API системы. Клиентское приложение взаимодействует с системой только через Delegate-классы. Delegate-классы получаются посредством запроса фабрики Delegates, которая в зависимости от конфигурации возвращает нужную реализацию. Классы Delegate являются частью клиентского API.

                                                  Список основных Delegate-классов:

                                                  AuthenticationServiceDelegate – содержит методы для аутентификации пользователей в системе (с использованием логина/пароля, Kerberos и т.п.)
                                                  AuthorizationServiceDelegate — содержит методы для работы с полномочиями пользователей (назначение полномочий, проверка на допустимость операции для пользователя и т.п.)
                                                  BotServiceDelegate — содержит методы для работы с бот станциями и ботами
                                                  ExecutorServiceDelegate — содержит методы для работы с исполнителями. Позволяет создавать/удалять/изменять исполнителей а так же включать их в группы
                                                  ProfileServiceDelegate — содержит методы для работы с профайлам пользователей
                                                  SubstitutionServiceDelegate — содержит методы для управления правилами замещения
                                                  SystemServiceDelegate — содержит методы для входа/выхода пользователя в систему
                                                  DefinitionServiceDelegate — содержит методы для работы с определениями процессов
                                                  ExecutionServiceDelegate — содержит методы для работы с исполняемыми экземплярами процессов
                                                  Все существующие в данный момент Delegate-классы реализуют требуемую функциональность при помощи технологии EJB.

                                                  # Слой Service
                                                  Слой service – это серверное API доступа к системе. Реализации Delegate интерфейсов обращаются именно к этому слою. Каждый Delegate работает с одним соответствующим классом Service. В настоящее время все разработанные service классы и интерфейсы ориентированы на EJB-технологию, однако в будущем возможны и другие реализации. Реализации классов Service являются Stateless Session Bean EJB, которые декларативно поддерживают транзакционность вызовов и запрашивают соответствующие классы из слоя Logic.

                                                  Таким образом, классы Delegate – Service - Logic образуют как бы «транспорт» между клиентом и сервером.

                                                  # Слой Logic
                                                  Слой Logic – это реализация бизнес логики работы системы. Слой работает с классами слоя DAO для доступа к постоянному хранилищу.

                                                  # Слой DAO
                                                  Слой DAO – это интерфейсы и классы, обеспечивающие доступ к данным, находящимся в постоянном хранилище (базе данных). В настоящее время все DAO-классы системы реализованы при помощи ORM-средства Hibernate.

                                                  # Использование Hibernate
                                                  Hibernate – ORM (Object/Relational Mapping) средство. Отображает объектную архитектуру на реляционную структуру данных. Допускает настройку (не меняя разработанного кода) на большинство существующих серверов реляционных баз данных.

                                                  Поддерживает работу с распределенными транзакциями, автоматически создает таблицы для новых классов и т.д. Вся работа с данными внутри системы ведется только через Hibernate.

                                                  Все компоненты, предоставляющие клиентское API построены с использованием описанных выше слоев. В целях оптимизации в некоторых компонентах применяется кеширование, которое может встречаться на уровне logic или DAO. Основная функциональность по управлению кешами находится в классах CachingLogic, CacheInterceptor и классах соответствующих кешей. Изменения в кешируемых объектах перехватываются и сообщаются посредством CachingLogic всем подписавшимся на изменения классам кешей. Транзакция, изменяющая кеш, считается закрытой по окончанию обработки ejb вызова.

                                                  # Обновление базы данных
                                                  см. описание системы патчей.

                                                  # API
                                                  Система представляет API для интеграции с другими системами:

                                                  # Java API
                                                  Реализация (снизу вверх): БД - Hibernate3 - EJB3

                                                  Документацию можно смотреть в исходном коде (javadocs в *Service.java).

                                                  # WebServices API
                                                  Реализация (снизу вверх): БД - Hibernate3 - JAX-WS

                                                  Документация: WebServicesDeveloperGuide

                                                  # Scripting API
                                                  Реализация (снизу вверх): БД - Hibernate3 - XML Script

                                                  Документация: AdminScriptGuide

                                                  # Процесс сборки из исходного кода
                                                  Исходный код системы доступен в открытом репозитории на github.

                                                  Сервер можно собирать как средствами maven используя командную строку, так и используя среду Eclipse IDE.

                                                  В результате сборки будет сформирован runawfe.ear, который теоретически можно запустить на любом сервере приложений. Начиная с версии 4.3.0 введена поддержка JAVA версии 8, и отказ от JAVA 6. В дальнейшем планируется отказ от java7, поэтому рекомендуется использовать сервер приложений wildfly.

                                                  # Процесс сборки на примере Eclipse IDE
                                                  # Необходимое программное обеспечение для сборки
                                                  В отличие от Среды разработки для сборки сервера можно использовать Eclipse IDE любой версии и редакции.

                                                  установите плагин m2eclipse
                                                  используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу: http://maven.apache.org/
                                                  добавьте путь к Apache Maven директории bin в переменную окружения Path
                                                  # Импорт проектов
                                                  Импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server.

                                                  Eclipse srv proj.png

                                                  # Установка maven артефактов
                                                  Выполните

                                                  ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                                                  ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                                                  или другим способом установите артефакты в локальный репозиторий

                                                  # Сборка
                                                  Заведите конфигурацию запуска на основе maven как показано на рисунке

                                                  Maven.build.configuration.png

                                                  Запустите конфигурацию.

                                                  Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\eclipse-workspace\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"

                                                  # Сборка из командной строки
                                                  используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу http://maven.apache.org/
                                                  добавьте путь к Apache Maven директории bin в переменную окружения Path
                                                  импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server
                                                  выполните обновление зависимостей
                                                  ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                                                  ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                                                  откройте командную строку
                                                  перейдите в директорию ${wfe}/wfe-app/
                                                  выполните команду для сборки
                                                  mvn clean package -Dmaven.test.skip=true
                                                  Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"


                                                  Для установки артефактов в локальный репозиторий используйте команду

                                                  mvn clean install -Dmaven.test.skip=true
                                                  # Использование ear на сервере приложений
                                                  cкачайте текущую версию RunaWFE в виде файл-архива исполняемых java файлов runawfe-wildfly-java8-*.zip (на базе wildfly, java8)
                                                  распакуйте архив
                                                  обновите runawfe.ear на версию полученную в результате сборки
                                                  # Расширение функциональности
                                                  # Точки расширения системы
                                                  Обработчики позволяют исполнить код в процессах (элементы "Обработчик", "Задача сценария") и ботах
                                                  Форматы переменных определяют тип переменных и правила преобразования значений к текстовому представлению и обратно
                                                  Организационные функции используются при назначении ролей и в правилах замещения для определения заместителя
                                                  Критерии замещения используются в подсистеме замещения для определения заместителя при построении списка заданий
                                                  Валидаторы обеспечивают проверку переменных при выполнении задания (в т.ч. введенные значения форм)
                                                  Freemarker теги форм генерируют html код для отображения на форме
                                                  Ajax команды предоставляют доступ к функциональности сервера из JavaScript
                                                  # Процесс разработки расширений
                                                  Создайте новый java-проект и подключите необходимые зависимости (wfe-core, wfe-service).

                                                  Реализуйте в нем требуемые расширения и соберите его в виде jar-файла.

                                                  Замечание. Использование maven облегчит процесс управления зависимостями.

                                                  Разместить собранный jar на сервере вы можете:

                                                  положив его в runawfe.ear!/lib
                                                  положив его в директорию deploy (только для jboss4)
                                                  положив его в ${jboss.server.base.dir}/wfe.custom (только для jboss7)
                                                  положив его в ${jboss.server.base.dir}/${jboss.server.name}/wfe.custom (только для jboss4)
                                                  # Обработчики
                                                  Обработчик в процессе – компонент процесса (элементы "Обработчик", "Задача сценария"), использующийся для выполнения каких-либо действий при возникновении определенных событий (проход по определенному переходу в процессе, приход или уход управления из узла и т.п.).

                                                  Обработчик должен реализовывать интерфейс ru.runa.wfe.extension.ActionHandler. Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов Spring контекста (например с помощью аннотации @Autowired).

                                                  При написании нового обработчика рекомендуется наследовать его от абстрактного класса ru.runa.wfe.extension.handler.CommonHandler или ru.runa.wfe.extension.handler.CommonParamBasedHandler. В методе setConfiguration обработчик должен запомнить свои параметры (если обработчик их ожидает), а в методе execute происходит непосредственная обработка и выполнение требуемых действий.

                                                  В случае, если при выполнении обработчика произошла ошибка, произойдет откат транзакции и состояние процесса будет возвращено к заданию, исполнение которого повлекло вызов обработчика. В интерфейсе обработчика для бота ru.runa.wfe.extension.TaskHandler предусмотрен метод onRollback для работы с не-транзакционными ресурсами.

                                                  Эти обработчики удобно использовать для простых операций (например для отправки оповещений в виде SMS-сообщений если процесс попал в определенное состояние). Но у них есть несколько ограничений. Прежде всего у них нет соответствующего объекта контекста безопасности (security context). Это означает, что в них нельзя выполнять защищенные методы (запуск процессов, выполнение задач, создание пользователей и т.п.) Ошибочным решением в них будет блокирование выполнения процесса (например с Thread::Sleep(...)). Например, если в обработчике отправляется e-mail, а SMTP сервер недоступен, обработчику нельзя "задерживать" свое выполнение.

                                                  Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                                                  # Специфика обработчиков для ботов
                                                  Бот - это сокращение от робот. В системе боты - это особый тип исполнителей. Система не отличает ботов от людей. У каждого бота есть свои права на вход в систему, он периодически просыпается, проверяет свой список задачи и выполняет обнаруженные там задачи.

                                                  Каждая задача бота обрабатывается при помощи соответствующего обработчика. Чтобы написать новый обработчик нужно реализовать интерфейс ru.runa.wfe.extension.TaskHandler.

                                                  Обратите внимание, что этот вид обработчиков выполняется в контексте безопасности (security context) пользователя-бота, и здесь может выполнятся любая операция (если у бота есть на это права).

                                                  Обработчики задач ботов могут блокировать выполнение процесса.

                                                  Например, обработчик задач, отправляющий e-mail может блокировать выполнение бизнес процесса до тех пор, пока обработчик не удостоверится, что SMTP сервер принял сообщение для последующей доставки.

                                                  Обработчики задач вызываются периодически, когда боты проверяют свои списки задач.

                                                  # Специфика обработчика для элемента ветвление
                                                  Обработчик для Decision является java-классом, реализующим интерфейс ru.runa.wfe.extension.DecisionHandler. Интерфейс содержит один метод decide(ExecutionContext executionContext), который возвращает имя выбранного перехода (одного из выходящих из данного ветвления). Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов контекста спринга (например с помощью аннотации @Autowired).

                                                  Обработчик принимает ExecutionContext в качестве входящего параметра и должен сделать выбор перехода исходя из значений переменных бизнес процесса и условий, указанных в конфигурации обработчика. Точно также как обработчики действия (action handler) обработчики выбора (decision handlers) не могут использовать защищенные (secured) методы, не могут обрабатывать ошибки и откладывать выбор перехода до лучших времен.

                                                  По умолчанию используется ru.runa.wfe.extension.decision.GroovyDecisionHandler.

                                                  # Использование ru.runa.wfe.extension.handler.CommonParamBasedHandler в качестве базового класса
                                                  Этот класс инкапсулирует в себе парсинг XML конфигурации определенного формата. Его удобно использовать если обработчик имеет фиксированное число параметров. Пример конфигурации:

                                                  <?xml version="1.0" encoding="UTF-8"?>
                                                  <config>
                                                   <input>
                                                     <param name="typeName" variable="тип отсутствия" />
                                                     <param name="employee" variable="сотрудник" />
                                                     <param name="requester" variable="подавший заявку" />
                                                     <param name="from" variable="дата с" />
                                                     <param name="to" variable="дата по" />
                                                     <param name="cause" variable="причина" />
                                                     <param name="comment" variable="комментарий" />
                                                     <param name="confirmation" variable="дата подтверждения" />
                                                     <param name="firmCode" value="111" />
                                                     <param name="firmPositionCode" variable="код должности" />
                                                     <param name="firmDepartmentCode" variable="код подразделения" />
                                                   </input>
                                                   <output>
                                                     <param name="uuid" variable="идентификатор объекта" />
                                                   </output>
                                                  </config>
                                                  Использование обработчика Groovy
                                                  См. соответствующий раздел в руководстве по работе с Groovy.

                                                  # Как написать функцию над организационной структурой
                                                  Функции над организационной структурой в системе применяются, например, при инициализации Ролей-Дорожек и в правилах замещения.

                                                  Класс, соответствующий функции над организационной структурой, должен реализовывать интерфейс ru.runa.wfe.extension.OrgFunction.

                                                  Интерфейс содержит один метод

                                                  List<? extends Executor> getExecutors(Object... parameters)
                                                  Этот метод должен возвращать список исполнителей.

                                                  В бизнес-процессе обработчик функции над оргструктурой используются при определении Ролей-Дорожек: указывается внутри тега swimlane, в теле тега <assignment>.В качестве параметра class тега <assignment> указывается класс-обработчик для инициализации swimlane: ru.runa.wfe.extension.AssignmentHandler. Внутри тега <assignment> содержится конфигурация для этого класса, которая представляет собой имя класса-наследника интерфейса OrgFunction и список параметров в скобках. В качестве параметра может выступать конкретное значение или имя переменной бизнес процесса в фигурных скобках, перед которым стоит значок $

                                                  Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                                                  Если есть планы по использованию функции в подсистеме замещений - её можно зарегистрировать в substitutions.xml.

                                                  # Как написать критерий замещения
                                                  Критерии замещения в системе применяются в правилах замещения. Класс, соответствующий критерию замещения, должен наследоваться от ru.runa.wfe.ss.SubstitutionCriteria.

                                                  Для создания на основе него конечных критериев замещения с конфигурациями - его нужно зарегистрировать в substitution.criterias.xml.

                                                  Как реализовать класс-формат для переменных бизнес-процесса
                                                  См. соответствующий раздел в руководстве по работе с переменными.

                                                  # Как реализовать валидатор переменных
                                                  Классы, расширяющие абстрактный класс ru.runa.wfe.validation.FieldValidator, в системе применяются для проверки переменных при выполнении задания или старте процесса.

                                                  Пример:

                                                  public class OvertimeWorkRequestTimeCheck extends FieldValidator {
                                                     @Override
                                                     public void validate() {
                                                         Date date = (Date) getFieldValue();
                                                         if (date == null) {
                                                             return;
                                                         }
                                                         boolean testMode = getVariableProvider().getValueNotNull(boolean.class, "тестовый режим");
                                                         if (testMode) {
                                                             return;
                                                         }
                                                         Calendar calendar = CalendarUtil.dateToCalendar(date);
                                                         if (calendar.before(Calendar.getInstance())) {
                                                             addError("Заявка не может быть оформлена задним числом");
                                                             return;
                                                         }
                                                         CalendarUtil.setTimeFromCalendar(calendar, DemoProperties.getOvertimeWorkRequestMaximumStartTime());
                                                         Utils.adjustCalendarForHolidaysInOvertimwWork(calendar);
                                                         if (calendar.before(Calendar.getInstance())) {
                                                             addError("Заявка на этот день не может быть подана, время подачи истекло " + CalendarUtil.formatDateTime(calendar));
                                                         }
                                                     }
                                                  }

                                                  Связь между Средой разработки и сервером осуществляется по имени валидатора, регистрация требуется на стороне сервера в файле validators.xml, а в среде разработки - в plugin.xml.

                                                  # Как реализовать FreeMarker тег для формы
                                                  FreemarkerForms#Components

                                                  # Как реализовать Ajax команду
                                                  Классы, расширяющие абстрактный класс ru.runa.wfe.commons.web.JsonAjaxCommand, (или реализующие ru.runa.wfe.commons.web.AjaxCommand) в системе применяются для доступа к функциональности сервера из JavaScript, например при отображении форм задания.

                                                  Регистрация команды происходит любым из двух способов:

                                                  в файле ajax.commands.xml, ей присваивается определенное имя
                                                  в контексте приложения, именем является id spring-бина
                                                  Затем по этому имени её можно выполнить используя JavaScript.

                                                  Пример команды

                                                  public class GetOrganizationNamesCommand extends JsonAjaxCommand {
                                                     @Autowired
                                                     private OrganizationDAO organizationDAO;
                                                     @Override
                                                     protected JSONAware execute(User user, HttpServletRequest request) throws Exception {
                                                         String term = request.getParameter("term");
                                                         if (term == null) {
                                                             term = "";
                                                         }
                                                         List<Organization> organizations = organizationDAO.getAll();
                                                         JSONArray array = new JSONArray();
                                                         for (Organization organization : organizations) {
                                                             if (organization.getName().startsWith(term)) {
                                                                 array.add(organization.getName());
                                                             }
                                                         }
                                                         return array;
                                                     }
                                                  }
                                                  Регистрация в wfe.custom.ajax.commands.xml

                                                  <?xml version="1.0" encoding="UTF-8" ?>
                                                  <configuration xmlns="http://runa.ru/xml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://runa.ru/xml">
                                                   <command name="getOrganizationNames" class="ru.runa.rkdemo.web.ajax.GetOrganizationNamesCommand" />
                                                  </configuration>
                                                  Её использование со скрипта формы (autocomplete input)

                                                  $(document).ready(function() {
                                                   $('#editLinkedLists').on("onRowAdded", function(event, rowIndex) {
                                                    $("input[name='названия организаций["+rowIndex+"]']").autocomplete( {
                                                     delay: 300,
                                                     minLength: 0,
                                                     source: "/wfe/ajaxcmd?command=getOrganizationNames"
                                                    });
                                                    $("input[name='названия организаций["+rowIndex+"]']").focus(function() {
                                                     $(this).autocomplete("search", $(this).val());
                                                    });
                                                   });
                                                  });Введение
                                                     # Основные компоненты и используемые технологии
                                                     Для WF–системы была выбрана следующая общая архитектура (в целом соответствует архитектуре, предлагаемой коалицией WfMC):

                                                     Компоненты системы:

                                                     Ядро системы
                                                     Содержит набор определений бизнес-процессов
                                                     Содержит набор выполняющихся экземпляров бизнес–процессов
                                                     Компонент, "назначающий" исполнителей для действий
                                                     Клиент
                                                     Список заданий (набор графических форм, содержит очереди поступивших работ, сортировки и фильтры)
                                                     Проигрыватель форм (отображает формы, разработанные в Среде разработки)
                                                     Административный интерфейс
                                                     Показывает состояния процессов, позволяет фильтровать и останавливать процессы
                                                     Позволяет загружать-выгружать процессы
                                                     Позволяет заводить-удалять пользователей
                                                     Позволяет задавать различные права
                                                     Редактор назначения заместителей
                                                     Среда разработки
                                                     Конструктор графических форм
                                                     Бот станции, содержащие ботов (Боты - приложения специального вида, которые также как и обычные пользователи могут выполнять задания)
                                                     Подсистема управления правами доступа (авторизация и аутентификация)
                                                     # Платформа программирования и используемые программные средства
                                                     В качестве платформы программирования используется J2EE.

                                                     Используемые программные средства:

                                                     Сервер приложений - JBOSS (http://www.jboss.org).
                                                     Среда разработки - любая, например Eclipse от IBM (http://www.eclipse.org).
                                                     Система контроля версий - git
                                                     Сборщик приложений – maven.
                                                     Сервер баз данных – поддерживаются сервера БД:
                                                     MS SQL Server (http://www.microsoft.com/sql/evaluation/default.mspx)
                                                     HSQL (http://hsqldb.org)
                                                     Oracle (http://www.oracle.com)
                                                     PostgreSQL (http://postgresql.com)
                                                     Операционная система — поддерживаются следующие ОС:
                                                     Windows (Server 2000-2008, XP, Vista, 7)
                                                     ALTLinux
                                                     Mandriva Linux
                                                     Fedora
                                                     Debian/Ubuntu
                                                     # Описание проектов
                                                     Название проекта	Обязателен при сборке	Обязателен при работе	Зависимости	Описание
                                                     wfe-alfresco	нет	нет	runawfe-app	Интеграция с Alfresco
                                                     wfe-app	да	да	wfe-ear, wfe-cactus-it	Проект для организации сборки maven
                                                     wfe-appserver	нет	нет	 ?	Не используется
                                                     wfe-bots	да	да	wfe-service	Подсистема ботов
                                                     wfe-cactus-it	да	нет	wfe-service	Интеграционные тесты
                                                     wfe-core	да	да	-	Основные компоненты системы
                                                     wfe-ear	да	да	wfe-service, wfe-bots, wfe-office, wfe-web	Проект для сборки runawfe.ear
                                                     wfe-office	да	нет	wfe-core	Обработчики для работы с Word, Excel
                                                     wfe-service	да	да	wfe-core	Сервисы (EJB + WebServices), представляющие собой публичное API приложения
                                                     wfe-web	да	да	wfe-bots	Визуальная часть приложения
                                                     wfe-webservice-client	нет	нет	 ?	Авто-генерации клиентской библиотеки на основе WSDL серверных сервисов. В нем же есть примеры использования веб-служб из Java клиента.
                                                     # Описание слоев архитектуры системы
                                                     Каждый компонент состоит из нескольких уровней (слоев).

                                                     Список слоев:

                                                     delegate
                                                     service
                                                     logic
                                                     DAO
                                                     hibernate
                                                     # Слой Delegate
                                                     Delegate-классы, реализующие сервисные интерфейсы представляют собой pattern проектирования BusinessDelegate, упрощающий доступ к серверному API системы. Клиентское приложение взаимодействует с системой только через Delegate-классы. Delegate-классы получаются посредством запроса фабрики Delegates, которая в зависимости от конфигурации возвращает нужную реализацию. Классы Delegate являются частью клиентского API.

                                                     Список основных Delegate-классов:

                                                     AuthenticationServiceDelegate – содержит методы для аутентификации пользователей в системе (с использованием логина/пароля, Kerberos и т.п.)
                                                     AuthorizationServiceDelegate — содержит методы для работы с полномочиями пользователей (назначение полномочий, проверка на допустимость операции для пользователя и т.п.)
                                                     BotServiceDelegate — содержит методы для работы с бот станциями и ботами
                                                     ExecutorServiceDelegate — содержит методы для работы с исполнителями. Позволяет создавать/удалять/изменять исполнителей а так же включать их в группы
                                                     ProfileServiceDelegate — содержит методы для работы с профайлам пользователей
                                                     SubstitutionServiceDelegate — содержит методы для управления правилами замещения
                                                     SystemServiceDelegate — содержит методы для входа/выхода пользователя в систему
                                                     DefinitionServiceDelegate — содержит методы для работы с определениями процессов
                                                     ExecutionServiceDelegate — содержит методы для работы с исполняемыми экземплярами процессов
                                                     Все существующие в данный момент Delegate-классы реализуют требуемую функциональность при помощи технологии EJB.

                                                     # Слой Service
                                                     Слой service – это серверное API доступа к системе. Реализации Delegate интерфейсов обращаются именно к этому слою. Каждый Delegate работает с одним соответствующим классом Service. В настоящее время все разработанные service классы и интерфейсы ориентированы на EJB-технологию, однако в будущем возможны и другие реализации. Реализации классов Service являются Stateless Session Bean EJB, которые декларативно поддерживают транзакционность вызовов и запрашивают соответствующие классы из слоя Logic.

                                                     Таким образом, классы Delegate – Service - Logic образуют как бы «транспорт» между клиентом и сервером.

                                                     # Слой Logic
                                                     Слой Logic – это реализация бизнес логики работы системы. Слой работает с классами слоя DAO для доступа к постоянному хранилищу.

                                                     # Слой DAO
                                                     Слой DAO – это интерфейсы и классы, обеспечивающие доступ к данным, находящимся в постоянном хранилище (базе данных). В настоящее время все DAO-классы системы реализованы при помощи ORM-средства Hibernate.

                                                     # Использование Hibernate
                                                     Hibernate – ORM (Object/Relational Mapping) средство. Отображает объектную архитектуру на реляционную структуру данных. Допускает настройку (не меняя разработанного кода) на большинство существующих серверов реляционных баз данных.

                                                     Поддерживает работу с распределенными транзакциями, автоматически создает таблицы для новых классов и т.д. Вся работа с данными внутри системы ведется только через Hibernate.

                                                     Все компоненты, предоставляющие клиентское API построены с использованием описанных выше слоев. В целях оптимизации в некоторых компонентах применяется кеширование, которое может встречаться на уровне logic или DAO. Основная функциональность по управлению кешами находится в классах CachingLogic, CacheInterceptor и классах соответствующих кешей. Изменения в кешируемых объектах перехватываются и сообщаются посредством CachingLogic всем подписавшимся на изменения классам кешей. Транзакция, изменяющая кеш, считается закрытой по окончанию обработки ejb вызова.

                                                     # Обновление базы данных
                                                     см. описание системы патчей.

                                                     # API
                                                     Система представляет API для интеграции с другими системами:

                                                     # Java API
                                                     Реализация (снизу вверх): БД - Hibernate3 - EJB3

                                                     Документацию можно смотреть в исходном коде (javadocs в *Service.java).

                                                     # WebServices API
                                                     Реализация (снизу вверх): БД - Hibernate3 - JAX-WS

                                                     Документация: WebServicesDeveloperGuide

                                                     # Scripting API
                                                     Реализация (снизу вверх): БД - Hibernate3 - XML Script

                                                     Документация: AdminScriptGuide

                                                     # Процесс сборки из исходного кода
                                                     Исходный код системы доступен в открытом репозитории на github.

                                                     Сервер можно собирать как средствами maven используя командную строку, так и используя среду Eclipse IDE.

                                                     В результате сборки будет сформирован runawfe.ear, который теоретически можно запустить на любом сервере приложений. Начиная с версии 4.3.0 введена поддержка JAVA версии 8, и отказ от JAVA 6. В дальнейшем планируется отказ от java7, поэтому рекомендуется использовать сервер приложений wildfly.

                                                     # Процесс сборки на примере Eclipse IDE
                                                     # Необходимое программное обеспечение для сборки
                                                     В отличие от Среды разработки для сборки сервера можно использовать Eclipse IDE любой версии и редакции.

                                                     установите плагин m2eclipse
                                                     используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу: http://maven.apache.org/
                                                     добавьте путь к Apache Maven директории bin в переменную окружения Path
                                                     # Импорт проектов
                                                     Импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server.

                                                     Eclipse srv proj.png

                                                     # Установка maven артефактов
                                                     Выполните

                                                     ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                                                     ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                                                     или другим способом установите артефакты в локальный репозиторий

                                                     # Сборка
                                                     Заведите конфигурацию запуска на основе maven как показано на рисунке

                                                     Maven.build.configuration.png

                                                     Запустите конфигурацию.

                                                     Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\eclipse-workspace\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"

                                                     # Сборка из командной строки
                                                     используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу http://maven.apache.org/
                                                     добавьте путь к Apache Maven директории bin в переменную окружения Path
                                                     импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server
                                                     выполните обновление зависимостей
                                                     ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                                                     ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                                                     откройте командную строку
                                                     перейдите в директорию ${wfe}/wfe-app/
                                                     выполните команду для сборки
                                                     mvn clean package -Dmaven.test.skip=true
                                                     Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"


                                                     Для установки артефактов в локальный репозиторий используйте команду

                                                     mvn clean install -Dmaven.test.skip=true
                                                     # Использование ear на сервере приложений
                                                     cкачайте текущую версию RunaWFE в виде файл-архива исполняемых java файлов runawfe-wildfly-java8-*.zip (на базе wildfly, java8)
                                                     распакуйте архив
                                                     обновите runawfe.ear на версию полученную в результате сборки
                                                     # Расширение функциональности
                                                     # Точки расширения системы
                                                     Обработчики позволяют исполнить код в процессах (элементы "Обработчик", "Задача сценария") и ботах
                                                     Форматы переменных определяют тип переменных и правила преобразования значений к текстовому представлению и обратно
                                                     Организационные функции используются при назначении ролей и в правилах замещения для определения заместителя
                                                     Критерии замещения используются в подсистеме замещения для определения заместителя при построении списка заданий
                                                     Валидаторы обеспечивают проверку переменных при выполнении задания (в т.ч. введенные значения форм)
                                                     Freemarker теги форм генерируют html код для отображения на форме
                                                     Ajax команды предоставляют доступ к функциональности сервера из JavaScript
                                                     # Процесс разработки расширений
                                                     Создайте новый java-проект и подключите необходимые зависимости (wfe-core, wfe-service).

                                                     Реализуйте в нем требуемые расширения и соберите его в виде jar-файла.

                                                     Замечание. Использование maven облегчит процесс управления зависимостями.

                                                     Разместить собранный jar на сервере вы можете:

                                                     положив его в runawfe.ear!/lib
                                                     положив его в директорию deploy (только для jboss4)
                                                     положив его в ${jboss.server.base.dir}/wfe.custom (только для jboss7)
                                                     положив его в ${jboss.server.base.dir}/${jboss.server.name}/wfe.custom (только для jboss4)
                                                     # Обработчики
                                                     Обработчик в процессе – компонент процесса (элементы "Обработчик", "Задача сценария"), использующийся для выполнения каких-либо действий при возникновении определенных событий (проход по определенному переходу в процессе, приход или уход управления из узла и т.п.).

                                                     Обработчик должен реализовывать интерфейс ru.runa.wfe.extension.ActionHandler. Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов Spring контекста (например с помощью аннотации @Autowired).

                                                     При написании нового обработчика рекомендуется наследовать его от абстрактного класса ru.runa.wfe.extension.handler.CommonHandler или ru.runa.wfe.extension.handler.CommonParamBasedHandler. В методе setConfiguration обработчик должен запомнить свои параметры (если обработчик их ожидает), а в методе execute происходит непосредственная обработка и выполнение требуемых действий.

                                                     В случае, если при выполнении обработчика произошла ошибка, произойдет откат транзакции и состояние процесса будет возвращено к заданию, исполнение которого повлекло вызов обработчика. В интерфейсе обработчика для бота ru.runa.wfe.extension.TaskHandler предусмотрен метод onRollback для работы с не-транзакционными ресурсами.

                                                     Эти обработчики удобно использовать для простых операций (например для отправки оповещений в виде SMS-сообщений если процесс попал в определенное состояние). Но у них есть несколько ограничений. Прежде всего у них нет соответствующего объекта контекста безопасности (security context). Это означает, что в них нельзя выполнять защищенные методы (запуск процессов, выполнение задач, создание пользователей и т.п.) Ошибочным решением в них будет блокирование выполнения процесса (например с Thread::Sleep(...)). Например, если в обработчике отправляется e-mail, а SMTP сервер недоступен, обработчику нельзя "задерживать" свое выполнение.

                                                     Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                                                     # Специфика обработчиков для ботов
                                                     Бот - это сокращение от робот. В системе боты - это особый тип исполнителей. Система не отличает ботов от людей. У каждого бота есть свои права на вход в систему, он периодически просыпается, проверяет свой список задачи и выполняет обнаруженные там задачи.

                                                     Каждая задача бота обрабатывается при помощи соответствующего обработчика. Чтобы написать новый обработчик нужно реализовать интерфейс ru.runa.wfe.extension.TaskHandler.

                                                     Обратите внимание, что этот вид обработчиков выполняется в контексте безопасности (security context) пользователя-бота, и здесь может выполнятся любая операция (если у бота есть на это права).

                                                     Обработчики задач ботов могут блокировать выполнение процесса.

                                                     Например, обработчик задач, отправляющий e-mail может блокировать выполнение бизнес процесса до тех пор, пока обработчик не удостоверится, что SMTP сервер принял сообщение для последующей доставки.

                                                     Обработчики задач вызываются периодически, когда боты проверяют свои списки задач.

                                                     # Специфика обработчика для элемента ветвление
                                                     Обработчик для Decision является java-классом, реализующим интерфейс ru.runa.wfe.extension.DecisionHandler. Интерфейс содержит один метод decide(ExecutionContext executionContext), который возвращает имя выбранного перехода (одного из выходящих из данного ветвления). Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов контекста спринга (например с помощью аннотации @Autowired).

                                                     Обработчик принимает ExecutionContext в качестве входящего параметра и должен сделать выбор перехода исходя из значений переменных бизнес процесса и условий, указанных в конфигурации обработчика. Точно также как обработчики действия (action handler) обработчики выбора (decision handlers) не могут использовать защищенные (secured) методы, не могут обрабатывать ошибки и откладывать выбор перехода до лучших времен.

                                                     По умолчанию используется ru.runa.wfe.extension.decision.GroovyDecisionHandler.

                                                     # Использование ru.runa.wfe.extension.handler.CommonParamBasedHandler в качестве базового класса
                                                     Этот класс инкапсулирует в себе парсинг XML конфигурации определенного формата. Его удобно использовать если обработчик имеет фиксированное число параметров. Пример конфигурации:

                                                     <?xml version="1.0" encoding="UTF-8"?>
                                                     <config>
                                                      <input>
                                                        <param name="typeName" variable="тип отсутствия" />
                                                        <param name="employee" variable="сотрудник" />
                                                        <param name="requester" variable="подавший заявку" />
                                                        <param name="from" variable="дата с" />
                                                        <param name="to" variable="дата по" />
                                                        <param name="cause" variable="причина" />
                                                        <param name="comment" variable="комментарий" />
                                                        <param name="confirmation" variable="дата подтверждения" />
                                                        <param name="firmCode" value="111" />
                                                        <param name="firmPositionCode" variable="код должности" />
                                                        <param name="firmDepartmentCode" variable="код подразделения" />
                                                      </input>
                                                      <output>
                                                        <param name="uuid" variable="идентификатор объекта" />
                                                      </output>
                                                     </config>
                                                     Использование обработчика Groovy
                                                     См. соответствующий раздел в руководстве по работе с Groovy.

                                                     # Как написать функцию над организационной структурой
                                                     Функции над организационной структурой в системе применяются, например, при инициализации Ролей-Дорожек и в правилах замещения.

                                                     Класс, соответствующий функции над организационной структурой, должен реализовывать интерфейс ru.runa.wfe.extension.OrgFunction.

                                                     Интерфейс содержит один метод

                                                     List<? extends Executor> getExecutors(Object... parameters)
                                                     Этот метод должен возвращать список исполнителей.

                                                     В бизнес-процессе обработчик функции над оргструктурой используются при определении Ролей-Дорожек: указывается внутри тега swimlane, в теле тега <assignment>.В качестве параметра class тега <assignment> указывается класс-обработчик для инициализации swimlane: ru.runa.wfe.extension.AssignmentHandler. Внутри тега <assignment> содержится конфигурация для этого класса, которая представляет собой имя класса-наследника интерфейса OrgFunction и список параметров в скобках. В качестве параметра может выступать конкретное значение или имя переменной бизнес процесса в фигурных скобках, перед которым стоит значок $

                                                     Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                                                     Если есть планы по использованию функции в подсистеме замещений - её можно зарегистрировать в substitutions.xml.

                                                     # Как написать критерий замещения
                                                     Критерии замещения в системе применяются в правилах замещения. Класс, соответствующий критерию замещения, должен наследоваться от ru.runa.wfe.ss.SubstitutionCriteria.

                                                     Для создания на основе него конечных критериев замещения с конфигурациями - его нужно зарегистрировать в substitution.criterias.xml.

                                                     Как реализовать класс-формат для переменных бизнес-процесса
                                                     См. соответствующий раздел в руководстве по работе с переменными.

                                                     # Как реализовать валидатор переменных
                                                     Классы, расширяющие абстрактный класс ru.runa.wfe.validation.FieldValidator, в системе применяются для проверки переменных при выполнении задания или старте процесса.

                                                     Пример:

                                                     public class OvertimeWorkRequestTimeCheck extends FieldValidator {
                                                        @Override
                                                        public void validate() {
                                                            Date date = (Date) getFieldValue();
                                                            if (date == null) {
                                                                return;
                                                            }
                                                            boolean testMode = getVariableProvider().getValueNotNull(boolean.class, "тестовый режим");
                                                            if (testMode) {
                                                                return;
                                                            }
                                                            Calendar calendar = CalendarUtil.dateToCalendar(date);
                                                            if (calendar.before(Calendar.getInstance())) {
                                                                addError("Заявка не может быть оформлена задним числом");
                                                                return;
                                                            }
                                                            CalendarUtil.setTimeFromCalendar(calendar, DemoProperties.getOvertimeWorkRequestMaximumStartTime());
                                                            Utils.adjustCalendarForHolidaysInOvertimwWork(calendar);
                                                            if (calendar.before(Calendar.getInstance())) {
                                                                addError("Заявка на этот день не может быть подана, время подачи истекло " + CalendarUtil.formatDateTime(calendar));
                                                            }
                                                        }
                                                     }

                                                     Связь между Средой разработки и сервером осуществляется по имени валидатора, регистрация требуется на стороне сервера в файле validators.xml, а в среде разработки - в plugin.xml.

                                                     # Как реализовать FreeMarker тег для формы
                                                     FreemarkerForms#Components

                                                     # Как реализовать Ajax команду
                                                     Классы, расширяющие абстрактный класс ru.runa.wfe.commons.web.JsonAjaxCommand, (или реализующие ru.runa.wfe.commons.web.AjaxCommand) в системе применяются для доступа к функциональности сервера из JavaScript, например при отображении форм задания.

                                                     Регистрация команды происходит любым из двух способов:

                                                     в файле ajax.commands.xml, ей присваивается определенное имя
                                                     в контексте приложения, именем является id spring-бина
                                                     Затем по этому имени её можно выполнить используя JavaScript.

                                                     Пример команды

                                                     public class GetOrganizationNamesCommand extends JsonAjaxCommand {
                                                        @Autowired
                                                        private OrganizationDAO organizationDAO;
                                                        @Override
                                                        protected JSONAware execute(User user, HttpServletRequest request) throws Exception {
                                                            String term = request.getParameter("term");
                                                            if (term == null) {
                                                                term = "";
                                                            }
                                                            List<Organization> organizations = organizationDAO.getAll();
                                                            JSONArray array = new JSONArray();
                                                            for (Organization organization : organizations) {
                                                                if (organization.getName().startsWith(term)) {
                                                                    array.add(organization.getName());
                                                                }
                                                            }
                                                            return array;
                                                        }
                                                     }
                                                     Регистрация в wfe.custom.ajax.commands.xml

                                                     <?xml version="1.0" encoding="UTF-8" ?>
                                                     <configuration xmlns="http://runa.ru/xml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://runa.ru/xml">
                                                      <command name="getOrganizationNames" class="ru.runa.rkdemo.web.ajax.GetOrganizationNamesCommand" />
                                                     </configuration>
                                                     Её использование со скрипта формы (autocomplete input)

                                                     $(document).ready(function() {
                                                      $('#editLinkedLists').on("onRowAdded", function(event, rowIndex) {
                                                       $("input[name='названия организаций["+rowIndex+"]']").autocomplete( {
                                                        delay: 300,
                                                        minLength: 0,
                                                        source: "/wfe/ajaxcmd?command=getOrganizationNames"
                                                       });
                                                       $("input[name='названия организаций["+rowIndex+"]']").focus(function() {
                                                        $(this).autocomplete("search", $(this).val());
                                                       });
                                                      });
                                                     });Введение
                                                        # Основные компоненты и используемые технологии
                                                        Для WF–системы была выбрана следующая общая архитектура (в целом соответствует архитектуре, предлагаемой коалицией WfMC):

                                                        Компоненты системы:

                                                        Ядро системы
                                                        Содержит набор определений бизнес-процессов
                                                        Содержит набор выполняющихся экземпляров бизнес–процессов
                                                        Компонент, "назначающий" исполнителей для действий
                                                        Клиент
                                                        Список заданий (набор графических форм, содержит очереди поступивших работ, сортировки и фильтры)
                                                        Проигрыватель форм (отображает формы, разработанные в Среде разработки)
                                                        Административный интерфейс
                                                        Показывает состояния процессов, позволяет фильтровать и останавливать процессы
                                                        Позволяет загружать-выгружать процессы
                                                        Позволяет заводить-удалять пользователей
                                                        Позволяет задавать различные права
                                                        Редактор назначения заместителей
                                                        Среда разработки
                                                        Конструктор графических форм
                                                        Бот станции, содержащие ботов (Боты - приложения специального вида, которые также как и обычные пользователи могут выполнять задания)
                                                        Подсистема управления правами доступа (авторизация и аутентификация)
                                                        # Платформа программирования и используемые программные средства
                                                        В качестве платформы программирования используется J2EE.

                                                        Используемые программные средства:

                                                        Сервер приложений - JBOSS (http://www.jboss.org).
                                                        Среда разработки - любая, например Eclipse от IBM (http://www.eclipse.org).
                                                        Система контроля версий - git
                                                        Сборщик приложений – maven.
                                                        Сервер баз данных – поддерживаются сервера БД:
                                                        MS SQL Server (http://www.microsoft.com/sql/evaluation/default.mspx)
                                                        HSQL (http://hsqldb.org)
                                                        Oracle (http://www.oracle.com)
                                                        PostgreSQL (http://postgresql.com)
                                                        Операционная система — поддерживаются следующие ОС:
                                                        Windows (Server 2000-2008, XP, Vista, 7)
                                                        ALTLinux
                                                        Mandriva Linux
                                                        Fedora
                                                        Debian/Ubuntu
                                                        # Описание проектов
                                                        Название проекта	Обязателен при сборке	Обязателен при работе	Зависимости	Описание
                                                        wfe-alfresco	нет	нет	runawfe-app	Интеграция с Alfresco
                                                        wfe-app	да	да	wfe-ear, wfe-cactus-it	Проект для организации сборки maven
                                                        wfe-appserver	нет	нет	 ?	Не используется
                                                        wfe-bots	да	да	wfe-service	Подсистема ботов
                                                        wfe-cactus-it	да	нет	wfe-service	Интеграционные тесты
                                                        wfe-core	да	да	-	Основные компоненты системы
                                                        wfe-ear	да	да	wfe-service, wfe-bots, wfe-office, wfe-web	Проект для сборки runawfe.ear
                                                        wfe-office	да	нет	wfe-core	Обработчики для работы с Word, Excel
                                                        wfe-service	да	да	wfe-core	Сервисы (EJB + WebServices), представляющие собой публичное API приложения
                                                        wfe-web	да	да	wfe-bots	Визуальная часть приложения
                                                        wfe-webservice-client	нет	нет	 ?	Авто-генерации клиентской библиотеки на основе WSDL серверных сервисов. В нем же есть примеры использования веб-служб из Java клиента.
                                                        # Описание слоев архитектуры системы
                                                        Каждый компонент состоит из нескольких уровней (слоев).

                                                        Список слоев:

                                                        delegate
                                                        service
                                                        logic
                                                        DAO
                                                        hibernate
                                                        # Слой Delegate
                                                        Delegate-классы, реализующие сервисные интерфейсы представляют собой pattern проектирования BusinessDelegate, упрощающий доступ к серверному API системы. Клиентское приложение взаимодействует с системой только через Delegate-классы. Delegate-классы получаются посредством запроса фабрики Delegates, которая в зависимости от конфигурации возвращает нужную реализацию. Классы Delegate являются частью клиентского API.

                                                        Список основных Delegate-классов:

                                                        AuthenticationServiceDelegate – содержит методы для аутентификации пользователей в системе (с использованием логина/пароля, Kerberos и т.п.)
                                                        AuthorizationServiceDelegate — содержит методы для работы с полномочиями пользователей (назначение полномочий, проверка на допустимость операции для пользователя и т.п.)
                                                        BotServiceDelegate — содержит методы для работы с бот станциями и ботами
                                                        ExecutorServiceDelegate — содержит методы для работы с исполнителями. Позволяет создавать/удалять/изменять исполнителей а так же включать их в группы
                                                        ProfileServiceDelegate — содержит методы для работы с профайлам пользователей
                                                        SubstitutionServiceDelegate — содержит методы для управления правилами замещения
                                                        SystemServiceDelegate — содержит методы для входа/выхода пользователя в систему
                                                        DefinitionServiceDelegate — содержит методы для работы с определениями процессов
                                                        ExecutionServiceDelegate — содержит методы для работы с исполняемыми экземплярами процессов
                                                        Все существующие в данный момент Delegate-классы реализуют требуемую функциональность при помощи технологии EJB.

                                                        # Слой Service
                                                        Слой service – это серверное API доступа к системе. Реализации Delegate интерфейсов обращаются именно к этому слою. Каждый Delegate работает с одним соответствующим классом Service. В настоящее время все разработанные service классы и интерфейсы ориентированы на EJB-технологию, однако в будущем возможны и другие реализации. Реализации классов Service являются Stateless Session Bean EJB, которые декларативно поддерживают транзакционность вызовов и запрашивают соответствующие классы из слоя Logic.

                                                        Таким образом, классы Delegate – Service - Logic образуют как бы «транспорт» между клиентом и сервером.

                                                        # Слой Logic
                                                        Слой Logic – это реализация бизнес логики работы системы. Слой работает с классами слоя DAO для доступа к постоянному хранилищу.

                                                        # Слой DAO
                                                        Слой DAO – это интерфейсы и классы, обеспечивающие доступ к данным, находящимся в постоянном хранилище (базе данных). В настоящее время все DAO-классы системы реализованы при помощи ORM-средства Hibernate.

                                                        # Использование Hibernate
                                                        Hibernate – ORM (Object/Relational Mapping) средство. Отображает объектную архитектуру на реляционную структуру данных. Допускает настройку (не меняя разработанного кода) на большинство существующих серверов реляционных баз данных.

                                                        Поддерживает работу с распределенными транзакциями, автоматически создает таблицы для новых классов и т.д. Вся работа с данными внутри системы ведется только через Hibernate.

                                                        Все компоненты, предоставляющие клиентское API построены с использованием описанных выше слоев. В целях оптимизации в некоторых компонентах применяется кеширование, которое может встречаться на уровне logic или DAO. Основная функциональность по управлению кешами находится в классах CachingLogic, CacheInterceptor и классах соответствующих кешей. Изменения в кешируемых объектах перехватываются и сообщаются посредством CachingLogic всем подписавшимся на изменения классам кешей. Транзакция, изменяющая кеш, считается закрытой по окончанию обработки ejb вызова.

                                                        # Обновление базы данных
                                                        см. описание системы патчей.

                                                        # API
                                                        Система представляет API для интеграции с другими системами:

                                                        # Java API
                                                        Реализация (снизу вверх): БД - Hibernate3 - EJB3

                                                        Документацию можно смотреть в исходном коде (javadocs в *Service.java).

                                                        # WebServices API
                                                        Реализация (снизу вверх): БД - Hibernate3 - JAX-WS

                                                        Документация: WebServicesDeveloperGuide

                                                        # Scripting API
                                                        Реализация (снизу вверх): БД - Hibernate3 - XML Script

                                                        Документация: AdminScriptGuide

                                                        # Процесс сборки из исходного кода
                                                        Исходный код системы доступен в открытом репозитории на github.

                                                        Сервер можно собирать как средствами maven используя командную строку, так и используя среду Eclipse IDE.

                                                        В результате сборки будет сформирован runawfe.ear, который теоретически можно запустить на любом сервере приложений. Начиная с версии 4.3.0 введена поддержка JAVA версии 8, и отказ от JAVA 6. В дальнейшем планируется отказ от java7, поэтому рекомендуется использовать сервер приложений wildfly.

                                                        # Процесс сборки на примере Eclipse IDE
                                                        # Необходимое программное обеспечение для сборки
                                                        В отличие от Среды разработки для сборки сервера можно использовать Eclipse IDE любой версии и редакции.

                                                        установите плагин m2eclipse
                                                        используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу: http://maven.apache.org/
                                                        добавьте путь к Apache Maven директории bin в переменную окружения Path
                                                        # Импорт проектов
                                                        Импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server.

                                                        Eclipse srv proj.png

                                                        # Установка maven артефактов
                                                        Выполните

                                                        ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                                                        ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                                                        или другим способом установите артефакты в локальный репозиторий

                                                        # Сборка
                                                        Заведите конфигурацию запуска на основе maven как показано на рисунке

                                                        Maven.build.configuration.png

                                                        Запустите конфигурацию.

                                                        Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\eclipse-workspace\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"

                                                        # Сборка из командной строки
                                                        используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу http://maven.apache.org/
                                                        добавьте путь к Apache Maven директории bin в переменную окружения Path
                                                        импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server
                                                        выполните обновление зависимостей
                                                        ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                                                        ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                                                        откройте командную строку
                                                        перейдите в директорию ${wfe}/wfe-app/
                                                        выполните команду для сборки
                                                        mvn clean package -Dmaven.test.skip=true
                                                        Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"


                                                        Для установки артефактов в локальный репозиторий используйте команду

                                                        mvn clean install -Dmaven.test.skip=true
                                                        # Использование ear на сервере приложений
                                                        cкачайте текущую версию RunaWFE в виде файл-архива исполняемых java файлов runawfe-wildfly-java8-*.zip (на базе wildfly, java8)
                                                        распакуйте архив
                                                        обновите runawfe.ear на версию полученную в результате сборки
                                                        # Расширение функциональности
                                                        # Точки расширения системы
                                                        Обработчики позволяют исполнить код в процессах (элементы "Обработчик", "Задача сценария") и ботах
                                                        Форматы переменных определяют тип переменных и правила преобразования значений к текстовому представлению и обратно
                                                        Организационные функции используются при назначении ролей и в правилах замещения для определения заместителя
                                                        Критерии замещения используются в подсистеме замещения для определения заместителя при построении списка заданий
                                                        Валидаторы обеспечивают проверку переменных при выполнении задания (в т.ч. введенные значения форм)
                                                        Freemarker теги форм генерируют html код для отображения на форме
                                                        Ajax команды предоставляют доступ к функциональности сервера из JavaScript
                                                        # Процесс разработки расширений
                                                        Создайте новый java-проект и подключите необходимые зависимости (wfe-core, wfe-service).

                                                        Реализуйте в нем требуемые расширения и соберите его в виде jar-файла.

                                                        Замечание. Использование maven облегчит процесс управления зависимостями.

                                                        Разместить собранный jar на сервере вы можете:

                                                        положив его в runawfe.ear!/lib
                                                        положив его в директорию deploy (только для jboss4)
                                                        положив его в ${jboss.server.base.dir}/wfe.custom (только для jboss7)
                                                        положив его в ${jboss.server.base.dir}/${jboss.server.name}/wfe.custom (только для jboss4)
                                                        # Обработчики
                                                        Обработчик в процессе – компонент процесса (элементы "Обработчик", "Задача сценария"), использующийся для выполнения каких-либо действий при возникновении определенных событий (проход по определенному переходу в процессе, приход или уход управления из узла и т.п.).

                                                        Обработчик должен реализовывать интерфейс ru.runa.wfe.extension.ActionHandler. Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов Spring контекста (например с помощью аннотации @Autowired).

                                                        При написании нового обработчика рекомендуется наследовать его от абстрактного класса ru.runa.wfe.extension.handler.CommonHandler или ru.runa.wfe.extension.handler.CommonParamBasedHandler. В методе setConfiguration обработчик должен запомнить свои параметры (если обработчик их ожидает), а в методе execute происходит непосредственная обработка и выполнение требуемых действий.

                                                        В случае, если при выполнении обработчика произошла ошибка, произойдет откат транзакции и состояние процесса будет возвращено к заданию, исполнение которого повлекло вызов обработчика. В интерфейсе обработчика для бота ru.runa.wfe.extension.TaskHandler предусмотрен метод onRollback для работы с не-транзакционными ресурсами.

                                                        Эти обработчики удобно использовать для простых операций (например для отправки оповещений в виде SMS-сообщений если процесс попал в определенное состояние). Но у них есть несколько ограничений. Прежде всего у них нет соответствующего объекта контекста безопасности (security context). Это означает, что в них нельзя выполнять защищенные методы (запуск процессов, выполнение задач, создание пользователей и т.п.) Ошибочным решением в них будет блокирование выполнения процесса (например с Thread::Sleep(...)). Например, если в обработчике отправляется e-mail, а SMTP сервер недоступен, обработчику нельзя "задерживать" свое выполнение.

                                                        Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                                                        # Специфика обработчиков для ботов
                                                        Бот - это сокращение от робот. В системе боты - это особый тип исполнителей. Система не отличает ботов от людей. У каждого бота есть свои права на вход в систему, он периодически просыпается, проверяет свой список задачи и выполняет обнаруженные там задачи.

                                                        Каждая задача бота обрабатывается при помощи соответствующего обработчика. Чтобы написать новый обработчик нужно реализовать интерфейс ru.runa.wfe.extension.TaskHandler.

                                                        Обратите внимание, что этот вид обработчиков выполняется в контексте безопасности (security context) пользователя-бота, и здесь может выполнятся любая операция (если у бота есть на это права).

                                                        Обработчики задач ботов могут блокировать выполнение процесса.

                                                        Например, обработчик задач, отправляющий e-mail может блокировать выполнение бизнес процесса до тех пор, пока обработчик не удостоверится, что SMTP сервер принял сообщение для последующей доставки.

                                                        Обработчики задач вызываются периодически, когда боты проверяют свои списки задач.

                                                        # Специфика обработчика для элемента ветвление
                                                        Обработчик для Decision является java-классом, реализующим интерфейс ru.runa.wfe.extension.DecisionHandler. Интерфейс содержит один метод decide(ExecutionContext executionContext), который возвращает имя выбранного перехода (одного из выходящих из данного ветвления). Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов контекста спринга (например с помощью аннотации @Autowired).

                                                        Обработчик принимает ExecutionContext в качестве входящего параметра и должен сделать выбор перехода исходя из значений переменных бизнес процесса и условий, указанных в конфигурации обработчика. Точно также как обработчики действия (action handler) обработчики выбора (decision handlers) не могут использовать защищенные (secured) методы, не могут обрабатывать ошибки и откладывать выбор перехода до лучших времен.

                                                        По умолчанию используется ru.runa.wfe.extension.decision.GroovyDecisionHandler.

                                                        # Использование ru.runa.wfe.extension.handler.CommonParamBasedHandler в качестве базового класса
                                                        Этот класс инкапсулирует в себе парсинг XML конфигурации определенного формата. Его удобно использовать если обработчик имеет фиксированное число параметров. Пример конфигурации:

                                                        <?xml version="1.0" encoding="UTF-8"?>
                                                        <config>
                                                         <input>
                                                           <param name="typeName" variable="тип отсутствия" />
                                                           <param name="employee" variable="сотрудник" />
                                                           <param name="requester" variable="подавший заявку" />
                                                           <param name="from" variable="дата с" />
                                                           <param name="to" variable="дата по" />
                                                           <param name="cause" variable="причина" />
                                                           <param name="comment" variable="комментарий" />
                                                           <param name="confirmation" variable="дата подтверждения" />
                                                           <param name="firmCode" value="111" />
                                                           <param name="firmPositionCode" variable="код должности" />
                                                           <param name="firmDepartmentCode" variable="код подразделения" />
                                                         </input>
                                                         <output>
                                                           <param name="uuid" variable="идентификатор объекта" />
                                                         </output>
                                                        </config>
                                                        Использование обработчика Groovy
                                                        См. соответствующий раздел в руководстве по работе с Groovy.

                                                        # Как написать функцию над организационной структурой
                                                        Функции над организационной структурой в системе применяются, например, при инициализации Ролей-Дорожек и в правилах замещения.

                                                        Класс, соответствующий функции над организационной структурой, должен реализовывать интерфейс ru.runa.wfe.extension.OrgFunction.

                                                        Интерфейс содержит один метод

                                                        List<? extends Executor> getExecutors(Object... parameters)
                                                        Этот метод должен возвращать список исполнителей.

                                                        В бизнес-процессе обработчик функции над оргструктурой используются при определении Ролей-Дорожек: указывается внутри тега swimlane, в теле тега <assignment>.В качестве параметра class тега <assignment> указывается класс-обработчик для инициализации swimlane: ru.runa.wfe.extension.AssignmentHandler. Внутри тега <assignment> содержится конфигурация для этого класса, которая представляет собой имя класса-наследника интерфейса OrgFunction и список параметров в скобках. В качестве параметра может выступать конкретное значение или имя переменной бизнес процесса в фигурных скобках, перед которым стоит значок $

                                                        Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                                                        Если есть планы по использованию функции в подсистеме замещений - её можно зарегистрировать в substitutions.xml.

                                                        # Как написать критерий замещения
                                                        Критерии замещения в системе применяются в правилах замещения. Класс, соответствующий критерию замещения, должен наследоваться от ru.runa.wfe.ss.SubstitutionCriteria.

                                                        Для создания на основе него конечных критериев замещения с конфигурациями - его нужно зарегистрировать в substitution.criterias.xml.

                                                        Как реализовать класс-формат для переменных бизнес-процесса
                                                        См. соответствующий раздел в руководстве по работе с переменными.

                                                        # Как реализовать валидатор переменных
                                                        Классы, расширяющие абстрактный класс ru.runa.wfe.validation.FieldValidator, в системе применяются для проверки переменных при выполнении задания или старте процесса.

                                                        Пример:

                                                        public class OvertimeWorkRequestTimeCheck extends FieldValidator {
                                                           @Override
                                                           public void validate() {
                                                               Date date = (Date) getFieldValue();
                                                               if (date == null) {
                                                                   return;
                                                               }
                                                               boolean testMode = getVariableProvider().getValueNotNull(boolean.class, "тестовый режим");
                                                               if (testMode) {
                                                                   return;
                                                               }
                                                               Calendar calendar = CalendarUtil.dateToCalendar(date);
                                                               if (calendar.before(Calendar.getInstance())) {
                                                                   addError("Заявка не может быть оформлена задним числом");
                                                                   return;
                                                               }
                                                               CalendarUtil.setTimeFromCalendar(calendar, DemoProperties.getOvertimeWorkRequestMaximumStartTime());
                                                               Utils.adjustCalendarForHolidaysInOvertimwWork(calendar);
                                                               if (calendar.before(Calendar.getInstance())) {
                                                                   addError("Заявка на этот день не может быть подана, время подачи истекло " + CalendarUtil.formatDateTime(calendar));
                                                               }
                                                           }
                                                        }

                                                        Связь между Средой разработки и сервером осуществляется по имени валидатора, регистрация требуется на стороне сервера в файле validators.xml, а в среде разработки - в plugin.xml.

                                                        # Как реализовать FreeMarker тег для формы
                                                        FreemarkerForms#Components

                                                        # Как реализовать Ajax команду
                                                        Классы, расширяющие абстрактный класс ru.runa.wfe.commons.web.JsonAjaxCommand, (или реализующие ru.runa.wfe.commons.web.AjaxCommand) в системе применяются для доступа к функциональности сервера из JavaScript, например при отображении форм задания.

                                                        Регистрация команды происходит любым из двух способов:

                                                        в файле ajax.commands.xml, ей присваивается определенное имя
                                                        в контексте приложения, именем является id spring-бина
                                                        Затем по этому имени её можно выполнить используя JavaScript.

                                                        Пример команды

                                                        public class GetOrganizationNamesCommand extends JsonAjaxCommand {
                                                           @Autowired
                                                           private OrganizationDAO organizationDAO;
                                                           @Override
                                                           protected JSONAware execute(User user, HttpServletRequest request) throws Exception {
                                                               String term = request.getParameter("term");
                                                               if (term == null) {
                                                                   term = "";
                                                               }
                                                               List<Organization> organizations = organizationDAO.getAll();
                                                               JSONArray array = new JSONArray();
                                                               for (Organization organization : organizations) {
                                                                   if (organization.getName().startsWith(term)) {
                                                                       array.add(organization.getName());
                                                                   }
                                                               }
                                                               return array;
                                                           }
                                                        }
                                                        Регистрация в wfe.custom.ajax.commands.xml

                                                        <?xml version="1.0" encoding="UTF-8" ?>
                                                        <configuration xmlns="http://runa.ru/xml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://runa.ru/xml">
                                                         <command name="getOrganizationNames" class="ru.runa.rkdemo.web.ajax.GetOrganizationNamesCommand" />
                                                        </configuration>
                                                        Её использование со скрипта формы (autocomplete input)

                                                        $(document).ready(function() {
                                                         $('#editLinkedLists').on("onRowAdded", function(event, rowIndex) {
                                                          $("input[name='названия организаций["+rowIndex+"]']").autocomplete( {
                                                           delay: 300,
                                                           minLength: 0,
                                                           source: "/wfe/ajaxcmd?command=getOrganizationNames"
                                                          });
                                                          $("input[name='названия организаций["+rowIndex+"]']").focus(function() {
                                                           $(this).autocomplete("search", $(this).val());
                                                          });
                                                         });
                                                        });Введение
                                                           # Основные компоненты и используемые технологии
                                                           Для WF–системы была выбрана следующая общая архитектура (в целом соответствует архитектуре, предлагаемой коалицией WfMC):

                                                           Компоненты системы:

                                                           Ядро системы
                                                           Содержит набор определений бизнес-процессов
                                                           Содержит набор выполняющихся экземпляров бизнес–процессов
                                                           Компонент, "назначающий" исполнителей для действий
                                                           Клиент
                                                           Список заданий (набор графических форм, содержит очереди поступивших работ, сортировки и фильтры)
                                                           Проигрыватель форм (отображает формы, разработанные в Среде разработки)
                                                           Административный интерфейс
                                                           Показывает состояния процессов, позволяет фильтровать и останавливать процессы
                                                           Позволяет загружать-выгружать процессы
                                                           Позволяет заводить-удалять пользователей
                                                           Позволяет задавать различные права
                                                           Редактор назначения заместителей
                                                           Среда разработки
                                                           Конструктор графических форм
                                                           Бот станции, содержащие ботов (Боты - приложения специального вида, которые также как и обычные пользователи могут выполнять задания)
                                                           Подсистема управления правами доступа (авторизация и аутентификация)
                                                           # Платформа программирования и используемые программные средства
                                                           В качестве платформы программирования используется J2EE.

                                                           Используемые программные средства:

                                                           Сервер приложений - JBOSS (http://www.jboss.org).
                                                           Среда разработки - любая, например Eclipse от IBM (http://www.eclipse.org).
                                                           Система контроля версий - git
                                                           Сборщик приложений – maven.
                                                           Сервер баз данных – поддерживаются сервера БД:
                                                           MS SQL Server (http://www.microsoft.com/sql/evaluation/default.mspx)
                                                           HSQL (http://hsqldb.org)
                                                           Oracle (http://www.oracle.com)
                                                           PostgreSQL (http://postgresql.com)
                                                           Операционная система — поддерживаются следующие ОС:
                                                           Windows (Server 2000-2008, XP, Vista, 7)
                                                           ALTLinux
                                                           Mandriva Linux
                                                           Fedora
                                                           Debian/Ubuntu
                                                           # Описание проектов
                                                           Название проекта	Обязателен при сборке	Обязателен при работе	Зависимости	Описание
                                                           wfe-alfresco	нет	нет	runawfe-app	Интеграция с Alfresco
                                                           wfe-app	да	да	wfe-ear, wfe-cactus-it	Проект для организации сборки maven
                                                           wfe-appserver	нет	нет	 ?	Не используется
                                                           wfe-bots	да	да	wfe-service	Подсистема ботов
                                                           wfe-cactus-it	да	нет	wfe-service	Интеграционные тесты
                                                           wfe-core	да	да	-	Основные компоненты системы
                                                           wfe-ear	да	да	wfe-service, wfe-bots, wfe-office, wfe-web	Проект для сборки runawfe.ear
                                                           wfe-office	да	нет	wfe-core	Обработчики для работы с Word, Excel
                                                           wfe-service	да	да	wfe-core	Сервисы (EJB + WebServices), представляющие собой публичное API приложения
                                                           wfe-web	да	да	wfe-bots	Визуальная часть приложения
                                                           wfe-webservice-client	нет	нет	 ?	Авто-генерации клиентской библиотеки на основе WSDL серверных сервисов. В нем же есть примеры использования веб-служб из Java клиента.
                                                           # Описание слоев архитектуры системы
                                                           Каждый компонент состоит из нескольких уровней (слоев).

                                                           Список слоев:

                                                           delegate
                                                           service
                                                           logic
                                                           DAO
                                                           hibernate
                                                           # Слой Delegate
                                                           Delegate-классы, реализующие сервисные интерфейсы представляют собой pattern проектирования BusinessDelegate, упрощающий доступ к серверному API системы. Клиентское приложение взаимодействует с системой только через Delegate-классы. Delegate-классы получаются посредством запроса фабрики Delegates, которая в зависимости от конфигурации возвращает нужную реализацию. Классы Delegate являются частью клиентского API.

                                                           Список основных Delegate-классов:

                                                           AuthenticationServiceDelegate – содержит методы для аутентификации пользователей в системе (с использованием логина/пароля, Kerberos и т.п.)
                                                           AuthorizationServiceDelegate — содержит методы для работы с полномочиями пользователей (назначение полномочий, проверка на допустимость операции для пользователя и т.п.)
                                                           BotServiceDelegate — содержит методы для работы с бот станциями и ботами
                                                           ExecutorServiceDelegate — содержит методы для работы с исполнителями. Позволяет создавать/удалять/изменять исполнителей а так же включать их в группы
                                                           ProfileServiceDelegate — содержит методы для работы с профайлам пользователей
                                                           SubstitutionServiceDelegate — содержит методы для управления правилами замещения
                                                           SystemServiceDelegate — содержит методы для входа/выхода пользователя в систему
                                                           DefinitionServiceDelegate — содержит методы для работы с определениями процессов
                                                           ExecutionServiceDelegate — содержит методы для работы с исполняемыми экземплярами процессов
                                                           Все существующие в данный момент Delegate-классы реализуют требуемую функциональность при помощи технологии EJB.

                                                           # Слой Service
                                                           Слой service – это серверное API доступа к системе. Реализации Delegate интерфейсов обращаются именно к этому слою. Каждый Delegate работает с одним соответствующим классом Service. В настоящее время все разработанные service классы и интерфейсы ориентированы на EJB-технологию, однако в будущем возможны и другие реализации. Реализации классов Service являются Stateless Session Bean EJB, которые декларативно поддерживают транзакционность вызовов и запрашивают соответствующие классы из слоя Logic.

                                                           Таким образом, классы Delegate – Service - Logic образуют как бы «транспорт» между клиентом и сервером.

                                                           # Слой Logic
                                                           Слой Logic – это реализация бизнес логики работы системы. Слой работает с классами слоя DAO для доступа к постоянному хранилищу.

                                                           # Слой DAO
                                                           Слой DAO – это интерфейсы и классы, обеспечивающие доступ к данным, находящимся в постоянном хранилище (базе данных). В настоящее время все DAO-классы системы реализованы при помощи ORM-средства Hibernate.

                                                           # Использование Hibernate
                                                           Hibernate – ORM (Object/Relational Mapping) средство. Отображает объектную архитектуру на реляционную структуру данных. Допускает настройку (не меняя разработанного кода) на большинство существующих серверов реляционных баз данных.

                                                           Поддерживает работу с распределенными транзакциями, автоматически создает таблицы для новых классов и т.д. Вся работа с данными внутри системы ведется только через Hibernate.

                                                           Все компоненты, предоставляющие клиентское API построены с использованием описанных выше слоев. В целях оптимизации в некоторых компонентах применяется кеширование, которое может встречаться на уровне logic или DAO. Основная функциональность по управлению кешами находится в классах CachingLogic, CacheInterceptor и классах соответствующих кешей. Изменения в кешируемых объектах перехватываются и сообщаются посредством CachingLogic всем подписавшимся на изменения классам кешей. Транзакция, изменяющая кеш, считается закрытой по окончанию обработки ejb вызова.

                                                           # Обновление базы данных
                                                           см. описание системы патчей.

                                                           # API
                                                           Система представляет API для интеграции с другими системами:

                                                           # Java API
                                                           Реализация (снизу вверх): БД - Hibernate3 - EJB3

                                                           Документацию можно смотреть в исходном коде (javadocs в *Service.java).

                                                           # WebServices API
                                                           Реализация (снизу вверх): БД - Hibernate3 - JAX-WS

                                                           Документация: WebServicesDeveloperGuide

                                                           # Scripting API
                                                           Реализация (снизу вверх): БД - Hibernate3 - XML Script

                                                           Документация: AdminScriptGuide

                                                           # Процесс сборки из исходного кода
                                                           Исходный код системы доступен в открытом репозитории на github.

                                                           Сервер можно собирать как средствами maven используя командную строку, так и используя среду Eclipse IDE.

                                                           В результате сборки будет сформирован runawfe.ear, который теоретически можно запустить на любом сервере приложений. Начиная с версии 4.3.0 введена поддержка JAVA версии 8, и отказ от JAVA 6. В дальнейшем планируется отказ от java7, поэтому рекомендуется использовать сервер приложений wildfly.

                                                           # Процесс сборки на примере Eclipse IDE
                                                           # Необходимое программное обеспечение для сборки
                                                           В отличие от Среды разработки для сборки сервера можно использовать Eclipse IDE любой версии и редакции.

                                                           установите плагин m2eclipse
                                                           используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу: http://maven.apache.org/
                                                           добавьте путь к Apache Maven директории bin в переменную окружения Path
                                                           # Импорт проектов
                                                           Импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server.

                                                           Eclipse srv proj.png

                                                           # Установка maven артефактов
                                                           Выполните

                                                           ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                                                           ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                                                           или другим способом установите артефакты в локальный репозиторий

                                                           # Сборка
                                                           Заведите конфигурацию запуска на основе maven как показано на рисунке

                                                           Maven.build.configuration.png

                                                           Запустите конфигурацию.

                                                           Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\eclipse-workspace\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"

                                                           # Сборка из командной строки
                                                           используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу http://maven.apache.org/
                                                           добавьте путь к Apache Maven директории bin в переменную окружения Path
                                                           импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server
                                                           выполните обновление зависимостей
                                                           ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                                                           ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                                                           откройте командную строку
                                                           перейдите в директорию ${wfe}/wfe-app/
                                                           выполните команду для сборки
                                                           mvn clean package -Dmaven.test.skip=true
                                                           Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"


                                                           Для установки артефактов в локальный репозиторий используйте команду

                                                           mvn clean install -Dmaven.test.skip=true
                                                           # Использование ear на сервере приложений
                                                           cкачайте текущую версию RunaWFE в виде файл-архива исполняемых java файлов runawfe-wildfly-java8-*.zip (на базе wildfly, java8)
                                                           распакуйте архив
                                                           обновите runawfe.ear на версию полученную в результате сборки
                                                           # Расширение функциональности
                                                           # Точки расширения системы
                                                           Обработчики позволяют исполнить код в процессах (элементы "Обработчик", "Задача сценария") и ботах
                                                           Форматы переменных определяют тип переменных и правила преобразования значений к текстовому представлению и обратно
                                                           Организационные функции используются при назначении ролей и в правилах замещения для определения заместителя
                                                           Критерии замещения используются в подсистеме замещения для определения заместителя при построении списка заданий
                                                           Валидаторы обеспечивают проверку переменных при выполнении задания (в т.ч. введенные значения форм)
                                                           Freemarker теги форм генерируют html код для отображения на форме
                                                           Ajax команды предоставляют доступ к функциональности сервера из JavaScript
                                                           # Процесс разработки расширений
                                                           Создайте новый java-проект и подключите необходимые зависимости (wfe-core, wfe-service).

                                                           Реализуйте в нем требуемые расширения и соберите его в виде jar-файла.

                                                           Замечание. Использование maven облегчит процесс управления зависимостями.

                                                           Разместить собранный jar на сервере вы можете:

                                                           положив его в runawfe.ear!/lib
                                                           положив его в директорию deploy (только для jboss4)
                                                           положив его в ${jboss.server.base.dir}/wfe.custom (только для jboss7)
                                                           положив его в ${jboss.server.base.dir}/${jboss.server.name}/wfe.custom (только для jboss4)
                                                           # Обработчики
                                                           Обработчик в процессе – компонент процесса (элементы "Обработчик", "Задача сценария"), использующийся для выполнения каких-либо действий при возникновении определенных событий (проход по определенному переходу в процессе, приход или уход управления из узла и т.п.).

                                                           Обработчик должен реализовывать интерфейс ru.runa.wfe.extension.ActionHandler. Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов Spring контекста (например с помощью аннотации @Autowired).

                                                           При написании нового обработчика рекомендуется наследовать его от абстрактного класса ru.runa.wfe.extension.handler.CommonHandler или ru.runa.wfe.extension.handler.CommonParamBasedHandler. В методе setConfiguration обработчик должен запомнить свои параметры (если обработчик их ожидает), а в методе execute происходит непосредственная обработка и выполнение требуемых действий.

                                                           В случае, если при выполнении обработчика произошла ошибка, произойдет откат транзакции и состояние процесса будет возвращено к заданию, исполнение которого повлекло вызов обработчика. В интерфейсе обработчика для бота ru.runa.wfe.extension.TaskHandler предусмотрен метод onRollback для работы с не-транзакционными ресурсами.

                                                           Эти обработчики удобно использовать для простых операций (например для отправки оповещений в виде SMS-сообщений если процесс попал в определенное состояние). Но у них есть несколько ограничений. Прежде всего у них нет соответствующего объекта контекста безопасности (security context). Это означает, что в них нельзя выполнять защищенные методы (запуск процессов, выполнение задач, создание пользователей и т.п.) Ошибочным решением в них будет блокирование выполнения процесса (например с Thread::Sleep(...)). Например, если в обработчике отправляется e-mail, а SMTP сервер недоступен, обработчику нельзя "задерживать" свое выполнение.

                                                           Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                                                           # Специфика обработчиков для ботов
                                                           Бот - это сокращение от робот. В системе боты - это особый тип исполнителей. Система не отличает ботов от людей. У каждого бота есть свои права на вход в систему, он периодически просыпается, проверяет свой список задачи и выполняет обнаруженные там задачи.

                                                           Каждая задача бота обрабатывается при помощи соответствующего обработчика. Чтобы написать новый обработчик нужно реализовать интерфейс ru.runa.wfe.extension.TaskHandler.

                                                           Обратите внимание, что этот вид обработчиков выполняется в контексте безопасности (security context) пользователя-бота, и здесь может выполнятся любая операция (если у бота есть на это права).

                                                           Обработчики задач ботов могут блокировать выполнение процесса.

                                                           Например, обработчик задач, отправляющий e-mail может блокировать выполнение бизнес процесса до тех пор, пока обработчик не удостоверится, что SMTP сервер принял сообщение для последующей доставки.

                                                           Обработчики задач вызываются периодически, когда боты проверяют свои списки задач.

                                                           # Специфика обработчика для элемента ветвление
                                                           Обработчик для Decision является java-классом, реализующим интерфейс ru.runa.wfe.extension.DecisionHandler. Интерфейс содержит один метод decide(ExecutionContext executionContext), который возвращает имя выбранного перехода (одного из выходящих из данного ветвления). Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов контекста спринга (например с помощью аннотации @Autowired).

                                                           Обработчик принимает ExecutionContext в качестве входящего параметра и должен сделать выбор перехода исходя из значений переменных бизнес процесса и условий, указанных в конфигурации обработчика. Точно также как обработчики действия (action handler) обработчики выбора (decision handlers) не могут использовать защищенные (secured) методы, не могут обрабатывать ошибки и откладывать выбор перехода до лучших времен.

                                                           По умолчанию используется ru.runa.wfe.extension.decision.GroovyDecisionHandler.

                                                           # Использование ru.runa.wfe.extension.handler.CommonParamBasedHandler в качестве базового класса
                                                           Этот класс инкапсулирует в себе парсинг XML конфигурации определенного формата. Его удобно использовать если обработчик имеет фиксированное число параметров. Пример конфигурации:

                                                           <?xml version="1.0" encoding="UTF-8"?>
                                                           <config>
                                                            <input>
                                                              <param name="typeName" variable="тип отсутствия" />
                                                              <param name="employee" variable="сотрудник" />
                                                              <param name="requester" variable="подавший заявку" />
                                                              <param name="from" variable="дата с" />
                                                              <param name="to" variable="дата по" />
                                                              <param name="cause" variable="причина" />
                                                              <param name="comment" variable="комментарий" />
                                                              <param name="confirmation" variable="дата подтверждения" />
                                                              <param name="firmCode" value="111" />
                                                              <param name="firmPositionCode" variable="код должности" />
                                                              <param name="firmDepartmentCode" variable="код подразделения" />
                                                            </input>
                                                            <output>
                                                              <param name="uuid" variable="идентификатор объекта" />
                                                            </output>
                                                           </config>
                                                           Использование обработчика Groovy
                                                           См. соответствующий раздел в руководстве по работе с Groovy.

                                                           # Как написать функцию над организационной структурой
                                                           Функции над организационной структурой в системе применяются, например, при инициализации Ролей-Дорожек и в правилах замещения.

                                                           Класс, соответствующий функции над организационной структурой, должен реализовывать интерфейс ru.runa.wfe.extension.OrgFunction.

                                                           Интерфейс содержит один метод

                                                           List<? extends Executor> getExecutors(Object... parameters)
                                                           Этот метод должен возвращать список исполнителей.

                                                           В бизнес-процессе обработчик функции над оргструктурой используются при определении Ролей-Дорожек: указывается внутри тега swimlane, в теле тега <assignment>.В качестве параметра class тега <assignment> указывается класс-обработчик для инициализации swimlane: ru.runa.wfe.extension.AssignmentHandler. Внутри тега <assignment> содержится конфигурация для этого класса, которая представляет собой имя класса-наследника интерфейса OrgFunction и список параметров в скобках. В качестве параметра может выступать конкретное значение или имя переменной бизнес процесса в фигурных скобках, перед которым стоит значок $

                                                           Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                                                           Если есть планы по использованию функции в подсистеме замещений - её можно зарегистрировать в substitutions.xml.

                                                           # Как написать критерий замещения
                                                           Критерии замещения в системе применяются в правилах замещения. Класс, соответствующий критерию замещения, должен наследоваться от ru.runa.wfe.ss.SubstitutionCriteria.

                                                           Для создания на основе него конечных критериев замещения с конфигурациями - его нужно зарегистрировать в substitution.criterias.xml.

                                                           Как реализовать класс-формат для переменных бизнес-процесса
                                                           См. соответствующий раздел в руководстве по работе с переменными.

                                                           # Как реализовать валидатор переменных
                                                           Классы, расширяющие абстрактный класс ru.runa.wfe.validation.FieldValidator, в системе применяются для проверки переменных при выполнении задания или старте процесса.

                                                           Пример:

                                                           public class OvertimeWorkRequestTimeCheck extends FieldValidator {
                                                              @Override
                                                              public void validate() {
                                                                  Date date = (Date) getFieldValue();
                                                                  if (date == null) {
                                                                      return;
                                                                  }
                                                                  boolean testMode = getVariableProvider().getValueNotNull(boolean.class, "тестовый режим");
                                                                  if (testMode) {
                                                                      return;
                                                                  }
                                                                  Calendar calendar = CalendarUtil.dateToCalendar(date);
                                                                  if (calendar.before(Calendar.getInstance())) {
                                                                      addError("Заявка не может быть оформлена задним числом");
                                                                      return;
                                                                  }
                                                                  CalendarUtil.setTimeFromCalendar(calendar, DemoProperties.getOvertimeWorkRequestMaximumStartTime());
                                                                  Utils.adjustCalendarForHolidaysInOvertimwWork(calendar);
                                                                  if (calendar.before(Calendar.getInstance())) {
                                                                      addError("Заявка на этот день не может быть подана, время подачи истекло " + CalendarUtil.formatDateTime(calendar));
                                                                  }
                                                              }
                                                           }

                                                           Связь между Средой разработки и сервером осуществляется по имени валидатора, регистрация требуется на стороне сервера в файле validators.xml, а в среде разработки - в plugin.xml.

                                                           # Как реализовать FreeMarker тег для формы
                                                           FreemarkerForms#Components

                                                           # Как реализовать Ajax команду
                                                           Классы, расширяющие абстрактный класс ru.runa.wfe.commons.web.JsonAjaxCommand, (или реализующие ru.runa.wfe.commons.web.AjaxCommand) в системе применяются для доступа к функциональности сервера из JavaScript, например при отображении форм задания.

                                                           Регистрация команды происходит любым из двух способов:

                                                           в файле ajax.commands.xml, ей присваивается определенное имя
                                                           в контексте приложения, именем является id spring-бина
                                                           Затем по этому имени её можно выполнить используя JavaScript.

                                                           Пример команды

                                                           public class GetOrganizationNamesCommand extends JsonAjaxCommand {
                                                              @Autowired
                                                              private OrganizationDAO organizationDAO;
                                                              @Override
                                                              protected JSONAware execute(User user, HttpServletRequest request) throws Exception {
                                                                  String term = request.getParameter("term");
                                                                  if (term == null) {
                                                                      term = "";
                                                                  }
                                                                  List<Organization> organizations = organizationDAO.getAll();
                                                                  JSONArray array = new JSONArray();
                                                                  for (Organization organization : organizations) {
                                                                      if (organization.getName().startsWith(term)) {
                                                                          array.add(organization.getName());
                                                                      }
                                                                  }
                                                                  return array;
                                                              }
                                                           }
                                                           Регистрация в wfe.custom.ajax.commands.xml

                                                           <?xml version="1.0" encoding="UTF-8" ?>
                                                           <configuration xmlns="http://runa.ru/xml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://runa.ru/xml">
                                                            <command name="getOrganizationNames" class="ru.runa.rkdemo.web.ajax.GetOrganizationNamesCommand" />
                                                           </configuration>
                                                           Её использование со скрипта формы (autocomplete input)

                                                           $(document).ready(function() {
                                                            $('#editLinkedLists').on("onRowAdded", function(event, rowIndex) {
                                                             $("input[name='названия организаций["+rowIndex+"]']").autocomplete( {
                                                              delay: 300,
                                                              minLength: 0,
                                                              source: "/wfe/ajaxcmd?command=getOrganizationNames"
                                                             });
                                                             $("input[name='названия организаций["+rowIndex+"]']").focus(function() {
                                                              $(this).autocomplete("search", $(this).val());
                                                             });
                                                            });
                                                           });Введение
                                                              # Основные компоненты и используемые технологии
                                                              Для WF–системы была выбрана следующая общая архитектура (в целом соответствует архитектуре, предлагаемой коалицией WfMC):

                                                              Компоненты системы:

                                                              Ядро системы
                                                              Содержит набор определений бизнес-процессов
                                                              Содержит набор выполняющихся экземпляров бизнес–процессов
                                                              Компонент, "назначающий" исполнителей для действий
                                                              Клиент
                                                              Список заданий (набор графических форм, содержит очереди поступивших работ, сортировки и фильтры)
                                                              Проигрыватель форм (отображает формы, разработанные в Среде разработки)
                                                              Административный интерфейс
                                                              Показывает состояния процессов, позволяет фильтровать и останавливать процессы
                                                              Позволяет загружать-выгружать процессы
                                                              Позволяет заводить-удалять пользователей
                                                              Позволяет задавать различные права
                                                              Редактор назначения заместителей
                                                              Среда разработки
                                                              Конструктор графических форм
                                                              Бот станции, содержащие ботов (Боты - приложения специального вида, которые также как и обычные пользователи могут выполнять задания)
                                                              Подсистема управления правами доступа (авторизация и аутентификация)
                                                              # Платформа программирования и используемые программные средства
                                                              В качестве платформы программирования используется J2EE.

                                                              Используемые программные средства:

                                                              Сервер приложений - JBOSS (http://www.jboss.org).
                                                              Среда разработки - любая, например Eclipse от IBM (http://www.eclipse.org).
                                                              Система контроля версий - git
                                                              Сборщик приложений – maven.
                                                              Сервер баз данных – поддерживаются сервера БД:
                                                              MS SQL Server (http://www.microsoft.com/sql/evaluation/default.mspx)
                                                              HSQL (http://hsqldb.org)
                                                              Oracle (http://www.oracle.com)
                                                              PostgreSQL (http://postgresql.com)
                                                              Операционная система — поддерживаются следующие ОС:
                                                              Windows (Server 2000-2008, XP, Vista, 7)
                                                              ALTLinux
                                                              Mandriva Linux
                                                              Fedora
                                                              Debian/Ubuntu
                                                              # Описание проектов
                                                              Название проекта	Обязателен при сборке	Обязателен при работе	Зависимости	Описание
                                                              wfe-alfresco	нет	нет	runawfe-app	Интеграция с Alfresco
                                                              wfe-app	да	да	wfe-ear, wfe-cactus-it	Проект для организации сборки maven
                                                              wfe-appserver	нет	нет	 ?	Не используется
                                                              wfe-bots	да	да	wfe-service	Подсистема ботов
                                                              wfe-cactus-it	да	нет	wfe-service	Интеграционные тесты
                                                              wfe-core	да	да	-	Основные компоненты системы
                                                              wfe-ear	да	да	wfe-service, wfe-bots, wfe-office, wfe-web	Проект для сборки runawfe.ear
                                                              wfe-office	да	нет	wfe-core	Обработчики для работы с Word, Excel
                                                              wfe-service	да	да	wfe-core	Сервисы (EJB + WebServices), представляющие собой публичное API приложения
                                                              wfe-web	да	да	wfe-bots	Визуальная часть приложения
                                                              wfe-webservice-client	нет	нет	 ?	Авто-генерации клиентской библиотеки на основе WSDL серверных сервисов. В нем же есть примеры использования веб-служб из Java клиента.
                                                              # Описание слоев архитектуры системы
                                                              Каждый компонент состоит из нескольких уровней (слоев).

                                                              Список слоев:

                                                              delegate
                                                              service
                                                              logic
                                                              DAO
                                                              hibernate
                                                              # Слой Delegate
                                                              Delegate-классы, реализующие сервисные интерфейсы представляют собой pattern проектирования BusinessDelegate, упрощающий доступ к серверному API системы. Клиентское приложение взаимодействует с системой только через Delegate-классы. Delegate-классы получаются посредством запроса фабрики Delegates, которая в зависимости от конфигурации возвращает нужную реализацию. Классы Delegate являются частью клиентского API.

                                                              Список основных Delegate-классов:

                                                              AuthenticationServiceDelegate – содержит методы для аутентификации пользователей в системе (с использованием логина/пароля, Kerberos и т.п.)
                                                              AuthorizationServiceDelegate — содержит методы для работы с полномочиями пользователей (назначение полномочий, проверка на допустимость операции для пользователя и т.п.)
                                                              BotServiceDelegate — содержит методы для работы с бот станциями и ботами
                                                              ExecutorServiceDelegate — содержит методы для работы с исполнителями. Позволяет создавать/удалять/изменять исполнителей а так же включать их в группы
                                                              ProfileServiceDelegate — содержит методы для работы с профайлам пользователей
                                                              SubstitutionServiceDelegate — содержит методы для управления правилами замещения
                                                              SystemServiceDelegate — содержит методы для входа/выхода пользователя в систему
                                                              DefinitionServiceDelegate — содержит методы для работы с определениями процессов
                                                              ExecutionServiceDelegate — содержит методы для работы с исполняемыми экземплярами процессов
                                                              Все существующие в данный момент Delegate-классы реализуют требуемую функциональность при помощи технологии EJB.

                                                              # Слой Service
                                                              Слой service – это серверное API доступа к системе. Реализации Delegate интерфейсов обращаются именно к этому слою. Каждый Delegate работает с одним соответствующим классом Service. В настоящее время все разработанные service классы и интерфейсы ориентированы на EJB-технологию, однако в будущем возможны и другие реализации. Реализации классов Service являются Stateless Session Bean EJB, которые декларативно поддерживают транзакционность вызовов и запрашивают соответствующие классы из слоя Logic.

                                                              Таким образом, классы Delegate – Service - Logic образуют как бы «транспорт» между клиентом и сервером.

                                                              # Слой Logic
                                                              Слой Logic – это реализация бизнес логики работы системы. Слой работает с классами слоя DAO для доступа к постоянному хранилищу.

                                                              # Слой DAO
                                                              Слой DAO – это интерфейсы и классы, обеспечивающие доступ к данным, находящимся в постоянном хранилище (базе данных). В настоящее время все DAO-классы системы реализованы при помощи ORM-средства Hibernate.

                                                              # Использование Hibernate
                                                              Hibernate – ORM (Object/Relational Mapping) средство. Отображает объектную архитектуру на реляционную структуру данных. Допускает настройку (не меняя разработанного кода) на большинство существующих серверов реляционных баз данных.

                                                              Поддерживает работу с распределенными транзакциями, автоматически создает таблицы для новых классов и т.д. Вся работа с данными внутри системы ведется только через Hibernate.

                                                              Все компоненты, предоставляющие клиентское API построены с использованием описанных выше слоев. В целях оптимизации в некоторых компонентах применяется кеширование, которое может встречаться на уровне logic или DAO. Основная функциональность по управлению кешами находится в классах CachingLogic, CacheInterceptor и классах соответствующих кешей. Изменения в кешируемых объектах перехватываются и сообщаются посредством CachingLogic всем подписавшимся на изменения классам кешей. Транзакция, изменяющая кеш, считается закрытой по окончанию обработки ejb вызова.

                                                              # Обновление базы данных
                                                              см. описание системы патчей.

                                                              # API
                                                              Система представляет API для интеграции с другими системами:

                                                              # Java API
                                                              Реализация (снизу вверх): БД - Hibernate3 - EJB3

                                                              Документацию можно смотреть в исходном коде (javadocs в *Service.java).

                                                              # WebServices API
                                                              Реализация (снизу вверх): БД - Hibernate3 - JAX-WS

                                                              Документация: WebServicesDeveloperGuide

                                                              # Scripting API
                                                              Реализация (снизу вверх): БД - Hibernate3 - XML Script

                                                              Документация: AdminScriptGuide

                                                              # Процесс сборки из исходного кода
                                                              Исходный код системы доступен в открытом репозитории на github.

                                                              Сервер можно собирать как средствами maven используя командную строку, так и используя среду Eclipse IDE.

                                                              В результате сборки будет сформирован runawfe.ear, который теоретически можно запустить на любом сервере приложений. Начиная с версии 4.3.0 введена поддержка JAVA версии 8, и отказ от JAVA 6. В дальнейшем планируется отказ от java7, поэтому рекомендуется использовать сервер приложений wildfly.

                                                              # Процесс сборки на примере Eclipse IDE
                                                              # Необходимое программное обеспечение для сборки
                                                              В отличие от Среды разработки для сборки сервера можно использовать Eclipse IDE любой версии и редакции.

                                                              установите плагин m2eclipse
                                                              используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу: http://maven.apache.org/
                                                              добавьте путь к Apache Maven директории bin в переменную окружения Path
                                                              # Импорт проектов
                                                              Импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server.

                                                              Eclipse srv proj.png

                                                              # Установка maven артефактов
                                                              Выполните

                                                              ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                                                              ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                                                              или другим способом установите артефакты в локальный репозиторий

                                                              # Сборка
                                                              Заведите конфигурацию запуска на основе maven как показано на рисунке

                                                              Maven.build.configuration.png

                                                              Запустите конфигурацию.

                                                              Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\eclipse-workspace\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"

                                                              # Сборка из командной строки
                                                              используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу http://maven.apache.org/
                                                              добавьте путь к Apache Maven директории bin в переменную окружения Path
                                                              импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server
                                                              выполните обновление зависимостей
                                                              ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                                                              ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                                                              откройте командную строку
                                                              перейдите в директорию ${wfe}/wfe-app/
                                                              выполните команду для сборки
                                                              mvn clean package -Dmaven.test.skip=true
                                                              Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"


                                                              Для установки артефактов в локальный репозиторий используйте команду

                                                              mvn clean install -Dmaven.test.skip=true
                                                              # Использование ear на сервере приложений
                                                              cкачайте текущую версию RunaWFE в виде файл-архива исполняемых java файлов runawfe-wildfly-java8-*.zip (на базе wildfly, java8)
                                                              распакуйте архив
                                                              обновите runawfe.ear на версию полученную в результате сборки
                                                              # Расширение функциональности
                                                              # Точки расширения системы
                                                              Обработчики позволяют исполнить код в процессах (элементы "Обработчик", "Задача сценария") и ботах
                                                              Форматы переменных определяют тип переменных и правила преобразования значений к текстовому представлению и обратно
                                                              Организационные функции используются при назначении ролей и в правилах замещения для определения заместителя
                                                              Критерии замещения используются в подсистеме замещения для определения заместителя при построении списка заданий
                                                              Валидаторы обеспечивают проверку переменных при выполнении задания (в т.ч. введенные значения форм)
                                                              Freemarker теги форм генерируют html код для отображения на форме
                                                              Ajax команды предоставляют доступ к функциональности сервера из JavaScript
                                                              # Процесс разработки расширений
                                                              Создайте новый java-проект и подключите необходимые зависимости (wfe-core, wfe-service).

                                                              Реализуйте в нем требуемые расширения и соберите его в виде jar-файла.

                                                              Замечание. Использование maven облегчит процесс управления зависимостями.

                                                              Разместить собранный jar на сервере вы можете:

                                                              положив его в runawfe.ear!/lib
                                                              положив его в директорию deploy (только для jboss4)
                                                              положив его в ${jboss.server.base.dir}/wfe.custom (только для jboss7)
                                                              положив его в ${jboss.server.base.dir}/${jboss.server.name}/wfe.custom (только для jboss4)
                                                              # Обработчики
                                                              Обработчик в процессе – компонент процесса (элементы "Обработчик", "Задача сценария"), использующийся для выполнения каких-либо действий при возникновении определенных событий (проход по определенному переходу в процессе, приход или уход управления из узла и т.п.).

                                                              Обработчик должен реализовывать интерфейс ru.runa.wfe.extension.ActionHandler. Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов Spring контекста (например с помощью аннотации @Autowired).

                                                              При написании нового обработчика рекомендуется наследовать его от абстрактного класса ru.runa.wfe.extension.handler.CommonHandler или ru.runa.wfe.extension.handler.CommonParamBasedHandler. В методе setConfiguration обработчик должен запомнить свои параметры (если обработчик их ожидает), а в методе execute происходит непосредственная обработка и выполнение требуемых действий.

                                                              В случае, если при выполнении обработчика произошла ошибка, произойдет откат транзакции и состояние процесса будет возвращено к заданию, исполнение которого повлекло вызов обработчика. В интерфейсе обработчика для бота ru.runa.wfe.extension.TaskHandler предусмотрен метод onRollback для работы с не-транзакционными ресурсами.

                                                              Эти обработчики удобно использовать для простых операций (например для отправки оповещений в виде SMS-сообщений если процесс попал в определенное состояние). Но у них есть несколько ограничений. Прежде всего у них нет соответствующего объекта контекста безопасности (security context). Это означает, что в них нельзя выполнять защищенные методы (запуск процессов, выполнение задач, создание пользователей и т.п.) Ошибочным решением в них будет блокирование выполнения процесса (например с Thread::Sleep(...)). Например, если в обработчике отправляется e-mail, а SMTP сервер недоступен, обработчику нельзя "задерживать" свое выполнение.

                                                              Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                                                              # Специфика обработчиков для ботов
                                                              Бот - это сокращение от робот. В системе боты - это особый тип исполнителей. Система не отличает ботов от людей. У каждого бота есть свои права на вход в систему, он периодически просыпается, проверяет свой список задачи и выполняет обнаруженные там задачи.

                                                              Каждая задача бота обрабатывается при помощи соответствующего обработчика. Чтобы написать новый обработчик нужно реализовать интерфейс ru.runa.wfe.extension.TaskHandler.

                                                              Обратите внимание, что этот вид обработчиков выполняется в контексте безопасности (security context) пользователя-бота, и здесь может выполнятся любая операция (если у бота есть на это права).

                                                              Обработчики задач ботов могут блокировать выполнение процесса.

                                                              Например, обработчик задач, отправляющий e-mail может блокировать выполнение бизнес процесса до тех пор, пока обработчик не удостоверится, что SMTP сервер принял сообщение для последующей доставки.

                                                              Обработчики задач вызываются периодически, когда боты проверяют свои списки задач.

                                                              # Специфика обработчика для элемента ветвление
                                                              Обработчик для Decision является java-классом, реализующим интерфейс ru.runa.wfe.extension.DecisionHandler. Интерфейс содержит один метод decide(ExecutionContext executionContext), который возвращает имя выбранного перехода (одного из выходящих из данного ветвления). Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов контекста спринга (например с помощью аннотации @Autowired).

                                                              Обработчик принимает ExecutionContext в качестве входящего параметра и должен сделать выбор перехода исходя из значений переменных бизнес процесса и условий, указанных в конфигурации обработчика. Точно также как обработчики действия (action handler) обработчики выбора (decision handlers) не могут использовать защищенные (secured) методы, не могут обрабатывать ошибки и откладывать выбор перехода до лучших времен.

                                                              По умолчанию используется ru.runa.wfe.extension.decision.GroovyDecisionHandler.

                                                              # Использование ru.runa.wfe.extension.handler.CommonParamBasedHandler в качестве базового класса
                                                              Этот класс инкапсулирует в себе парсинг XML конфигурации определенного формата. Его удобно использовать если обработчик имеет фиксированное число параметров. Пример конфигурации:

                                                              <?xml version="1.0" encoding="UTF-8"?>
                                                              <config>
                                                               <input>
                                                                 <param name="typeName" variable="тип отсутствия" />
                                                                 <param name="employee" variable="сотрудник" />
                                                                 <param name="requester" variable="подавший заявку" />
                                                                 <param name="from" variable="дата с" />
                                                                 <param name="to" variable="дата по" />
                                                                 <param name="cause" variable="причина" />
                                                                 <param name="comment" variable="комментарий" />
                                                                 <param name="confirmation" variable="дата подтверждения" />
                                                                 <param name="firmCode" value="111" />
                                                                 <param name="firmPositionCode" variable="код должности" />
                                                                 <param name="firmDepartmentCode" variable="код подразделения" />
                                                               </input>
                                                               <output>
                                                                 <param name="uuid" variable="идентификатор объекта" />
                                                               </output>
                                                              </config>
                                                              Использование обработчика Groovy
                                                              См. соответствующий раздел в руководстве по работе с Groovy.

                                                              # Как написать функцию над организационной структурой
                                                              Функции над организационной структурой в системе применяются, например, при инициализации Ролей-Дорожек и в правилах замещения.

                                                              Класс, соответствующий функции над организационной структурой, должен реализовывать интерфейс ru.runa.wfe.extension.OrgFunction.

                                                              Интерфейс содержит один метод

                                                              List<? extends Executor> getExecutors(Object... parameters)
                                                              Этот метод должен возвращать список исполнителей.

                                                              В бизнес-процессе обработчик функции над оргструктурой используются при определении Ролей-Дорожек: указывается внутри тега swimlane, в теле тега <assignment>.В качестве параметра class тега <assignment> указывается класс-обработчик для инициализации swimlane: ru.runa.wfe.extension.AssignmentHandler. Внутри тега <assignment> содержится конфигурация для этого класса, которая представляет собой имя класса-наследника интерфейса OrgFunction и список параметров в скобках. В качестве параметра может выступать конкретное значение или имя переменной бизнес процесса в фигурных скобках, перед которым стоит значок $

                                                              Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                                                              Если есть планы по использованию функции в подсистеме замещений - её можно зарегистрировать в substitutions.xml.

                                                              # Как написать критерий замещения
                                                              Критерии замещения в системе применяются в правилах замещения. Класс, соответствующий критерию замещения, должен наследоваться от ru.runa.wfe.ss.SubstitutionCriteria.

                                                              Для создания на основе него конечных критериев замещения с конфигурациями - его нужно зарегистрировать в substitution.criterias.xml.

                                                              Как реализовать класс-формат для переменных бизнес-процесса
                                                              См. соответствующий раздел в руководстве по работе с переменными.

                                                              # Как реализовать валидатор переменных
                                                              Классы, расширяющие абстрактный класс ru.runa.wfe.validation.FieldValidator, в системе применяются для проверки переменных при выполнении задания или старте процесса.

                                                              Пример:

                                                              public class OvertimeWorkRequestTimeCheck extends FieldValidator {
                                                                 @Override
                                                                 public void validate() {
                                                                     Date date = (Date) getFieldValue();
                                                                     if (date == null) {
                                                                         return;
                                                                     }
                                                                     boolean testMode = getVariableProvider().getValueNotNull(boolean.class, "тестовый режим");
                                                                     if (testMode) {
                                                                         return;
                                                                     }
                                                                     Calendar calendar = CalendarUtil.dateToCalendar(date);
                                                                     if (calendar.before(Calendar.getInstance())) {
                                                                         addError("Заявка не может быть оформлена задним числом");
                                                                         return;
                                                                     }
                                                                     CalendarUtil.setTimeFromCalendar(calendar, DemoProperties.getOvertimeWorkRequestMaximumStartTime());
                                                                     Utils.adjustCalendarForHolidaysInOvertimwWork(calendar);
                                                                     if (calendar.before(Calendar.getInstance())) {
                                                                         addError("Заявка на этот день не может быть подана, время подачи истекло " + CalendarUtil.formatDateTime(calendar));
                                                                     }
                                                                 }
                                                              }

                                                              Связь между Средой разработки и сервером осуществляется по имени валидатора, регистрация требуется на стороне сервера в файле validators.xml, а в среде разработки - в plugin.xml.

                                                              # Как реализовать FreeMarker тег для формы
                                                              FreemarkerForms#Components

                                                              # Как реализовать Ajax команду
                                                              Классы, расширяющие абстрактный класс ru.runa.wfe.commons.web.JsonAjaxCommand, (или реализующие ru.runa.wfe.commons.web.AjaxCommand) в системе применяются для доступа к функциональности сервера из JavaScript, например при отображении форм задания.

                                                              Регистрация команды происходит любым из двух способов:

                                                              в файле ajax.commands.xml, ей присваивается определенное имя
                                                              в контексте приложения, именем является id spring-бина
                                                              Затем по этому имени её можно выполнить используя JavaScript.

                                                              Пример команды

                                                              public class GetOrganizationNamesCommand extends JsonAjaxCommand {
                                                                 @Autowired
                                                                 private OrganizationDAO organizationDAO;
                                                                 @Override
                                                                 protected JSONAware execute(User user, HttpServletRequest request) throws Exception {
                                                                     String term = request.getParameter("term");
                                                                     if (term == null) {
                                                                         term = "";
                                                                     }
                                                                     List<Organization> organizations = organizationDAO.getAll();
                                                                     JSONArray array = new JSONArray();
                                                                     for (Organization organization : organizations) {
                                                                         if (organization.getName().startsWith(term)) {
                                                                             array.add(organization.getName());
                                                                         }
                                                                     }
                                                                     return array;
                                                                 }
                                                              }
                                                              Регистрация в wfe.custom.ajax.commands.xml

                                                              <?xml version="1.0" encoding="UTF-8" ?>
                                                              <configuration xmlns="http://runa.ru/xml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://runa.ru/xml">
                                                               <command name="getOrganizationNames" class="ru.runa.rkdemo.web.ajax.GetOrganizationNamesCommand" />
                                                              </configuration>
                                                              Её использование со скрипта формы (autocomplete input)

                                                              $(document).ready(function() {
                                                               $('#editLinkedLists').on("onRowAdded", function(event, rowIndex) {
                                                                $("input[name='названия организаций["+rowIndex+"]']").autocomplete( {
                                                                 delay: 300,
                                                                 minLength: 0,
                                                                 source: "/wfe/ajaxcmd?command=getOrganizationNames"
                                                                });
                                                                $("input[name='названия организаций["+rowIndex+"]']").focus(function() {
                                                                 $(this).autocomplete("search", $(this).val());
                                                                });
                                                               });
                                                              });Введение
                                                                 # Основные компоненты и используемые технологии
                                                                 Для WF–системы была выбрана следующая общая архитектура (в целом соответствует архитектуре, предлагаемой коалицией WfMC):

                                                                 Компоненты системы:

                                                                 Ядро системы
                                                                 Содержит набор определений бизнес-процессов
                                                                 Содержит набор выполняющихся экземпляров бизнес–процессов
                                                                 Компонент, "назначающий" исполнителей для действий
                                                                 Клиент
                                                                 Список заданий (набор графических форм, содержит очереди поступивших работ, сортировки и фильтры)
                                                                 Проигрыватель форм (отображает формы, разработанные в Среде разработки)
                                                                 Административный интерфейс
                                                                 Показывает состояния процессов, позволяет фильтровать и останавливать процессы
                                                                 Позволяет загружать-выгружать процессы
                                                                 Позволяет заводить-удалять пользователей
                                                                 Позволяет задавать различные права
                                                                 Редактор назначения заместителей
                                                                 Среда разработки
                                                                 Конструктор графических форм
                                                                 Бот станции, содержащие ботов (Боты - приложения специального вида, которые также как и обычные пользователи могут выполнять задания)
                                                                 Подсистема управления правами доступа (авторизация и аутентификация)
                                                                 # Платформа программирования и используемые программные средства
                                                                 В качестве платформы программирования используется J2EE.

                                                                 Используемые программные средства:

                                                                 Сервер приложений - JBOSS (http://www.jboss.org).
                                                                 Среда разработки - любая, например Eclipse от IBM (http://www.eclipse.org).
                                                                 Система контроля версий - git
                                                                 Сборщик приложений – maven.
                                                                 Сервер баз данных – поддерживаются сервера БД:
                                                                 MS SQL Server (http://www.microsoft.com/sql/evaluation/default.mspx)
                                                                 HSQL (http://hsqldb.org)
                                                                 Oracle (http://www.oracle.com)
                                                                 PostgreSQL (http://postgresql.com)
                                                                 Операционная система — поддерживаются следующие ОС:
                                                                 Windows (Server 2000-2008, XP, Vista, 7)
                                                                 ALTLinux
                                                                 Mandriva Linux
                                                                 Fedora
                                                                 Debian/Ubuntu
                                                                 # Описание проектов
                                                                 Название проекта	Обязателен при сборке	Обязателен при работе	Зависимости	Описание
                                                                 wfe-alfresco	нет	нет	runawfe-app	Интеграция с Alfresco
                                                                 wfe-app	да	да	wfe-ear, wfe-cactus-it	Проект для организации сборки maven
                                                                 wfe-appserver	нет	нет	 ?	Не используется
                                                                 wfe-bots	да	да	wfe-service	Подсистема ботов
                                                                 wfe-cactus-it	да	нет	wfe-service	Интеграционные тесты
                                                                 wfe-core	да	да	-	Основные компоненты системы
                                                                 wfe-ear	да	да	wfe-service, wfe-bots, wfe-office, wfe-web	Проект для сборки runawfe.ear
                                                                 wfe-office	да	нет	wfe-core	Обработчики для работы с Word, Excel
                                                                 wfe-service	да	да	wfe-core	Сервисы (EJB + WebServices), представляющие собой публичное API приложения
                                                                 wfe-web	да	да	wfe-bots	Визуальная часть приложения
                                                                 wfe-webservice-client	нет	нет	 ?	Авто-генерации клиентской библиотеки на основе WSDL серверных сервисов. В нем же есть примеры использования веб-служб из Java клиента.
                                                                 # Описание слоев архитектуры системы
                                                                 Каждый компонент состоит из нескольких уровней (слоев).

                                                                 Список слоев:

                                                                 delegate
                                                                 service
                                                                 logic
                                                                 DAO
                                                                 hibernate
                                                                 # Слой Delegate
                                                                 Delegate-классы, реализующие сервисные интерфейсы представляют собой pattern проектирования BusinessDelegate, упрощающий доступ к серверному API системы. Клиентское приложение взаимодействует с системой только через Delegate-классы. Delegate-классы получаются посредством запроса фабрики Delegates, которая в зависимости от конфигурации возвращает нужную реализацию. Классы Delegate являются частью клиентского API.

                                                                 Список основных Delegate-классов:

                                                                 AuthenticationServiceDelegate – содержит методы для аутентификации пользователей в системе (с использованием логина/пароля, Kerberos и т.п.)
                                                                 AuthorizationServiceDelegate — содержит методы для работы с полномочиями пользователей (назначение полномочий, проверка на допустимость операции для пользователя и т.п.)
                                                                 BotServiceDelegate — содержит методы для работы с бот станциями и ботами
                                                                 ExecutorServiceDelegate — содержит методы для работы с исполнителями. Позволяет создавать/удалять/изменять исполнителей а так же включать их в группы
                                                                 ProfileServiceDelegate — содержит методы для работы с профайлам пользователей
                                                                 SubstitutionServiceDelegate — содержит методы для управления правилами замещения
                                                                 SystemServiceDelegate — содержит методы для входа/выхода пользователя в систему
                                                                 DefinitionServiceDelegate — содержит методы для работы с определениями процессов
                                                                 ExecutionServiceDelegate — содержит методы для работы с исполняемыми экземплярами процессов
                                                                 Все существующие в данный момент Delegate-классы реализуют требуемую функциональность при помощи технологии EJB.

                                                                 # Слой Service
                                                                 Слой service – это серверное API доступа к системе. Реализации Delegate интерфейсов обращаются именно к этому слою. Каждый Delegate работает с одним соответствующим классом Service. В настоящее время все разработанные service классы и интерфейсы ориентированы на EJB-технологию, однако в будущем возможны и другие реализации. Реализации классов Service являются Stateless Session Bean EJB, которые декларативно поддерживают транзакционность вызовов и запрашивают соответствующие классы из слоя Logic.

                                                                 Таким образом, классы Delegate – Service - Logic образуют как бы «транспорт» между клиентом и сервером.

                                                                 # Слой Logic
                                                                 Слой Logic – это реализация бизнес логики работы системы. Слой работает с классами слоя DAO для доступа к постоянному хранилищу.

                                                                 # Слой DAO
                                                                 Слой DAO – это интерфейсы и классы, обеспечивающие доступ к данным, находящимся в постоянном хранилище (базе данных). В настоящее время все DAO-классы системы реализованы при помощи ORM-средства Hibernate.

                                                                 # Использование Hibernate
                                                                 Hibernate – ORM (Object/Relational Mapping) средство. Отображает объектную архитектуру на реляционную структуру данных. Допускает настройку (не меняя разработанного кода) на большинство существующих серверов реляционных баз данных.

                                                                 Поддерживает работу с распределенными транзакциями, автоматически создает таблицы для новых классов и т.д. Вся работа с данными внутри системы ведется только через Hibernate.

                                                                 Все компоненты, предоставляющие клиентское API построены с использованием описанных выше слоев. В целях оптимизации в некоторых компонентах применяется кеширование, которое может встречаться на уровне logic или DAO. Основная функциональность по управлению кешами находится в классах CachingLogic, CacheInterceptor и классах соответствующих кешей. Изменения в кешируемых объектах перехватываются и сообщаются посредством CachingLogic всем подписавшимся на изменения классам кешей. Транзакция, изменяющая кеш, считается закрытой по окончанию обработки ejb вызова.

                                                                 # Обновление базы данных
                                                                 см. описание системы патчей.

                                                                 # API
                                                                 Система представляет API для интеграции с другими системами:

                                                                 # Java API
                                                                 Реализация (снизу вверх): БД - Hibernate3 - EJB3

                                                                 Документацию можно смотреть в исходном коде (javadocs в *Service.java).

                                                                 # WebServices API
                                                                 Реализация (снизу вверх): БД - Hibernate3 - JAX-WS

                                                                 Документация: WebServicesDeveloperGuide

                                                                 # Scripting API
                                                                 Реализация (снизу вверх): БД - Hibernate3 - XML Script

                                                                 Документация: AdminScriptGuide

                                                                 # Процесс сборки из исходного кода
                                                                 Исходный код системы доступен в открытом репозитории на github.

                                                                 Сервер можно собирать как средствами maven используя командную строку, так и используя среду Eclipse IDE.

                                                                 В результате сборки будет сформирован runawfe.ear, который теоретически можно запустить на любом сервере приложений. Начиная с версии 4.3.0 введена поддержка JAVA версии 8, и отказ от JAVA 6. В дальнейшем планируется отказ от java7, поэтому рекомендуется использовать сервер приложений wildfly.

                                                                 # Процесс сборки на примере Eclipse IDE
                                                                 # Необходимое программное обеспечение для сборки
                                                                 В отличие от Среды разработки для сборки сервера можно использовать Eclipse IDE любой версии и редакции.

                                                                 установите плагин m2eclipse
                                                                 используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу: http://maven.apache.org/
                                                                 добавьте путь к Apache Maven директории bin в переменную окружения Path
                                                                 # Импорт проектов
                                                                 Импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server.

                                                                 Eclipse srv proj.png

                                                                 # Установка maven артефактов
                                                                 Выполните

                                                                 ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                                                                 ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                                                                 или другим способом установите артефакты в локальный репозиторий

                                                                 # Сборка
                                                                 Заведите конфигурацию запуска на основе maven как показано на рисунке

                                                                 Maven.build.configuration.png

                                                                 Запустите конфигурацию.

                                                                 Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\eclipse-workspace\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"

                                                                 # Сборка из командной строки
                                                                 используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу http://maven.apache.org/
                                                                 добавьте путь к Apache Maven директории bin в переменную окружения Path
                                                                 импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server
                                                                 выполните обновление зависимостей
                                                                 ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                                                                 ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                                                                 откройте командную строку
                                                                 перейдите в директорию ${wfe}/wfe-app/
                                                                 выполните команду для сборки
                                                                 mvn clean package -Dmaven.test.skip=true
                                                                 Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"


                                                                 Для установки артефактов в локальный репозиторий используйте команду

                                                                 mvn clean install -Dmaven.test.skip=true
                                                                 # Использование ear на сервере приложений
                                                                 cкачайте текущую версию RunaWFE в виде файл-архива исполняемых java файлов runawfe-wildfly-java8-*.zip (на базе wildfly, java8)
                                                                 распакуйте архив
                                                                 обновите runawfe.ear на версию полученную в результате сборки
                                                                 # Расширение функциональности
                                                                 # Точки расширения системы
                                                                 Обработчики позволяют исполнить код в процессах (элементы "Обработчик", "Задача сценария") и ботах
                                                                 Форматы переменных определяют тип переменных и правила преобразования значений к текстовому представлению и обратно
                                                                 Организационные функции используются при назначении ролей и в правилах замещения для определения заместителя
                                                                 Критерии замещения используются в подсистеме замещения для определения заместителя при построении списка заданий
                                                                 Валидаторы обеспечивают проверку переменных при выполнении задания (в т.ч. введенные значения форм)
                                                                 Freemarker теги форм генерируют html код для отображения на форме
                                                                 Ajax команды предоставляют доступ к функциональности сервера из JavaScript
                                                                 # Процесс разработки расширений
                                                                 Создайте новый java-проект и подключите необходимые зависимости (wfe-core, wfe-service).

                                                                 Реализуйте в нем требуемые расширения и соберите его в виде jar-файла.

                                                                 Замечание. Использование maven облегчит процесс управления зависимостями.

                                                                 Разместить собранный jar на сервере вы можете:

                                                                 положив его в runawfe.ear!/lib
                                                                 положив его в директорию deploy (только для jboss4)
                                                                 положив его в ${jboss.server.base.dir}/wfe.custom (только для jboss7)
                                                                 положив его в ${jboss.server.base.dir}/${jboss.server.name}/wfe.custom (только для jboss4)
                                                                 # Обработчики
                                                                 Обработчик в процессе – компонент процесса (элементы "Обработчик", "Задача сценария"), использующийся для выполнения каких-либо действий при возникновении определенных событий (проход по определенному переходу в процессе, приход или уход управления из узла и т.п.).

                                                                 Обработчик должен реализовывать интерфейс ru.runa.wfe.extension.ActionHandler. Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов Spring контекста (например с помощью аннотации @Autowired).

                                                                 При написании нового обработчика рекомендуется наследовать его от абстрактного класса ru.runa.wfe.extension.handler.CommonHandler или ru.runa.wfe.extension.handler.CommonParamBasedHandler. В методе setConfiguration обработчик должен запомнить свои параметры (если обработчик их ожидает), а в методе execute происходит непосредственная обработка и выполнение требуемых действий.

                                                                 В случае, если при выполнении обработчика произошла ошибка, произойдет откат транзакции и состояние процесса будет возвращено к заданию, исполнение которого повлекло вызов обработчика. В интерфейсе обработчика для бота ru.runa.wfe.extension.TaskHandler предусмотрен метод onRollback для работы с не-транзакционными ресурсами.

                                                                 Эти обработчики удобно использовать для простых операций (например для отправки оповещений в виде SMS-сообщений если процесс попал в определенное состояние). Но у них есть несколько ограничений. Прежде всего у них нет соответствующего объекта контекста безопасности (security context). Это означает, что в них нельзя выполнять защищенные методы (запуск процессов, выполнение задач, создание пользователей и т.п.) Ошибочным решением в них будет блокирование выполнения процесса (например с Thread::Sleep(...)). Например, если в обработчике отправляется e-mail, а SMTP сервер недоступен, обработчику нельзя "задерживать" свое выполнение.

                                                                 Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                                                                 # Специфика обработчиков для ботов
                                                                 Бот - это сокращение от робот. В системе боты - это особый тип исполнителей. Система не отличает ботов от людей. У каждого бота есть свои права на вход в систему, он периодически просыпается, проверяет свой список задачи и выполняет обнаруженные там задачи.

                                                                 Каждая задача бота обрабатывается при помощи соответствующего обработчика. Чтобы написать новый обработчик нужно реализовать интерфейс ru.runa.wfe.extension.TaskHandler.

                                                                 Обратите внимание, что этот вид обработчиков выполняется в контексте безопасности (security context) пользователя-бота, и здесь может выполнятся любая операция (если у бота есть на это права).

                                                                 Обработчики задач ботов могут блокировать выполнение процесса.

                                                                 Например, обработчик задач, отправляющий e-mail может блокировать выполнение бизнес процесса до тех пор, пока обработчик не удостоверится, что SMTP сервер принял сообщение для последующей доставки.

                                                                 Обработчики задач вызываются периодически, когда боты проверяют свои списки задач.

                                                                 # Специфика обработчика для элемента ветвление
                                                                 Обработчик для Decision является java-классом, реализующим интерфейс ru.runa.wfe.extension.DecisionHandler. Интерфейс содержит один метод decide(ExecutionContext executionContext), который возвращает имя выбранного перехода (одного из выходящих из данного ветвления). Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов контекста спринга (например с помощью аннотации @Autowired).

                                                                 Обработчик принимает ExecutionContext в качестве входящего параметра и должен сделать выбор перехода исходя из значений переменных бизнес процесса и условий, указанных в конфигурации обработчика. Точно также как обработчики действия (action handler) обработчики выбора (decision handlers) не могут использовать защищенные (secured) методы, не могут обрабатывать ошибки и откладывать выбор перехода до лучших времен.

                                                                 По умолчанию используется ru.runa.wfe.extension.decision.GroovyDecisionHandler.

                                                                 # Использование ru.runa.wfe.extension.handler.CommonParamBasedHandler в качестве базового класса
                                                                 Этот класс инкапсулирует в себе парсинг XML конфигурации определенного формата. Его удобно использовать если обработчик имеет фиксированное число параметров. Пример конфигурации:

                                                                 <?xml version="1.0" encoding="UTF-8"?>
                                                                 <config>
                                                                  <input>
                                                                    <param name="typeName" variable="тип отсутствия" />
                                                                    <param name="employee" variable="сотрудник" />
                                                                    <param name="requester" variable="подавший заявку" />
                                                                    <param name="from" variable="дата с" />
                                                                    <param name="to" variable="дата по" />
                                                                    <param name="cause" variable="причина" />
                                                                    <param name="comment" variable="комментарий" />
                                                                    <param name="confirmation" variable="дата подтверждения" />
                                                                    <param name="firmCode" value="111" />
                                                                    <param name="firmPositionCode" variable="код должности" />
                                                                    <param name="firmDepartmentCode" variable="код подразделения" />
                                                                  </input>
                                                                  <output>
                                                                    <param name="uuid" variable="идентификатор объекта" />
                                                                  </output>
                                                                 </config>
                                                                 Использование обработчика Groovy
                                                                 См. соответствующий раздел в руководстве по работе с Groovy.

                                                                 # Как написать функцию над организационной структурой
                                                                 Функции над организационной структурой в системе применяются, например, при инициализации Ролей-Дорожек и в правилах замещения.

                                                                 Класс, соответствующий функции над организационной структурой, должен реализовывать интерфейс ru.runa.wfe.extension.OrgFunction.

                                                                 Интерфейс содержит один метод

                                                                 List<? extends Executor> getExecutors(Object... parameters)
                                                                 Этот метод должен возвращать список исполнителей.

                                                                 В бизнес-процессе обработчик функции над оргструктурой используются при определении Ролей-Дорожек: указывается внутри тега swimlane, в теле тега <assignment>.В качестве параметра class тега <assignment> указывается класс-обработчик для инициализации swimlane: ru.runa.wfe.extension.AssignmentHandler. Внутри тега <assignment> содержится конфигурация для этого класса, которая представляет собой имя класса-наследника интерфейса OrgFunction и список параметров в скобках. В качестве параметра может выступать конкретное значение или имя переменной бизнес процесса в фигурных скобках, перед которым стоит значок $

                                                                 Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                                                                 Если есть планы по использованию функции в подсистеме замещений - её можно зарегистрировать в substitutions.xml.

                                                                 # Как написать критерий замещения
                                                                 Критерии замещения в системе применяются в правилах замещения. Класс, соответствующий критерию замещения, должен наследоваться от ru.runa.wfe.ss.SubstitutionCriteria.

                                                                 Для создания на основе него конечных критериев замещения с конфигурациями - его нужно зарегистрировать в substitution.criterias.xml.

                                                                 Как реализовать класс-формат для переменных бизнес-процесса
                                                                 См. соответствующий раздел в руководстве по работе с переменными.

                                                                 # Как реализовать валидатор переменных
                                                                 Классы, расширяющие абстрактный класс ru.runa.wfe.validation.FieldValidator, в системе применяются для проверки переменных при выполнении задания или старте процесса.

                                                                 Пример:

                                                                 public class OvertimeWorkRequestTimeCheck extends FieldValidator {
                                                                    @Override
                                                                    public void validate() {
                                                                        Date date = (Date) getFieldValue();
                                                                        if (date == null) {
                                                                            return;
                                                                        }
                                                                        boolean testMode = getVariableProvider().getValueNotNull(boolean.class, "тестовый режим");
                                                                        if (testMode) {
                                                                            return;
                                                                        }
                                                                        Calendar calendar = CalendarUtil.dateToCalendar(date);
                                                                        if (calendar.before(Calendar.getInstance())) {
                                                                            addError("Заявка не может быть оформлена задним числом");
                                                                            return;
                                                                        }
                                                                        CalendarUtil.setTimeFromCalendar(calendar, DemoProperties.getOvertimeWorkRequestMaximumStartTime());
                                                                        Utils.adjustCalendarForHolidaysInOvertimwWork(calendar);
                                                                        if (calendar.before(Calendar.getInstance())) {
                                                                            addError("Заявка на этот день не может быть подана, время подачи истекло " + CalendarUtil.formatDateTime(calendar));
                                                                        }
                                                                    }
                                                                 }

                                                                 Связь между Средой разработки и сервером осуществляется по имени валидатора, регистрация требуется на стороне сервера в файле validators.xml, а в среде разработки - в plugin.xml.

                                                                 # Как реализовать FreeMarker тег для формы
                                                                 FreemarkerForms#Components

                                                                 # Как реализовать Ajax команду
                                                                 Классы, расширяющие абстрактный класс ru.runa.wfe.commons.web.JsonAjaxCommand, (или реализующие ru.runa.wfe.commons.web.AjaxCommand) в системе применяются для доступа к функциональности сервера из JavaScript, например при отображении форм задания.

                                                                 Регистрация команды происходит любым из двух способов:

                                                                 в файле ajax.commands.xml, ей присваивается определенное имя
                                                                 в контексте приложения, именем является id spring-бина
                                                                 Затем по этому имени её можно выполнить используя JavaScript.

                                                                 Пример команды

                                                                 public class GetOrganizationNamesCommand extends JsonAjaxCommand {
                                                                    @Autowired
                                                                    private OrganizationDAO organizationDAO;
                                                                    @Override
                                                                    protected JSONAware execute(User user, HttpServletRequest request) throws Exception {
                                                                        String term = request.getParameter("term");
                                                                        if (term == null) {
                                                                            term = "";
                                                                        }
                                                                        List<Organization> organizations = organizationDAO.getAll();
                                                                        JSONArray array = new JSONArray();
                                                                        for (Organization organization : organizations) {
                                                                            if (organization.getName().startsWith(term)) {
                                                                                array.add(organization.getName());
                                                                            }
                                                                        }
                                                                        return array;
                                                                    }
                                                                 }
                                                                 Регистрация в wfe.custom.ajax.commands.xml

                                                                 <?xml version="1.0" encoding="UTF-8" ?>
                                                                 <configuration xmlns="http://runa.ru/xml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://runa.ru/xml">
                                                                  <command name="getOrganizationNames" class="ru.runa.rkdemo.web.ajax.GetOrganizationNamesCommand" />
                                                                 </configuration>
                                                                 Её использование со скрипта формы (autocomplete input)

                                                                 $(document).ready(function() {
                                                                  $('#editLinkedLists').on("onRowAdded", function(event, rowIndex) {
                                                                   $("input[name='названия организаций["+rowIndex+"]']").autocomplete( {
                                                                    delay: 300,
                                                                    minLength: 0,
                                                                    source: "/wfe/ajaxcmd?command=getOrganizationNames"
                                                                   });
                                                                   $("input[name='названия организаций["+rowIndex+"]']").focus(function() {
                                                                    $(this).autocomplete("search", $(this).val());
                                                                   });
                                                                  });
                                                                 });Введение
                                                                    # Основные компоненты и используемые технологии
                                                                    Для WF–системы была выбрана следующая общая архитектура (в целом соответствует архитектуре, предлагаемой коалицией WfMC):

                                                                    Компоненты системы:

                                                                    Ядро системы
                                                                    Содержит набор определений бизнес-процессов
                                                                    Содержит набор выполняющихся экземпляров бизнес–процессов
                                                                    Компонент, "назначающий" исполнителей для действий
                                                                    Клиент
                                                                    Список заданий (набор графических форм, содержит очереди поступивших работ, сортировки и фильтры)
                                                                    Проигрыватель форм (отображает формы, разработанные в Среде разработки)
                                                                    Административный интерфейс
                                                                    Показывает состояния процессов, позволяет фильтровать и останавливать процессы
                                                                    Позволяет загружать-выгружать процессы
                                                                    Позволяет заводить-удалять пользователей
                                                                    Позволяет задавать различные права
                                                                    Редактор назначения заместителей
                                                                    Среда разработки
                                                                    Конструктор графических форм
                                                                    Бот станции, содержащие ботов (Боты - приложения специального вида, которые также как и обычные пользователи могут выполнять задания)
                                                                    Подсистема управления правами доступа (авторизация и аутентификация)
                                                                    # Платформа программирования и используемые программные средства
                                                                    В качестве платформы программирования используется J2EE.

                                                                    Используемые программные средства:

                                                                    Сервер приложений - JBOSS (http://www.jboss.org).
                                                                    Среда разработки - любая, например Eclipse от IBM (http://www.eclipse.org).
                                                                    Система контроля версий - git
                                                                    Сборщик приложений – maven.
                                                                    Сервер баз данных – поддерживаются сервера БД:
                                                                    MS SQL Server (http://www.microsoft.com/sql/evaluation/default.mspx)
                                                                    HSQL (http://hsqldb.org)
                                                                    Oracle (http://www.oracle.com)
                                                                    PostgreSQL (http://postgresql.com)
                                                                    Операционная система — поддерживаются следующие ОС:
                                                                    Windows (Server 2000-2008, XP, Vista, 7)
                                                                    ALTLinux
                                                                    Mandriva Linux
                                                                    Fedora
                                                                    Debian/Ubuntu
                                                                    # Описание проектов
                                                                    Название проекта	Обязателен при сборке	Обязателен при работе	Зависимости	Описание
                                                                    wfe-alfresco	нет	нет	runawfe-app	Интеграция с Alfresco
                                                                    wfe-app	да	да	wfe-ear, wfe-cactus-it	Проект для организации сборки maven
                                                                    wfe-appserver	нет	нет	 ?	Не используется
                                                                    wfe-bots	да	да	wfe-service	Подсистема ботов
                                                                    wfe-cactus-it	да	нет	wfe-service	Интеграционные тесты
                                                                    wfe-core	да	да	-	Основные компоненты системы
                                                                    wfe-ear	да	да	wfe-service, wfe-bots, wfe-office, wfe-web	Проект для сборки runawfe.ear
                                                                    wfe-office	да	нет	wfe-core	Обработчики для работы с Word, Excel
                                                                    wfe-service	да	да	wfe-core	Сервисы (EJB + WebServices), представляющие собой публичное API приложения
                                                                    wfe-web	да	да	wfe-bots	Визуальная часть приложения
                                                                    wfe-webservice-client	нет	нет	 ?	Авто-генерации клиентской библиотеки на основе WSDL серверных сервисов. В нем же есть примеры использования веб-служб из Java клиента.
                                                                    # Описание слоев архитектуры системы
                                                                    Каждый компонент состоит из нескольких уровней (слоев).

                                                                    Список слоев:

                                                                    delegate
                                                                    service
                                                                    logic
                                                                    DAO
                                                                    hibernate
                                                                    # Слой Delegate
                                                                    Delegate-классы, реализующие сервисные интерфейсы представляют собой pattern проектирования BusinessDelegate, упрощающий доступ к серверному API системы. Клиентское приложение взаимодействует с системой только через Delegate-классы. Delegate-классы получаются посредством запроса фабрики Delegates, которая в зависимости от конфигурации возвращает нужную реализацию. Классы Delegate являются частью клиентского API.

                                                                    Список основных Delegate-классов:

                                                                    AuthenticationServiceDelegate – содержит методы для аутентификации пользователей в системе (с использованием логина/пароля, Kerberos и т.п.)
                                                                    AuthorizationServiceDelegate — содержит методы для работы с полномочиями пользователей (назначение полномочий, проверка на допустимость операции для пользователя и т.п.)
                                                                    BotServiceDelegate — содержит методы для работы с бот станциями и ботами
                                                                    ExecutorServiceDelegate — содержит методы для работы с исполнителями. Позволяет создавать/удалять/изменять исполнителей а так же включать их в группы
                                                                    ProfileServiceDelegate — содержит методы для работы с профайлам пользователей
                                                                    SubstitutionServiceDelegate — содержит методы для управления правилами замещения
                                                                    SystemServiceDelegate — содержит методы для входа/выхода пользователя в систему
                                                                    DefinitionServiceDelegate — содержит методы для работы с определениями процессов
                                                                    ExecutionServiceDelegate — содержит методы для работы с исполняемыми экземплярами процессов
                                                                    Все существующие в данный момент Delegate-классы реализуют требуемую функциональность при помощи технологии EJB.

                                                                    # Слой Service
                                                                    Слой service – это серверное API доступа к системе. Реализации Delegate интерфейсов обращаются именно к этому слою. Каждый Delegate работает с одним соответствующим классом Service. В настоящее время все разработанные service классы и интерфейсы ориентированы на EJB-технологию, однако в будущем возможны и другие реализации. Реализации классов Service являются Stateless Session Bean EJB, которые декларативно поддерживают транзакционность вызовов и запрашивают соответствующие классы из слоя Logic.

                                                                    Таким образом, классы Delegate – Service - Logic образуют как бы «транспорт» между клиентом и сервером.

                                                                    # Слой Logic
                                                                    Слой Logic – это реализация бизнес логики работы системы. Слой работает с классами слоя DAO для доступа к постоянному хранилищу.

                                                                    # Слой DAO
                                                                    Слой DAO – это интерфейсы и классы, обеспечивающие доступ к данным, находящимся в постоянном хранилище (базе данных). В настоящее время все DAO-классы системы реализованы при помощи ORM-средства Hibernate.

                                                                    # Использование Hibernate
                                                                    Hibernate – ORM (Object/Relational Mapping) средство. Отображает объектную архитектуру на реляционную структуру данных. Допускает настройку (не меняя разработанного кода) на большинство существующих серверов реляционных баз данных.

                                                                    Поддерживает работу с распределенными транзакциями, автоматически создает таблицы для новых классов и т.д. Вся работа с данными внутри системы ведется только через Hibernate.

                                                                    Все компоненты, предоставляющие клиентское API построены с использованием описанных выше слоев. В целях оптимизации в некоторых компонентах применяется кеширование, которое может встречаться на уровне logic или DAO. Основная функциональность по управлению кешами находится в классах CachingLogic, CacheInterceptor и классах соответствующих кешей. Изменения в кешируемых объектах перехватываются и сообщаются посредством CachingLogic всем подписавшимся на изменения классам кешей. Транзакция, изменяющая кеш, считается закрытой по окончанию обработки ejb вызова.

                                                                    # Обновление базы данных
                                                                    см. описание системы патчей.

                                                                    # API
                                                                    Система представляет API для интеграции с другими системами:

                                                                    # Java API
                                                                    Реализация (снизу вверх): БД - Hibernate3 - EJB3

                                                                    Документацию можно смотреть в исходном коде (javadocs в *Service.java).

                                                                    # WebServices API
                                                                    Реализация (снизу вверх): БД - Hibernate3 - JAX-WS

                                                                    Документация: WebServicesDeveloperGuide

                                                                    # Scripting API
                                                                    Реализация (снизу вверх): БД - Hibernate3 - XML Script

                                                                    Документация: AdminScriptGuide

                                                                    # Процесс сборки из исходного кода
                                                                    Исходный код системы доступен в открытом репозитории на github.

                                                                    Сервер можно собирать как средствами maven используя командную строку, так и используя среду Eclipse IDE.

                                                                    В результате сборки будет сформирован runawfe.ear, который теоретически можно запустить на любом сервере приложений. Начиная с версии 4.3.0 введена поддержка JAVA версии 8, и отказ от JAVA 6. В дальнейшем планируется отказ от java7, поэтому рекомендуется использовать сервер приложений wildfly.

                                                                    # Процесс сборки на примере Eclipse IDE
                                                                    # Необходимое программное обеспечение для сборки
                                                                    В отличие от Среды разработки для сборки сервера можно использовать Eclipse IDE любой версии и редакции.

                                                                    установите плагин m2eclipse
                                                                    используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу: http://maven.apache.org/
                                                                    добавьте путь к Apache Maven директории bin в переменную окружения Path
                                                                    # Импорт проектов
                                                                    Импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server.

                                                                    Eclipse srv proj.png

                                                                    # Установка maven артефактов
                                                                    Выполните

                                                                    ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                                                                    ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                                                                    или другим способом установите артефакты в локальный репозиторий

                                                                    # Сборка
                                                                    Заведите конфигурацию запуска на основе maven как показано на рисунке

                                                                    Maven.build.configuration.png

                                                                    Запустите конфигурацию.

                                                                    Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\eclipse-workspace\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"

                                                                    # Сборка из командной строки
                                                                    используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу http://maven.apache.org/
                                                                    добавьте путь к Apache Maven директории bin в переменную окружения Path
                                                                    импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server
                                                                    выполните обновление зависимостей
                                                                    ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                                                                    ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                                                                    откройте командную строку
                                                                    перейдите в директорию ${wfe}/wfe-app/
                                                                    выполните команду для сборки
                                                                    mvn clean package -Dmaven.test.skip=true
                                                                    Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"


                                                                    Для установки артефактов в локальный репозиторий используйте команду

                                                                    mvn clean install -Dmaven.test.skip=true
                                                                    # Использование ear на сервере приложений
                                                                    cкачайте текущую версию RunaWFE в виде файл-архива исполняемых java файлов runawfe-wildfly-java8-*.zip (на базе wildfly, java8)
                                                                    распакуйте архив
                                                                    обновите runawfe.ear на версию полученную в результате сборки
                                                                    # Расширение функциональности
                                                                    # Точки расширения системы
                                                                    Обработчики позволяют исполнить код в процессах (элементы "Обработчик", "Задача сценария") и ботах
                                                                    Форматы переменных определяют тип переменных и правила преобразования значений к текстовому представлению и обратно
                                                                    Организационные функции используются при назначении ролей и в правилах замещения для определения заместителя
                                                                    Критерии замещения используются в подсистеме замещения для определения заместителя при построении списка заданий
                                                                    Валидаторы обеспечивают проверку переменных при выполнении задания (в т.ч. введенные значения форм)
                                                                    Freemarker теги форм генерируют html код для отображения на форме
                                                                    Ajax команды предоставляют доступ к функциональности сервера из JavaScript
                                                                    # Процесс разработки расширений
                                                                    Создайте новый java-проект и подключите необходимые зависимости (wfe-core, wfe-service).

                                                                    Реализуйте в нем требуемые расширения и соберите его в виде jar-файла.

                                                                    Замечание. Использование maven облегчит процесс управления зависимостями.

                                                                    Разместить собранный jar на сервере вы можете:

                                                                    положив его в runawfe.ear!/lib
                                                                    положив его в директорию deploy (только для jboss4)
                                                                    положив его в ${jboss.server.base.dir}/wfe.custom (только для jboss7)
                                                                    положив его в ${jboss.server.base.dir}/${jboss.server.name}/wfe.custom (только для jboss4)
                                                                    # Обработчики
                                                                    Обработчик в процессе – компонент процесса (элементы "Обработчик", "Задача сценария"), использующийся для выполнения каких-либо действий при возникновении определенных событий (проход по определенному переходу в процессе, приход или уход управления из узла и т.п.).

                                                                    Обработчик должен реализовывать интерфейс ru.runa.wfe.extension.ActionHandler. Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов Spring контекста (например с помощью аннотации @Autowired).

                                                                    При написании нового обработчика рекомендуется наследовать его от абстрактного класса ru.runa.wfe.extension.handler.CommonHandler или ru.runa.wfe.extension.handler.CommonParamBasedHandler. В методе setConfiguration обработчик должен запомнить свои параметры (если обработчик их ожидает), а в методе execute происходит непосредственная обработка и выполнение требуемых действий.

                                                                    В случае, если при выполнении обработчика произошла ошибка, произойдет откат транзакции и состояние процесса будет возвращено к заданию, исполнение которого повлекло вызов обработчика. В интерфейсе обработчика для бота ru.runa.wfe.extension.TaskHandler предусмотрен метод onRollback для работы с не-транзакционными ресурсами.

                                                                    Эти обработчики удобно использовать для простых операций (например для отправки оповещений в виде SMS-сообщений если процесс попал в определенное состояние). Но у них есть несколько ограничений. Прежде всего у них нет соответствующего объекта контекста безопасности (security context). Это означает, что в них нельзя выполнять защищенные методы (запуск процессов, выполнение задач, создание пользователей и т.п.) Ошибочным решением в них будет блокирование выполнения процесса (например с Thread::Sleep(...)). Например, если в обработчике отправляется e-mail, а SMTP сервер недоступен, обработчику нельзя "задерживать" свое выполнение.

                                                                    Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                                                                    # Специфика обработчиков для ботов
                                                                    Бот - это сокращение от робот. В системе боты - это особый тип исполнителей. Система не отличает ботов от людей. У каждого бота есть свои права на вход в систему, он периодически просыпается, проверяет свой список задачи и выполняет обнаруженные там задачи.

                                                                    Каждая задача бота обрабатывается при помощи соответствующего обработчика. Чтобы написать новый обработчик нужно реализовать интерфейс ru.runa.wfe.extension.TaskHandler.

                                                                    Обратите внимание, что этот вид обработчиков выполняется в контексте безопасности (security context) пользователя-бота, и здесь может выполнятся любая операция (если у бота есть на это права).

                                                                    Обработчики задач ботов могут блокировать выполнение процесса.

                                                                    Например, обработчик задач, отправляющий e-mail может блокировать выполнение бизнес процесса до тех пор, пока обработчик не удостоверится, что SMTP сервер принял сообщение для последующей доставки.

                                                                    Обработчики задач вызываются периодически, когда боты проверяют свои списки задач.

                                                                    # Специфика обработчика для элемента ветвление
                                                                    Обработчик для Decision является java-классом, реализующим интерфейс ru.runa.wfe.extension.DecisionHandler. Интерфейс содержит один метод decide(ExecutionContext executionContext), который возвращает имя выбранного перехода (одного из выходящих из данного ветвления). Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов контекста спринга (например с помощью аннотации @Autowired).

                                                                    Обработчик принимает ExecutionContext в качестве входящего параметра и должен сделать выбор перехода исходя из значений переменных бизнес процесса и условий, указанных в конфигурации обработчика. Точно также как обработчики действия (action handler) обработчики выбора (decision handlers) не могут использовать защищенные (secured) методы, не могут обрабатывать ошибки и откладывать выбор перехода до лучших времен.

                                                                    По умолчанию используется ru.runa.wfe.extension.decision.GroovyDecisionHandler.

                                                                    # Использование ru.runa.wfe.extension.handler.CommonParamBasedHandler в качестве базового класса
                                                                    Этот класс инкапсулирует в себе парсинг XML конфигурации определенного формата. Его удобно использовать если обработчик имеет фиксированное число параметров. Пример конфигурации:

                                                                    <?xml version="1.0" encoding="UTF-8"?>
                                                                    <config>
                                                                     <input>
                                                                       <param name="typeName" variable="тип отсутствия" />
                                                                       <param name="employee" variable="сотрудник" />
                                                                       <param name="requester" variable="подавший заявку" />
                                                                       <param name="from" variable="дата с" />
                                                                       <param name="to" variable="дата по" />
                                                                       <param name="cause" variable="причина" />
                                                                       <param name="comment" variable="комментарий" />
                                                                       <param name="confirmation" variable="дата подтверждения" />
                                                                       <param name="firmCode" value="111" />
                                                                       <param name="firmPositionCode" variable="код должности" />
                                                                       <param name="firmDepartmentCode" variable="код подразделения" />
                                                                     </input>
                                                                     <output>
                                                                       <param name="uuid" variable="идентификатор объекта" />
                                                                     </output>
                                                                    </config>
                                                                    Использование обработчика Groovy
                                                                    См. соответствующий раздел в руководстве по работе с Groovy.

                                                                    # Как написать функцию над организационной структурой
                                                                    Функции над организационной структурой в системе применяются, например, при инициализации Ролей-Дорожек и в правилах замещения.

                                                                    Класс, соответствующий функции над организационной структурой, должен реализовывать интерфейс ru.runa.wfe.extension.OrgFunction.

                                                                    Интерфейс содержит один метод

                                                                    List<? extends Executor> getExecutors(Object... parameters)
                                                                    Этот метод должен возвращать список исполнителей.

                                                                    В бизнес-процессе обработчик функции над оргструктурой используются при определении Ролей-Дорожек: указывается внутри тега swimlane, в теле тега <assignment>.В качестве параметра class тега <assignment> указывается класс-обработчик для инициализации swimlane: ru.runa.wfe.extension.AssignmentHandler. Внутри тега <assignment> содержится конфигурация для этого класса, которая представляет собой имя класса-наследника интерфейса OrgFunction и список параметров в скобках. В качестве параметра может выступать конкретное значение или имя переменной бизнес процесса в фигурных скобках, перед которым стоит значок $

                                                                    Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                                                                    Если есть планы по использованию функции в подсистеме замещений - её можно зарегистрировать в substitutions.xml.

                                                                    # Как написать критерий замещения
                                                                    Критерии замещения в системе применяются в правилах замещения. Класс, соответствующий критерию замещения, должен наследоваться от ru.runa.wfe.ss.SubstitutionCriteria.

                                                                    Для создания на основе него конечных критериев замещения с конфигурациями - его нужно зарегистрировать в substitution.criterias.xml.

                                                                    Как реализовать класс-формат для переменных бизнес-процесса
                                                                    См. соответствующий раздел в руководстве по работе с переменными.

                                                                    # Как реализовать валидатор переменных
                                                                    Классы, расширяющие абстрактный класс ru.runa.wfe.validation.FieldValidator, в системе применяются для проверки переменных при выполнении задания или старте процесса.

                                                                    Пример:

                                                                    public class OvertimeWorkRequestTimeCheck extends FieldValidator {
                                                                       @Override
                                                                       public void validate() {
                                                                           Date date = (Date) getFieldValue();
                                                                           if (date == null) {
                                                                               return;
                                                                           }
                                                                           boolean testMode = getVariableProvider().getValueNotNull(boolean.class, "тестовый режим");
                                                                           if (testMode) {
                                                                               return;
                                                                           }
                                                                           Calendar calendar = CalendarUtil.dateToCalendar(date);
                                                                           if (calendar.before(Calendar.getInstance())) {
                                                                               addError("Заявка не может быть оформлена задним числом");
                                                                               return;
                                                                           }
                                                                           CalendarUtil.setTimeFromCalendar(calendar, DemoProperties.getOvertimeWorkRequestMaximumStartTime());
                                                                           Utils.adjustCalendarForHolidaysInOvertimwWork(calendar);
                                                                           if (calendar.before(Calendar.getInstance())) {
                                                                               addError("Заявка на этот день не может быть подана, время подачи истекло " + CalendarUtil.formatDateTime(calendar));
                                                                           }
                                                                       }
                                                                    }

                                                                    Связь между Средой разработки и сервером осуществляется по имени валидатора, регистрация требуется на стороне сервера в файле validators.xml, а в среде разработки - в plugin.xml.

                                                                    # Как реализовать FreeMarker тег для формы
                                                                    FreemarkerForms#Components

                                                                    # Как реализовать Ajax команду
                                                                    Классы, расширяющие абстрактный класс ru.runa.wfe.commons.web.JsonAjaxCommand, (или реализующие ru.runa.wfe.commons.web.AjaxCommand) в системе применяются для доступа к функциональности сервера из JavaScript, например при отображении форм задания.

                                                                    Регистрация команды происходит любым из двух способов:

                                                                    в файле ajax.commands.xml, ей присваивается определенное имя
                                                                    в контексте приложения, именем является id spring-бина
                                                                    Затем по этому имени её можно выполнить используя JavaScript.

                                                                    Пример команды

                                                                    public class GetOrganizationNamesCommand extends JsonAjaxCommand {
                                                                       @Autowired
                                                                       private OrganizationDAO organizationDAO;
                                                                       @Override
                                                                       protected JSONAware execute(User user, HttpServletRequest request) throws Exception {
                                                                           String term = request.getParameter("term");
                                                                           if (term == null) {
                                                                               term = "";
                                                                           }
                                                                           List<Organization> organizations = organizationDAO.getAll();
                                                                           JSONArray array = new JSONArray();
                                                                           for (Organization organization : organizations) {
                                                                               if (organization.getName().startsWith(term)) {
                                                                                   array.add(organization.getName());
                                                                               }
                                                                           }
                                                                           return array;
                                                                       }
                                                                    }
                                                                    Регистрация в wfe.custom.ajax.commands.xml

                                                                    <?xml version="1.0" encoding="UTF-8" ?>
                                                                    <configuration xmlns="http://runa.ru/xml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://runa.ru/xml">
                                                                     <command name="getOrganizationNames" class="ru.runa.rkdemo.web.ajax.GetOrganizationNamesCommand" />
                                                                    </configuration>
                                                                    Её использование со скрипта формы (autocomplete input)

                                                                    $(document).ready(function() {
                                                                     $('#editLinkedLists').on("onRowAdded", function(event, rowIndex) {
                                                                      $("input[name='названия организаций["+rowIndex+"]']").autocomplete( {
                                                                       delay: 300,
                                                                       minLength: 0,
                                                                       source: "/wfe/ajaxcmd?command=getOrganizationNames"
                                                                      });
                                                                      $("input[name='названия организаций["+rowIndex+"]']").focus(function() {
                                                                       $(this).autocomplete("search", $(this).val());
                                                                      });
                                                                     });
                                                                    });Введение
                                                                       # Основные компоненты и используемые технологии
                                                                       Для WF–системы была выбрана следующая общая архитектура (в целом соответствует архитектуре, предлагаемой коалицией WfMC):

                                                                       Компоненты системы:

                                                                       Ядро системы
                                                                       Содержит набор определений бизнес-процессов
                                                                       Содержит набор выполняющихся экземпляров бизнес–процессов
                                                                       Компонент, "назначающий" исполнителей для действий
                                                                       Клиент
                                                                       Список заданий (набор графических форм, содержит очереди поступивших работ, сортировки и фильтры)
                                                                       Проигрыватель форм (отображает формы, разработанные в Среде разработки)
                                                                       Административный интерфейс
                                                                       Показывает состояния процессов, позволяет фильтровать и останавливать процессы
                                                                       Позволяет загружать-выгружать процессы
                                                                       Позволяет заводить-удалять пользователей
                                                                       Позволяет задавать различные права
                                                                       Редактор назначения заместителей
                                                                       Среда разработки
                                                                       Конструктор графических форм
                                                                       Бот станции, содержащие ботов (Боты - приложения специального вида, которые также как и обычные пользователи могут выполнять задания)
                                                                       Подсистема управления правами доступа (авторизация и аутентификация)
                                                                       # Платформа программирования и используемые программные средства
                                                                       В качестве платформы программирования используется J2EE.

                                                                       Используемые программные средства:

                                                                       Сервер приложений - JBOSS (http://www.jboss.org).
                                                                       Среда разработки - любая, например Eclipse от IBM (http://www.eclipse.org).
                                                                       Система контроля версий - git
                                                                       Сборщик приложений – maven.
                                                                       Сервер баз данных – поддерживаются сервера БД:
                                                                       MS SQL Server (http://www.microsoft.com/sql/evaluation/default.mspx)
                                                                       HSQL (http://hsqldb.org)
                                                                       Oracle (http://www.oracle.com)
                                                                       PostgreSQL (http://postgresql.com)
                                                                       Операционная система — поддерживаются следующие ОС:
                                                                       Windows (Server 2000-2008, XP, Vista, 7)
                                                                       ALTLinux
                                                                       Mandriva Linux
                                                                       Fedora
                                                                       Debian/Ubuntu
                                                                       # Описание проектов
                                                                       Название проекта	Обязателен при сборке	Обязателен при работе	Зависимости	Описание
                                                                       wfe-alfresco	нет	нет	runawfe-app	Интеграция с Alfresco
                                                                       wfe-app	да	да	wfe-ear, wfe-cactus-it	Проект для организации сборки maven
                                                                       wfe-appserver	нет	нет	 ?	Не используется
                                                                       wfe-bots	да	да	wfe-service	Подсистема ботов
                                                                       wfe-cactus-it	да	нет	wfe-service	Интеграционные тесты
                                                                       wfe-core	да	да	-	Основные компоненты системы
                                                                       wfe-ear	да	да	wfe-service, wfe-bots, wfe-office, wfe-web	Проект для сборки runawfe.ear
                                                                       wfe-office	да	нет	wfe-core	Обработчики для работы с Word, Excel
                                                                       wfe-service	да	да	wfe-core	Сервисы (EJB + WebServices), представляющие собой публичное API приложения
                                                                       wfe-web	да	да	wfe-bots	Визуальная часть приложения
                                                                       wfe-webservice-client	нет	нет	 ?	Авто-генерации клиентской библиотеки на основе WSDL серверных сервисов. В нем же есть примеры использования веб-служб из Java клиента.
                                                                       # Описание слоев архитектуры системы
                                                                       Каждый компонент состоит из нескольких уровней (слоев).

                                                                       Список слоев:

                                                                       delegate
                                                                       service
                                                                       logic
                                                                       DAO
                                                                       hibernate
                                                                       # Слой Delegate
                                                                       Delegate-классы, реализующие сервисные интерфейсы представляют собой pattern проектирования BusinessDelegate, упрощающий доступ к серверному API системы. Клиентское приложение взаимодействует с системой только через Delegate-классы. Delegate-классы получаются посредством запроса фабрики Delegates, которая в зависимости от конфигурации возвращает нужную реализацию. Классы Delegate являются частью клиентского API.

                                                                       Список основных Delegate-классов:

                                                                       AuthenticationServiceDelegate – содержит методы для аутентификации пользователей в системе (с использованием логина/пароля, Kerberos и т.п.)
                                                                       AuthorizationServiceDelegate — содержит методы для работы с полномочиями пользователей (назначение полномочий, проверка на допустимость операции для пользователя и т.п.)
                                                                       BotServiceDelegate — содержит методы для работы с бот станциями и ботами
                                                                       ExecutorServiceDelegate — содержит методы для работы с исполнителями. Позволяет создавать/удалять/изменять исполнителей а так же включать их в группы
                                                                       ProfileServiceDelegate — содержит методы для работы с профайлам пользователей
                                                                       SubstitutionServiceDelegate — содержит методы для управления правилами замещения
                                                                       SystemServiceDelegate — содержит методы для входа/выхода пользователя в систему
                                                                       DefinitionServiceDelegate — содержит методы для работы с определениями процессов
                                                                       ExecutionServiceDelegate — содержит методы для работы с исполняемыми экземплярами процессов
                                                                       Все существующие в данный момент Delegate-классы реализуют требуемую функциональность при помощи технологии EJB.

                                                                       # Слой Service
                                                                       Слой service – это серверное API доступа к системе. Реализации Delegate интерфейсов обращаются именно к этому слою. Каждый Delegate работает с одним соответствующим классом Service. В настоящее время все разработанные service классы и интерфейсы ориентированы на EJB-технологию, однако в будущем возможны и другие реализации. Реализации классов Service являются Stateless Session Bean EJB, которые декларативно поддерживают транзакционность вызовов и запрашивают соответствующие классы из слоя Logic.

                                                                       Таким образом, классы Delegate – Service - Logic образуют как бы «транспорт» между клиентом и сервером.

                                                                       # Слой Logic
                                                                       Слой Logic – это реализация бизнес логики работы системы. Слой работает с классами слоя DAO для доступа к постоянному хранилищу.

                                                                       # Слой DAO
                                                                       Слой DAO – это интерфейсы и классы, обеспечивающие доступ к данным, находящимся в постоянном хранилище (базе данных). В настоящее время все DAO-классы системы реализованы при помощи ORM-средства Hibernate.

                                                                       # Использование Hibernate
                                                                       Hibernate – ORM (Object/Relational Mapping) средство. Отображает объектную архитектуру на реляционную структуру данных. Допускает настройку (не меняя разработанного кода) на большинство существующих серверов реляционных баз данных.

                                                                       Поддерживает работу с распределенными транзакциями, автоматически создает таблицы для новых классов и т.д. Вся работа с данными внутри системы ведется только через Hibernate.

                                                                       Все компоненты, предоставляющие клиентское API построены с использованием описанных выше слоев. В целях оптимизации в некоторых компонентах применяется кеширование, которое может встречаться на уровне logic или DAO. Основная функциональность по управлению кешами находится в классах CachingLogic, CacheInterceptor и классах соответствующих кешей. Изменения в кешируемых объектах перехватываются и сообщаются посредством CachingLogic всем подписавшимся на изменения классам кешей. Транзакция, изменяющая кеш, считается закрытой по окончанию обработки ejb вызова.

                                                                       # Обновление базы данных
                                                                       см. описание системы патчей.

                                                                       # API
                                                                       Система представляет API для интеграции с другими системами:

                                                                       # Java API
                                                                       Реализация (снизу вверх): БД - Hibernate3 - EJB3

                                                                       Документацию можно смотреть в исходном коде (javadocs в *Service.java).

                                                                       # WebServices API
                                                                       Реализация (снизу вверх): БД - Hibernate3 - JAX-WS

                                                                       Документация: WebServicesDeveloperGuide

                                                                       # Scripting API
                                                                       Реализация (снизу вверх): БД - Hibernate3 - XML Script

                                                                       Документация: AdminScriptGuide

                                                                       # Процесс сборки из исходного кода
                                                                       Исходный код системы доступен в открытом репозитории на github.

                                                                       Сервер можно собирать как средствами maven используя командную строку, так и используя среду Eclipse IDE.

                                                                       В результате сборки будет сформирован runawfe.ear, который теоретически можно запустить на любом сервере приложений. Начиная с версии 4.3.0 введена поддержка JAVA версии 8, и отказ от JAVA 6. В дальнейшем планируется отказ от java7, поэтому рекомендуется использовать сервер приложений wildfly.

                                                                       # Процесс сборки на примере Eclipse IDE
                                                                       # Необходимое программное обеспечение для сборки
                                                                       В отличие от Среды разработки для сборки сервера можно использовать Eclipse IDE любой версии и редакции.

                                                                       установите плагин m2eclipse
                                                                       используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу: http://maven.apache.org/
                                                                       добавьте путь к Apache Maven директории bin в переменную окружения Path
                                                                       # Импорт проектов
                                                                       Импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server.

                                                                       Eclipse srv proj.png

                                                                       # Установка maven артефактов
                                                                       Выполните

                                                                       ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                                                                       ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                                                                       или другим способом установите артефакты в локальный репозиторий

                                                                       # Сборка
                                                                       Заведите конфигурацию запуска на основе maven как показано на рисунке

                                                                       Maven.build.configuration.png

                                                                       Запустите конфигурацию.

                                                                       Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\eclipse-workspace\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"

                                                                       # Сборка из командной строки
                                                                       используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу http://maven.apache.org/
                                                                       добавьте путь к Apache Maven директории bin в переменную окружения Path
                                                                       импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server
                                                                       выполните обновление зависимостей
                                                                       ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                                                                       ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                                                                       откройте командную строку
                                                                       перейдите в директорию ${wfe}/wfe-app/
                                                                       выполните команду для сборки
                                                                       mvn clean package -Dmaven.test.skip=true
                                                                       Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"


                                                                       Для установки артефактов в локальный репозиторий используйте команду

                                                                       mvn clean install -Dmaven.test.skip=true
                                                                       # Использование ear на сервере приложений
                                                                       cкачайте текущую версию RunaWFE в виде файл-архива исполняемых java файлов runawfe-wildfly-java8-*.zip (на базе wildfly, java8)
                                                                       распакуйте архив
                                                                       обновите runawfe.ear на версию полученную в результате сборки
                                                                       # Расширение функциональности
                                                                       # Точки расширения системы
                                                                       Обработчики позволяют исполнить код в процессах (элементы "Обработчик", "Задача сценария") и ботах
                                                                       Форматы переменных определяют тип переменных и правила преобразования значений к текстовому представлению и обратно
                                                                       Организационные функции используются при назначении ролей и в правилах замещения для определения заместителя
                                                                       Критерии замещения используются в подсистеме замещения для определения заместителя при построении списка заданий
                                                                       Валидаторы обеспечивают проверку переменных при выполнении задания (в т.ч. введенные значения форм)
                                                                       Freemarker теги форм генерируют html код для отображения на форме
                                                                       Ajax команды предоставляют доступ к функциональности сервера из JavaScript
                                                                       # Процесс разработки расширений
                                                                       Создайте новый java-проект и подключите необходимые зависимости (wfe-core, wfe-service).

                                                                       Реализуйте в нем требуемые расширения и соберите его в виде jar-файла.

                                                                       Замечание. Использование maven облегчит процесс управления зависимостями.

                                                                       Разместить собранный jar на сервере вы можете:

                                                                       положив его в runawfe.ear!/lib
                                                                       положив его в директорию deploy (только для jboss4)
                                                                       положив его в ${jboss.server.base.dir}/wfe.custom (только для jboss7)
                                                                       положив его в ${jboss.server.base.dir}/${jboss.server.name}/wfe.custom (только для jboss4)
                                                                       # Обработчики
                                                                       Обработчик в процессе – компонент процесса (элементы "Обработчик", "Задача сценария"), использующийся для выполнения каких-либо действий при возникновении определенных событий (проход по определенному переходу в процессе, приход или уход управления из узла и т.п.).

                                                                       Обработчик должен реализовывать интерфейс ru.runa.wfe.extension.ActionHandler. Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов Spring контекста (например с помощью аннотации @Autowired).

                                                                       При написании нового обработчика рекомендуется наследовать его от абстрактного класса ru.runa.wfe.extension.handler.CommonHandler или ru.runa.wfe.extension.handler.CommonParamBasedHandler. В методе setConfiguration обработчик должен запомнить свои параметры (если обработчик их ожидает), а в методе execute происходит непосредственная обработка и выполнение требуемых действий.

                                                                       В случае, если при выполнении обработчика произошла ошибка, произойдет откат транзакции и состояние процесса будет возвращено к заданию, исполнение которого повлекло вызов обработчика. В интерфейсе обработчика для бота ru.runa.wfe.extension.TaskHandler предусмотрен метод onRollback для работы с не-транзакционными ресурсами.

                                                                       Эти обработчики удобно использовать для простых операций (например для отправки оповещений в виде SMS-сообщений если процесс попал в определенное состояние). Но у них есть несколько ограничений. Прежде всего у них нет соответствующего объекта контекста безопасности (security context). Это означает, что в них нельзя выполнять защищенные методы (запуск процессов, выполнение задач, создание пользователей и т.п.) Ошибочным решением в них будет блокирование выполнения процесса (например с Thread::Sleep(...)). Например, если в обработчике отправляется e-mail, а SMTP сервер недоступен, обработчику нельзя "задерживать" свое выполнение.

                                                                       Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                                                                       # Специфика обработчиков для ботов
                                                                       Бот - это сокращение от робот. В системе боты - это особый тип исполнителей. Система не отличает ботов от людей. У каждого бота есть свои права на вход в систему, он периодически просыпается, проверяет свой список задачи и выполняет обнаруженные там задачи.

                                                                       Каждая задача бота обрабатывается при помощи соответствующего обработчика. Чтобы написать новый обработчик нужно реализовать интерфейс ru.runa.wfe.extension.TaskHandler.

                                                                       Обратите внимание, что этот вид обработчиков выполняется в контексте безопасности (security context) пользователя-бота, и здесь может выполнятся любая операция (если у бота есть на это права).

                                                                       Обработчики задач ботов могут блокировать выполнение процесса.

                                                                       Например, обработчик задач, отправляющий e-mail может блокировать выполнение бизнес процесса до тех пор, пока обработчик не удостоверится, что SMTP сервер принял сообщение для последующей доставки.

                                                                       Обработчики задач вызываются периодически, когда боты проверяют свои списки задач.

                                                                       # Специфика обработчика для элемента ветвление
                                                                       Обработчик для Decision является java-классом, реализующим интерфейс ru.runa.wfe.extension.DecisionHandler. Интерфейс содержит один метод decide(ExecutionContext executionContext), который возвращает имя выбранного перехода (одного из выходящих из данного ветвления). Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов контекста спринга (например с помощью аннотации @Autowired).

                                                                       Обработчик принимает ExecutionContext в качестве входящего параметра и должен сделать выбор перехода исходя из значений переменных бизнес процесса и условий, указанных в конфигурации обработчика. Точно также как обработчики действия (action handler) обработчики выбора (decision handlers) не могут использовать защищенные (secured) методы, не могут обрабатывать ошибки и откладывать выбор перехода до лучших времен.

                                                                       По умолчанию используется ru.runa.wfe.extension.decision.GroovyDecisionHandler.

                                                                       # Использование ru.runa.wfe.extension.handler.CommonParamBasedHandler в качестве базового класса
                                                                       Этот класс инкапсулирует в себе парсинг XML конфигурации определенного формата. Его удобно использовать если обработчик имеет фиксированное число параметров. Пример конфигурации:

                                                                       <?xml version="1.0" encoding="UTF-8"?>
                                                                       <config>
                                                                        <input>
                                                                          <param name="typeName" variable="тип отсутствия" />
                                                                          <param name="employee" variable="сотрудник" />
                                                                          <param name="requester" variable="подавший заявку" />
                                                                          <param name="from" variable="дата с" />
                                                                          <param name="to" variable="дата по" />
                                                                          <param name="cause" variable="причина" />
                                                                          <param name="comment" variable="комментарий" />
                                                                          <param name="confirmation" variable="дата подтверждения" />
                                                                          <param name="firmCode" value="111" />
                                                                          <param name="firmPositionCode" variable="код должности" />
                                                                          <param name="firmDepartmentCode" variable="код подразделения" />
                                                                        </input>
                                                                        <output>
                                                                          <param name="uuid" variable="идентификатор объекта" />
                                                                        </output>
                                                                       </config>
                                                                       Использование обработчика Groovy
                                                                       См. соответствующий раздел в руководстве по работе с Groovy.

                                                                       # Как написать функцию над организационной структурой
                                                                       Функции над организационной структурой в системе применяются, например, при инициализации Ролей-Дорожек и в правилах замещения.

                                                                       Класс, соответствующий функции над организационной структурой, должен реализовывать интерфейс ru.runa.wfe.extension.OrgFunction.

                                                                       Интерфейс содержит один метод

                                                                       List<? extends Executor> getExecutors(Object... parameters)
                                                                       Этот метод должен возвращать список исполнителей.

                                                                       В бизнес-процессе обработчик функции над оргструктурой используются при определении Ролей-Дорожек: указывается внутри тега swimlane, в теле тега <assignment>.В качестве параметра class тега <assignment> указывается класс-обработчик для инициализации swimlane: ru.runa.wfe.extension.AssignmentHandler. Внутри тега <assignment> содержится конфигурация для этого класса, которая представляет собой имя класса-наследника интерфейса OrgFunction и список параметров в скобках. В качестве параметра может выступать конкретное значение или имя переменной бизнес процесса в фигурных скобках, перед которым стоит значок $

                                                                       Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                                                                       Если есть планы по использованию функции в подсистеме замещений - её можно зарегистрировать в substitutions.xml.

                                                                       # Как написать критерий замещения
                                                                       Критерии замещения в системе применяются в правилах замещения. Класс, соответствующий критерию замещения, должен наследоваться от ru.runa.wfe.ss.SubstitutionCriteria.

                                                                       Для создания на основе него конечных критериев замещения с конфигурациями - его нужно зарегистрировать в substitution.criterias.xml.

                                                                       Как реализовать класс-формат для переменных бизнес-процесса
                                                                       См. соответствующий раздел в руководстве по работе с переменными.

                                                                       # Как реализовать валидатор переменных
                                                                       Классы, расширяющие абстрактный класс ru.runa.wfe.validation.FieldValidator, в системе применяются для проверки переменных при выполнении задания или старте процесса.

                                                                       Пример:

                                                                       public class OvertimeWorkRequestTimeCheck extends FieldValidator {
                                                                          @Override
                                                                          public void validate() {
                                                                              Date date = (Date) getFieldValue();
                                                                              if (date == null) {
                                                                                  return;
                                                                              }
                                                                              boolean testMode = getVariableProvider().getValueNotNull(boolean.class, "тестовый режим");
                                                                              if (testMode) {
                                                                                  return;
                                                                              }
                                                                              Calendar calendar = CalendarUtil.dateToCalendar(date);
                                                                              if (calendar.before(Calendar.getInstance())) {
                                                                                  addError("Заявка не может быть оформлена задним числом");
                                                                                  return;
                                                                              }
                                                                              CalendarUtil.setTimeFromCalendar(calendar, DemoProperties.getOvertimeWorkRequestMaximumStartTime());
                                                                              Utils.adjustCalendarForHolidaysInOvertimwWork(calendar);
                                                                              if (calendar.before(Calendar.getInstance())) {
                                                                                  addError("Заявка на этот день не может быть подана, время подачи истекло " + CalendarUtil.formatDateTime(calendar));
                                                                              }
                                                                          }
                                                                       }

                                                                       Связь между Средой разработки и сервером осуществляется по имени валидатора, регистрация требуется на стороне сервера в файле validators.xml, а в среде разработки - в plugin.xml.

                                                                       # Как реализовать FreeMarker тег для формы
                                                                       FreemarkerForms#Components

                                                                       # Как реализовать Ajax команду
                                                                       Классы, расширяющие абстрактный класс ru.runa.wfe.commons.web.JsonAjaxCommand, (или реализующие ru.runa.wfe.commons.web.AjaxCommand) в системе применяются для доступа к функциональности сервера из JavaScript, например при отображении форм задания.

                                                                       Регистрация команды происходит любым из двух способов:

                                                                       в файле ajax.commands.xml, ей присваивается определенное имя
                                                                       в контексте приложения, именем является id spring-бина
                                                                       Затем по этому имени её можно выполнить используя JavaScript.

                                                                       Пример команды

                                                                       public class GetOrganizationNamesCommand extends JsonAjaxCommand {
                                                                          @Autowired
                                                                          private OrganizationDAO organizationDAO;
                                                                          @Override
                                                                          protected JSONAware execute(User user, HttpServletRequest request) throws Exception {
                                                                              String term = request.getParameter("term");
                                                                              if (term == null) {
                                                                                  term = "";
                                                                              }
                                                                              List<Organization> organizations = organizationDAO.getAll();
                                                                              JSONArray array = new JSONArray();
                                                                              for (Organization organization : organizations) {
                                                                                  if (organization.getName().startsWith(term)) {
                                                                                      array.add(organization.getName());
                                                                                  }
                                                                              }
                                                                              return array;
                                                                          }
                                                                       }
                                                                       Регистрация в wfe.custom.ajax.commands.xml

                                                                       <?xml version="1.0" encoding="UTF-8" ?>
                                                                       <configuration xmlns="http://runa.ru/xml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://runa.ru/xml">
                                                                        <command name="getOrganizationNames" class="ru.runa.rkdemo.web.ajax.GetOrganizationNamesCommand" />
                                                                       </configuration>
                                                                       Её использование со скрипта формы (autocomplete input)

                                                                       $(document).ready(function() {
                                                                        $('#editLinkedLists').on("onRowAdded", function(event, rowIndex) {
                                                                         $("input[name='названия организаций["+rowIndex+"]']").autocomplete( {
                                                                          delay: 300,
                                                                          minLength: 0,
                                                                          source: "/wfe/ajaxcmd?command=getOrganizationNames"
                                                                         });
                                                                         $("input[name='названия организаций["+rowIndex+"]']").focus(function() {
                                                                          $(this).autocomplete("search", $(this).val());
                                                                         });
                                                                        });
                                                                       });Введение
                                                                          # Основные компоненты и используемые технологии
                                                                          Для WF–системы была выбрана следующая общая архитектура (в целом соответствует архитектуре, предлагаемой коалицией WfMC):

                                                                          Компоненты системы:

                                                                          Ядро системы
                                                                          Содержит набор определений бизнес-процессов
                                                                          Содержит набор выполняющихся экземпляров бизнес–процессов
                                                                          Компонент, "назначающий" исполнителей для действий
                                                                          Клиент
                                                                          Список заданий (набор графических форм, содержит очереди поступивших работ, сортировки и фильтры)
                                                                          Проигрыватель форм (отображает формы, разработанные в Среде разработки)
                                                                          Административный интерфейс
                                                                          Показывает состояния процессов, позволяет фильтровать и останавливать процессы
                                                                          Позволяет загружать-выгружать процессы
                                                                          Позволяет заводить-удалять пользователей
                                                                          Позволяет задавать различные права
                                                                          Редактор назначения заместителей
                                                                          Среда разработки
                                                                          Конструктор графических форм
                                                                          Бот станции, содержащие ботов (Боты - приложения специального вида, которые также как и обычные пользователи могут выполнять задания)
                                                                          Подсистема управления правами доступа (авторизация и аутентификация)
                                                                          # Платформа программирования и используемые программные средства
                                                                          В качестве платформы программирования используется J2EE.

                                                                          Используемые программные средства:

                                                                          Сервер приложений - JBOSS (http://www.jboss.org).
                                                                          Среда разработки - любая, например Eclipse от IBM (http://www.eclipse.org).
                                                                          Система контроля версий - git
                                                                          Сборщик приложений – maven.
                                                                          Сервер баз данных – поддерживаются сервера БД:
                                                                          MS SQL Server (http://www.microsoft.com/sql/evaluation/default.mspx)
                                                                          HSQL (http://hsqldb.org)
                                                                          Oracle (http://www.oracle.com)
                                                                          PostgreSQL (http://postgresql.com)
                                                                          Операционная система — поддерживаются следующие ОС:
                                                                          Windows (Server 2000-2008, XP, Vista, 7)
                                                                          ALTLinux
                                                                          Mandriva Linux
                                                                          Fedora
                                                                          Debian/Ubuntu
                                                                          # Описание проектов
                                                                          Название проекта	Обязателен при сборке	Обязателен при работе	Зависимости	Описание
                                                                          wfe-alfresco	нет	нет	runawfe-app	Интеграция с Alfresco
                                                                          wfe-app	да	да	wfe-ear, wfe-cactus-it	Проект для организации сборки maven
                                                                          wfe-appserver	нет	нет	 ?	Не используется
                                                                          wfe-bots	да	да	wfe-service	Подсистема ботов
                                                                          wfe-cactus-it	да	нет	wfe-service	Интеграционные тесты
                                                                          wfe-core	да	да	-	Основные компоненты системы
                                                                          wfe-ear	да	да	wfe-service, wfe-bots, wfe-office, wfe-web	Проект для сборки runawfe.ear
                                                                          wfe-office	да	нет	wfe-core	Обработчики для работы с Word, Excel
                                                                          wfe-service	да	да	wfe-core	Сервисы (EJB + WebServices), представляющие собой публичное API приложения
                                                                          wfe-web	да	да	wfe-bots	Визуальная часть приложения
                                                                          wfe-webservice-client	нет	нет	 ?	Авто-генерации клиентской библиотеки на основе WSDL серверных сервисов. В нем же есть примеры использования веб-служб из Java клиента.
                                                                          # Описание слоев архитектуры системы
                                                                          Каждый компонент состоит из нескольких уровней (слоев).

                                                                          Список слоев:

                                                                          delegate
                                                                          service
                                                                          logic
                                                                          DAO
                                                                          hibernate
                                                                          # Слой Delegate
                                                                          Delegate-классы, реализующие сервисные интерфейсы представляют собой pattern проектирования BusinessDelegate, упрощающий доступ к серверному API системы. Клиентское приложение взаимодействует с системой только через Delegate-классы. Delegate-классы получаются посредством запроса фабрики Delegates, которая в зависимости от конфигурации возвращает нужную реализацию. Классы Delegate являются частью клиентского API.

                                                                          Список основных Delegate-классов:

                                                                          AuthenticationServiceDelegate – содержит методы для аутентификации пользователей в системе (с использованием логина/пароля, Kerberos и т.п.)
                                                                          AuthorizationServiceDelegate — содержит методы для работы с полномочиями пользователей (назначение полномочий, проверка на допустимость операции для пользователя и т.п.)
                                                                          BotServiceDelegate — содержит методы для работы с бот станциями и ботами
                                                                          ExecutorServiceDelegate — содержит методы для работы с исполнителями. Позволяет создавать/удалять/изменять исполнителей а так же включать их в группы
                                                                          ProfileServiceDelegate — содержит методы для работы с профайлам пользователей
                                                                          SubstitutionServiceDelegate — содержит методы для управления правилами замещения
                                                                          SystemServiceDelegate — содержит методы для входа/выхода пользователя в систему
                                                                          DefinitionServiceDelegate — содержит методы для работы с определениями процессов
                                                                          ExecutionServiceDelegate — содержит методы для работы с исполняемыми экземплярами процессов
                                                                          Все существующие в данный момент Delegate-классы реализуют требуемую функциональность при помощи технологии EJB.

                                                                          # Слой Service
                                                                          Слой service – это серверное API доступа к системе. Реализации Delegate интерфейсов обращаются именно к этому слою. Каждый Delegate работает с одним соответствующим классом Service. В настоящее время все разработанные service классы и интерфейсы ориентированы на EJB-технологию, однако в будущем возможны и другие реализации. Реализации классов Service являются Stateless Session Bean EJB, которые декларативно поддерживают транзакционность вызовов и запрашивают соответствующие классы из слоя Logic.

                                                                          Таким образом, классы Delegate – Service - Logic образуют как бы «транспорт» между клиентом и сервером.

                                                                          # Слой Logic
                                                                          Слой Logic – это реализация бизнес логики работы системы. Слой работает с классами слоя DAO для доступа к постоянному хранилищу.

                                                                          # Слой DAO
                                                                          Слой DAO – это интерфейсы и классы, обеспечивающие доступ к данным, находящимся в постоянном хранилище (базе данных). В настоящее время все DAO-классы системы реализованы при помощи ORM-средства Hibernate.

                                                                          # Использование Hibernate
                                                                          Hibernate – ORM (Object/Relational Mapping) средство. Отображает объектную архитектуру на реляционную структуру данных. Допускает настройку (не меняя разработанного кода) на большинство существующих серверов реляционных баз данных.

                                                                          Поддерживает работу с распределенными транзакциями, автоматически создает таблицы для новых классов и т.д. Вся работа с данными внутри системы ведется только через Hibernate.

                                                                          Все компоненты, предоставляющие клиентское API построены с использованием описанных выше слоев. В целях оптимизации в некоторых компонентах применяется кеширование, которое может встречаться на уровне logic или DAO. Основная функциональность по управлению кешами находится в классах CachingLogic, CacheInterceptor и классах соответствующих кешей. Изменения в кешируемых объектах перехватываются и сообщаются посредством CachingLogic всем подписавшимся на изменения классам кешей. Транзакция, изменяющая кеш, считается закрытой по окончанию обработки ejb вызова.

                                                                          # Обновление базы данных
                                                                          см. описание системы патчей.

                                                                          # API
                                                                          Система представляет API для интеграции с другими системами:

                                                                          # Java API
                                                                          Реализация (снизу вверх): БД - Hibernate3 - EJB3

                                                                          Документацию можно смотреть в исходном коде (javadocs в *Service.java).

                                                                          # WebServices API
                                                                          Реализация (снизу вверх): БД - Hibernate3 - JAX-WS

                                                                          Документация: WebServicesDeveloperGuide

                                                                          # Scripting API
                                                                          Реализация (снизу вверх): БД - Hibernate3 - XML Script

                                                                          Документация: AdminScriptGuide

                                                                          # Процесс сборки из исходного кода
                                                                          Исходный код системы доступен в открытом репозитории на github.

                                                                          Сервер можно собирать как средствами maven используя командную строку, так и используя среду Eclipse IDE.

                                                                          В результате сборки будет сформирован runawfe.ear, который теоретически можно запустить на любом сервере приложений. Начиная с версии 4.3.0 введена поддержка JAVA версии 8, и отказ от JAVA 6. В дальнейшем планируется отказ от java7, поэтому рекомендуется использовать сервер приложений wildfly.

                                                                          # Процесс сборки на примере Eclipse IDE
                                                                          # Необходимое программное обеспечение для сборки
                                                                          В отличие от Среды разработки для сборки сервера можно использовать Eclipse IDE любой версии и редакции.

                                                                          установите плагин m2eclipse
                                                                          используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу: http://maven.apache.org/
                                                                          добавьте путь к Apache Maven директории bin в переменную окружения Path
                                                                          # Импорт проектов
                                                                          Импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server.

                                                                          Eclipse srv proj.png

                                                                          # Установка maven артефактов
                                                                          Выполните

                                                                          ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                                                                          ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                                                                          или другим способом установите артефакты в локальный репозиторий

                                                                          # Сборка
                                                                          Заведите конфигурацию запуска на основе maven как показано на рисунке

                                                                          Maven.build.configuration.png

                                                                          Запустите конфигурацию.

                                                                          Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\eclipse-workspace\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"

                                                                          # Сборка из командной строки
                                                                          используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу http://maven.apache.org/
                                                                          добавьте путь к Apache Maven директории bin в переменную окружения Path
                                                                          импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server
                                                                          выполните обновление зависимостей
                                                                          ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                                                                          ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                                                                          откройте командную строку
                                                                          перейдите в директорию ${wfe}/wfe-app/
                                                                          выполните команду для сборки
                                                                          mvn clean package -Dmaven.test.skip=true
                                                                          Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"


                                                                          Для установки артефактов в локальный репозиторий используйте команду

                                                                          mvn clean install -Dmaven.test.skip=true
                                                                          # Использование ear на сервере приложений
                                                                          cкачайте текущую версию RunaWFE в виде файл-архива исполняемых java файлов runawfe-wildfly-java8-*.zip (на базе wildfly, java8)
                                                                          распакуйте архив
                                                                          обновите runawfe.ear на версию полученную в результате сборки
                                                                          # Расширение функциональности
                                                                          # Точки расширения системы
                                                                          Обработчики позволяют исполнить код в процессах (элементы "Обработчик", "Задача сценария") и ботах
                                                                          Форматы переменных определяют тип переменных и правила преобразования значений к текстовому представлению и обратно
                                                                          Организационные функции используются при назначении ролей и в правилах замещения для определения заместителя
                                                                          Критерии замещения используются в подсистеме замещения для определения заместителя при построении списка заданий
                                                                          Валидаторы обеспечивают проверку переменных при выполнении задания (в т.ч. введенные значения форм)
                                                                          Freemarker теги форм генерируют html код для отображения на форме
                                                                          Ajax команды предоставляют доступ к функциональности сервера из JavaScript
                                                                          # Процесс разработки расширений
                                                                          Создайте новый java-проект и подключите необходимые зависимости (wfe-core, wfe-service).

                                                                          Реализуйте в нем требуемые расширения и соберите его в виде jar-файла.

                                                                          Замечание. Использование maven облегчит процесс управления зависимостями.

                                                                          Разместить собранный jar на сервере вы можете:

                                                                          положив его в runawfe.ear!/lib
                                                                          положив его в директорию deploy (только для jboss4)
                                                                          положив его в ${jboss.server.base.dir}/wfe.custom (только для jboss7)
                                                                          положив его в ${jboss.server.base.dir}/${jboss.server.name}/wfe.custom (только для jboss4)
                                                                          # Обработчики
                                                                          Обработчик в процессе – компонент процесса (элементы "Обработчик", "Задача сценария"), использующийся для выполнения каких-либо действий при возникновении определенных событий (проход по определенному переходу в процессе, приход или уход управления из узла и т.п.).

                                                                          Обработчик должен реализовывать интерфейс ru.runa.wfe.extension.ActionHandler. Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов Spring контекста (например с помощью аннотации @Autowired).

                                                                          При написании нового обработчика рекомендуется наследовать его от абстрактного класса ru.runa.wfe.extension.handler.CommonHandler или ru.runa.wfe.extension.handler.CommonParamBasedHandler. В методе setConfiguration обработчик должен запомнить свои параметры (если обработчик их ожидает), а в методе execute происходит непосредственная обработка и выполнение требуемых действий.

                                                                          В случае, если при выполнении обработчика произошла ошибка, произойдет откат транзакции и состояние процесса будет возвращено к заданию, исполнение которого повлекло вызов обработчика. В интерфейсе обработчика для бота ru.runa.wfe.extension.TaskHandler предусмотрен метод onRollback для работы с не-транзакционными ресурсами.

                                                                          Эти обработчики удобно использовать для простых операций (например для отправки оповещений в виде SMS-сообщений если процесс попал в определенное состояние). Но у них есть несколько ограничений. Прежде всего у них нет соответствующего объекта контекста безопасности (security context). Это означает, что в них нельзя выполнять защищенные методы (запуск процессов, выполнение задач, создание пользователей и т.п.) Ошибочным решением в них будет блокирование выполнения процесса (например с Thread::Sleep(...)). Например, если в обработчике отправляется e-mail, а SMTP сервер недоступен, обработчику нельзя "задерживать" свое выполнение.

                                                                          Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                                                                          # Специфика обработчиков для ботов
                                                                          Бот - это сокращение от робот. В системе боты - это особый тип исполнителей. Система не отличает ботов от людей. У каждого бота есть свои права на вход в систему, он периодически просыпается, проверяет свой список задачи и выполняет обнаруженные там задачи.

                                                                          Каждая задача бота обрабатывается при помощи соответствующего обработчика. Чтобы написать новый обработчик нужно реализовать интерфейс ru.runa.wfe.extension.TaskHandler.

                                                                          Обратите внимание, что этот вид обработчиков выполняется в контексте безопасности (security context) пользователя-бота, и здесь может выполнятся любая операция (если у бота есть на это права).

                                                                          Обработчики задач ботов могут блокировать выполнение процесса.

                                                                          Например, обработчик задач, отправляющий e-mail может блокировать выполнение бизнес процесса до тех пор, пока обработчик не удостоверится, что SMTP сервер принял сообщение для последующей доставки.

                                                                          Обработчики задач вызываются периодически, когда боты проверяют свои списки задач.

                                                                          # Специфика обработчика для элемента ветвление
                                                                          Обработчик для Decision является java-классом, реализующим интерфейс ru.runa.wfe.extension.DecisionHandler. Интерфейс содержит один метод decide(ExecutionContext executionContext), который возвращает имя выбранного перехода (одного из выходящих из данного ветвления). Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов контекста спринга (например с помощью аннотации @Autowired).

                                                                          Обработчик принимает ExecutionContext в качестве входящего параметра и должен сделать выбор перехода исходя из значений переменных бизнес процесса и условий, указанных в конфигурации обработчика. Точно также как обработчики действия (action handler) обработчики выбора (decision handlers) не могут использовать защищенные (secured) методы, не могут обрабатывать ошибки и откладывать выбор перехода до лучших времен.

                                                                          По умолчанию используется ru.runa.wfe.extension.decision.GroovyDecisionHandler.

                                                                          # Использование ru.runa.wfe.extension.handler.CommonParamBasedHandler в качестве базового класса
                                                                          Этот класс инкапсулирует в себе парсинг XML конфигурации определенного формата. Его удобно использовать если обработчик имеет фиксированное число параметров. Пример конфигурации:

                                                                          <?xml version="1.0" encoding="UTF-8"?>
                                                                          <config>
                                                                           <input>
                                                                             <param name="typeName" variable="тип отсутствия" />
                                                                             <param name="employee" variable="сотрудник" />
                                                                             <param name="requester" variable="подавший заявку" />
                                                                             <param name="from" variable="дата с" />
                                                                             <param name="to" variable="дата по" />
                                                                             <param name="cause" variable="причина" />
                                                                             <param name="comment" variable="комментарий" />
                                                                             <param name="confirmation" variable="дата подтверждения" />
                                                                             <param name="firmCode" value="111" />
                                                                             <param name="firmPositionCode" variable="код должности" />
                                                                             <param name="firmDepartmentCode" variable="код подразделения" />
                                                                           </input>
                                                                           <output>
                                                                             <param name="uuid" variable="идентификатор объекта" />
                                                                           </output>
                                                                          </config>
                                                                          Использование обработчика Groovy
                                                                          См. соответствующий раздел в руководстве по работе с Groovy.

                                                                          # Как написать функцию над организационной структурой
                                                                          Функции над организационной структурой в системе применяются, например, при инициализации Ролей-Дорожек и в правилах замещения.

                                                                          Класс, соответствующий функции над организационной структурой, должен реализовывать интерфейс ru.runa.wfe.extension.OrgFunction.

                                                                          Интерфейс содержит один метод

                                                                          List<? extends Executor> getExecutors(Object... parameters)
                                                                          Этот метод должен возвращать список исполнителей.

                                                                          В бизнес-процессе обработчик функции над оргструктурой используются при определении Ролей-Дорожек: указывается внутри тега swimlane, в теле тега <assignment>.В качестве параметра class тега <assignment> указывается класс-обработчик для инициализации swimlane: ru.runa.wfe.extension.AssignmentHandler. Внутри тега <assignment> содержится конфигурация для этого класса, которая представляет собой имя класса-наследника интерфейса OrgFunction и список параметров в скобках. В качестве параметра может выступать конкретное значение или имя переменной бизнес процесса в фигурных скобках, перед которым стоит значок $

                                                                          Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                                                                          Если есть планы по использованию функции в подсистеме замещений - её можно зарегистрировать в substitutions.xml.

                                                                          # Как написать критерий замещения
                                                                          Критерии замещения в системе применяются в правилах замещения. Класс, соответствующий критерию замещения, должен наследоваться от ru.runa.wfe.ss.SubstitutionCriteria.

                                                                          Для создания на основе него конечных критериев замещения с конфигурациями - его нужно зарегистрировать в substitution.criterias.xml.

                                                                          Как реализовать класс-формат для переменных бизнес-процесса
                                                                          См. соответствующий раздел в руководстве по работе с переменными.

                                                                          # Как реализовать валидатор переменных
                                                                          Классы, расширяющие абстрактный класс ru.runa.wfe.validation.FieldValidator, в системе применяются для проверки переменных при выполнении задания или старте процесса.

                                                                          Пример:

                                                                          public class OvertimeWorkRequestTimeCheck extends FieldValidator {
                                                                             @Override
                                                                             public void validate() {
                                                                                 Date date = (Date) getFieldValue();
                                                                                 if (date == null) {
                                                                                     return;
                                                                                 }
                                                                                 boolean testMode = getVariableProvider().getValueNotNull(boolean.class, "тестовый режим");
                                                                                 if (testMode) {
                                                                                     return;
                                                                                 }
                                                                                 Calendar calendar = CalendarUtil.dateToCalendar(date);
                                                                                 if (calendar.before(Calendar.getInstance())) {
                                                                                     addError("Заявка не может быть оформлена задним числом");
                                                                                     return;
                                                                                 }
                                                                                 CalendarUtil.setTimeFromCalendar(calendar, DemoProperties.getOvertimeWorkRequestMaximumStartTime());
                                                                                 Utils.adjustCalendarForHolidaysInOvertimwWork(calendar);
                                                                                 if (calendar.before(Calendar.getInstance())) {
                                                                                     addError("Заявка на этот день не может быть подана, время подачи истекло " + CalendarUtil.formatDateTime(calendar));
                                                                                 }
                                                                             }
                                                                          }

                                                                          Связь между Средой разработки и сервером осуществляется по имени валидатора, регистрация требуется на стороне сервера в файле validators.xml, а в среде разработки - в plugin.xml.

                                                                          # Как реализовать FreeMarker тег для формы
                                                                          FreemarkerForms#Components

                                                                          # Как реализовать Ajax команду
                                                                          Классы, расширяющие абстрактный класс ru.runa.wfe.commons.web.JsonAjaxCommand, (или реализующие ru.runa.wfe.commons.web.AjaxCommand) в системе применяются для доступа к функциональности сервера из JavaScript, например при отображении форм задания.

                                                                          Регистрация команды происходит любым из двух способов:

                                                                          в файле ajax.commands.xml, ей присваивается определенное имя
                                                                          в контексте приложения, именем является id spring-бина
                                                                          Затем по этому имени её можно выполнить используя JavaScript.

                                                                          Пример команды

                                                                          public class GetOrganizationNamesCommand extends JsonAjaxCommand {
                                                                             @Autowired
                                                                             private OrganizationDAO organizationDAO;
                                                                             @Override
                                                                             protected JSONAware execute(User user, HttpServletRequest request) throws Exception {
                                                                                 String term = request.getParameter("term");
                                                                                 if (term == null) {
                                                                                     term = "";
                                                                                 }
                                                                                 List<Organization> organizations = organizationDAO.getAll();
                                                                                 JSONArray array = new JSONArray();
                                                                                 for (Organization organization : organizations) {
                                                                                     if (organization.getName().startsWith(term)) {
                                                                                         array.add(organization.getName());
                                                                                     }
                                                                                 }
                                                                                 return array;
                                                                             }
                                                                          }
                                                                          Регистрация в wfe.custom.ajax.commands.xml

                                                                          <?xml version="1.0" encoding="UTF-8" ?>
                                                                          <configuration xmlns="http://runa.ru/xml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://runa.ru/xml">
                                                                           <command name="getOrganizationNames" class="ru.runa.rkdemo.web.ajax.GetOrganizationNamesCommand" />
                                                                          </configuration>
                                                                          Её использование со скрипта формы (autocomplete input)

                                                                          $(document).ready(function() {
                                                                           $('#editLinkedLists').on("onRowAdded", function(event, rowIndex) {
                                                                            $("input[name='названия организаций["+rowIndex+"]']").autocomplete( {
                                                                             delay: 300,
                                                                             minLength: 0,
                                                                             source: "/wfe/ajaxcmd?command=getOrganizationNames"
                                                                            });
                                                                            $("input[name='названия организаций["+rowIndex+"]']").focus(function() {
                                                                             $(this).autocomplete("search", $(this).val());
                                                                            });
                                                                           });
                                                                          });Введение
                                                                             # Основные компоненты и используемые технологии
                                                                             Для WF–системы была выбрана следующая общая архитектура (в целом соответствует архитектуре, предлагаемой коалицией WfMC):

                                                                             Компоненты системы:

                                                                             Ядро системы
                                                                             Содержит набор определений бизнес-процессов
                                                                             Содержит набор выполняющихся экземпляров бизнес–процессов
                                                                             Компонент, "назначающий" исполнителей для действий
                                                                             Клиент
                                                                             Список заданий (набор графических форм, содержит очереди поступивших работ, сортировки и фильтры)
                                                                             Проигрыватель форм (отображает формы, разработанные в Среде разработки)
                                                                             Административный интерфейс
                                                                             Показывает состояния процессов, позволяет фильтровать и останавливать процессы
                                                                             Позволяет загружать-выгружать процессы
                                                                             Позволяет заводить-удалять пользователей
                                                                             Позволяет задавать различные права
                                                                             Редактор назначения заместителей
                                                                             Среда разработки
                                                                             Конструктор графических форм
                                                                             Бот станции, содержащие ботов (Боты - приложения специального вида, которые также как и обычные пользователи могут выполнять задания)
                                                                             Подсистема управления правами доступа (авторизация и аутентификация)
                                                                             # Платформа программирования и используемые программные средства
                                                                             В качестве платформы программирования используется J2EE.

                                                                             Используемые программные средства:

                                                                             Сервер приложений - JBOSS (http://www.jboss.org).
                                                                             Среда разработки - любая, например Eclipse от IBM (http://www.eclipse.org).
                                                                             Система контроля версий - git
                                                                             Сборщик приложений – maven.
                                                                             Сервер баз данных – поддерживаются сервера БД:
                                                                             MS SQL Server (http://www.microsoft.com/sql/evaluation/default.mspx)
                                                                             HSQL (http://hsqldb.org)
                                                                             Oracle (http://www.oracle.com)
                                                                             PostgreSQL (http://postgresql.com)
                                                                             Операционная система — поддерживаются следующие ОС:
                                                                             Windows (Server 2000-2008, XP, Vista, 7)
                                                                             ALTLinux
                                                                             Mandriva Linux
                                                                             Fedora
                                                                             Debian/Ubuntu
                                                                             # Описание проектов
                                                                             Название проекта	Обязателен при сборке	Обязателен при работе	Зависимости	Описание
                                                                             wfe-alfresco	нет	нет	runawfe-app	Интеграция с Alfresco
                                                                             wfe-app	да	да	wfe-ear, wfe-cactus-it	Проект для организации сборки maven
                                                                             wfe-appserver	нет	нет	 ?	Не используется
                                                                             wfe-bots	да	да	wfe-service	Подсистема ботов
                                                                             wfe-cactus-it	да	нет	wfe-service	Интеграционные тесты
                                                                             wfe-core	да	да	-	Основные компоненты системы
                                                                             wfe-ear	да	да	wfe-service, wfe-bots, wfe-office, wfe-web	Проект для сборки runawfe.ear
                                                                             wfe-office	да	нет	wfe-core	Обработчики для работы с Word, Excel
                                                                             wfe-service	да	да	wfe-core	Сервисы (EJB + WebServices), представляющие собой публичное API приложения
                                                                             wfe-web	да	да	wfe-bots	Визуальная часть приложения
                                                                             wfe-webservice-client	нет	нет	 ?	Авто-генерации клиентской библиотеки на основе WSDL серверных сервисов. В нем же есть примеры использования веб-служб из Java клиента.
                                                                             # Описание слоев архитектуры системы
                                                                             Каждый компонент состоит из нескольких уровней (слоев).

                                                                             Список слоев:

                                                                             delegate
                                                                             service
                                                                             logic
                                                                             DAO
                                                                             hibernate
                                                                             # Слой Delegate
                                                                             Delegate-классы, реализующие сервисные интерфейсы представляют собой pattern проектирования BusinessDelegate, упрощающий доступ к серверному API системы. Клиентское приложение взаимодействует с системой только через Delegate-классы. Delegate-классы получаются посредством запроса фабрики Delegates, которая в зависимости от конфигурации возвращает нужную реализацию. Классы Delegate являются частью клиентского API.

                                                                             Список основных Delegate-классов:

                                                                             AuthenticationServiceDelegate – содержит методы для аутентификации пользователей в системе (с использованием логина/пароля, Kerberos и т.п.)
                                                                             AuthorizationServiceDelegate — содержит методы для работы с полномочиями пользователей (назначение полномочий, проверка на допустимость операции для пользователя и т.п.)
                                                                             BotServiceDelegate — содержит методы для работы с бот станциями и ботами
                                                                             ExecutorServiceDelegate — содержит методы для работы с исполнителями. Позволяет создавать/удалять/изменять исполнителей а так же включать их в группы
                                                                             ProfileServiceDelegate — содержит методы для работы с профайлам пользователей
                                                                             SubstitutionServiceDelegate — содержит методы для управления правилами замещения
                                                                             SystemServiceDelegate — содержит методы для входа/выхода пользователя в систему
                                                                             DefinitionServiceDelegate — содержит методы для работы с определениями процессов
                                                                             ExecutionServiceDelegate — содержит методы для работы с исполняемыми экземплярами процессов
                                                                             Все существующие в данный момент Delegate-классы реализуют требуемую функциональность при помощи технологии EJB.

                                                                             # Слой Service
                                                                             Слой service – это серверное API доступа к системе. Реализации Delegate интерфейсов обращаются именно к этому слою. Каждый Delegate работает с одним соответствующим классом Service. В настоящее время все разработанные service классы и интерфейсы ориентированы на EJB-технологию, однако в будущем возможны и другие реализации. Реализации классов Service являются Stateless Session Bean EJB, которые декларативно поддерживают транзакционность вызовов и запрашивают соответствующие классы из слоя Logic.

                                                                             Таким образом, классы Delegate – Service - Logic образуют как бы «транспорт» между клиентом и сервером.

                                                                             # Слой Logic
                                                                             Слой Logic – это реализация бизнес логики работы системы. Слой работает с классами слоя DAO для доступа к постоянному хранилищу.

                                                                             # Слой DAO
                                                                             Слой DAO – это интерфейсы и классы, обеспечивающие доступ к данным, находящимся в постоянном хранилище (базе данных). В настоящее время все DAO-классы системы реализованы при помощи ORM-средства Hibernate.

                                                                             # Использование Hibernate
                                                                             Hibernate – ORM (Object/Relational Mapping) средство. Отображает объектную архитектуру на реляционную структуру данных. Допускает настройку (не меняя разработанного кода) на большинство существующих серверов реляционных баз данных.

                                                                             Поддерживает работу с распределенными транзакциями, автоматически создает таблицы для новых классов и т.д. Вся работа с данными внутри системы ведется только через Hibernate.

                                                                             Все компоненты, предоставляющие клиентское API построены с использованием описанных выше слоев. В целях оптимизации в некоторых компонентах применяется кеширование, которое может встречаться на уровне logic или DAO. Основная функциональность по управлению кешами находится в классах CachingLogic, CacheInterceptor и классах соответствующих кешей. Изменения в кешируемых объектах перехватываются и сообщаются посредством CachingLogic всем подписавшимся на изменения классам кешей. Транзакция, изменяющая кеш, считается закрытой по окончанию обработки ejb вызова.

                                                                             # Обновление базы данных
                                                                             см. описание системы патчей.

                                                                             # API
                                                                             Система представляет API для интеграции с другими системами:

                                                                             # Java API
                                                                             Реализация (снизу вверх): БД - Hibernate3 - EJB3

                                                                             Документацию можно смотреть в исходном коде (javadocs в *Service.java).

                                                                             # WebServices API
                                                                             Реализация (снизу вверх): БД - Hibernate3 - JAX-WS

                                                                             Документация: WebServicesDeveloperGuide

                                                                             # Scripting API
                                                                             Реализация (снизу вверх): БД - Hibernate3 - XML Script

                                                                             Документация: AdminScriptGuide

                                                                             # Процесс сборки из исходного кода
                                                                             Исходный код системы доступен в открытом репозитории на github.

                                                                             Сервер можно собирать как средствами maven используя командную строку, так и используя среду Eclipse IDE.

                                                                             В результате сборки будет сформирован runawfe.ear, который теоретически можно запустить на любом сервере приложений. Начиная с версии 4.3.0 введена поддержка JAVA версии 8, и отказ от JAVA 6. В дальнейшем планируется отказ от java7, поэтому рекомендуется использовать сервер приложений wildfly.

                                                                             # Процесс сборки на примере Eclipse IDE
                                                                             # Необходимое программное обеспечение для сборки
                                                                             В отличие от Среды разработки для сборки сервера можно использовать Eclipse IDE любой версии и редакции.

                                                                             установите плагин m2eclipse
                                                                             используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу: http://maven.apache.org/
                                                                             добавьте путь к Apache Maven директории bin в переменную окружения Path
                                                                             # Импорт проектов
                                                                             Импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server.

                                                                             Eclipse srv proj.png

                                                                             # Установка maven артефактов
                                                                             Выполните

                                                                             ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                                                                             ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                                                                             или другим способом установите артефакты в локальный репозиторий

                                                                             # Сборка
                                                                             Заведите конфигурацию запуска на основе maven как показано на рисунке

                                                                             Maven.build.configuration.png

                                                                             Запустите конфигурацию.

                                                                             Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\eclipse-workspace\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"

                                                                             # Сборка из командной строки
                                                                             используйте Apache Maven (>= 3.0.4), можно свободно загрузить по следующему адресу http://maven.apache.org/
                                                                             добавьте путь к Apache Maven директории bin в переменную окружения Path
                                                                             импортируйте проекты с помощью Git-клиента из репозитория https://github.com/processtech/runawfe-server
                                                                             выполните обновление зависимостей
                                                                             ${wfe}/wfe-app/repository/add_dependencies.bat (Windows)
                                                                             ${wfe}/wfe-app/repository/add_dependencies.sh (Linux)
                                                                             откройте командную строку
                                                                             перейдите в директорию ${wfe}/wfe-app/
                                                                             выполните команду для сборки
                                                                             mvn clean package -Dmaven.test.skip=true
                                                                             Сформированный runawfe.ear файл будет находиться в директории deployments проекта "wfe-ear", например "..\runawfe-server\wfe-ear\${jboss.home.dir}\standalone\deployments"


                                                                             Для установки артефактов в локальный репозиторий используйте команду

                                                                             mvn clean install -Dmaven.test.skip=true
                                                                             # Использование ear на сервере приложений
                                                                             cкачайте текущую версию RunaWFE в виде файл-архива исполняемых java файлов runawfe-wildfly-java8-*.zip (на базе wildfly, java8)
                                                                             распакуйте архив
                                                                             обновите runawfe.ear на версию полученную в результате сборки
                                                                             # Расширение функциональности
                                                                             # Точки расширения системы
                                                                             Обработчики позволяют исполнить код в процессах (элементы "Обработчик", "Задача сценария") и ботах
                                                                             Форматы переменных определяют тип переменных и правила преобразования значений к текстовому представлению и обратно
                                                                             Организационные функции используются при назначении ролей и в правилах замещения для определения заместителя
                                                                             Критерии замещения используются в подсистеме замещения для определения заместителя при построении списка заданий
                                                                             Валидаторы обеспечивают проверку переменных при выполнении задания (в т.ч. введенные значения форм)
                                                                             Freemarker теги форм генерируют html код для отображения на форме
                                                                             Ajax команды предоставляют доступ к функциональности сервера из JavaScript
                                                                             # Процесс разработки расширений
                                                                             Создайте новый java-проект и подключите необходимые зависимости (wfe-core, wfe-service).

                                                                             Реализуйте в нем требуемые расширения и соберите его в виде jar-файла.

                                                                             Замечание. Использование maven облегчит процесс управления зависимостями.

                                                                             Разместить собранный jar на сервере вы можете:

                                                                             положив его в runawfe.ear!/lib
                                                                             положив его в директорию deploy (только для jboss4)
                                                                             положив его в ${jboss.server.base.dir}/wfe.custom (только для jboss7)
                                                                             положив его в ${jboss.server.base.dir}/${jboss.server.name}/wfe.custom (только для jboss4)
                                                                             # Обработчики
                                                                             Обработчик в процессе – компонент процесса (элементы "Обработчик", "Задача сценария"), использующийся для выполнения каких-либо действий при возникновении определенных событий (проход по определенному переходу в процессе, приход или уход управления из узла и т.п.).

                                                                             Обработчик должен реализовывать интерфейс ru.runa.wfe.extension.ActionHandler. Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов Spring контекста (например с помощью аннотации @Autowired).

                                                                             При написании нового обработчика рекомендуется наследовать его от абстрактного класса ru.runa.wfe.extension.handler.CommonHandler или ru.runa.wfe.extension.handler.CommonParamBasedHandler. В методе setConfiguration обработчик должен запомнить свои параметры (если обработчик их ожидает), а в методе execute происходит непосредственная обработка и выполнение требуемых действий.

                                                                             В случае, если при выполнении обработчика произошла ошибка, произойдет откат транзакции и состояние процесса будет возвращено к заданию, исполнение которого повлекло вызов обработчика. В интерфейсе обработчика для бота ru.runa.wfe.extension.TaskHandler предусмотрен метод onRollback для работы с не-транзакционными ресурсами.

                                                                             Эти обработчики удобно использовать для простых операций (например для отправки оповещений в виде SMS-сообщений если процесс попал в определенное состояние). Но у них есть несколько ограничений. Прежде всего у них нет соответствующего объекта контекста безопасности (security context). Это означает, что в них нельзя выполнять защищенные методы (запуск процессов, выполнение задач, создание пользователей и т.п.) Ошибочным решением в них будет блокирование выполнения процесса (например с Thread::Sleep(...)). Например, если в обработчике отправляется e-mail, а SMTP сервер недоступен, обработчику нельзя "задерживать" свое выполнение.

                                                                             Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                                                                             # Специфика обработчиков для ботов
                                                                             Бот - это сокращение от робот. В системе боты - это особый тип исполнителей. Система не отличает ботов от людей. У каждого бота есть свои права на вход в систему, он периодически просыпается, проверяет свой список задачи и выполняет обнаруженные там задачи.

                                                                             Каждая задача бота обрабатывается при помощи соответствующего обработчика. Чтобы написать новый обработчик нужно реализовать интерфейс ru.runa.wfe.extension.TaskHandler.

                                                                             Обратите внимание, что этот вид обработчиков выполняется в контексте безопасности (security context) пользователя-бота, и здесь может выполнятся любая операция (если у бота есть на это права).

                                                                             Обработчики задач ботов могут блокировать выполнение процесса.

                                                                             Например, обработчик задач, отправляющий e-mail может блокировать выполнение бизнес процесса до тех пор, пока обработчик не удостоверится, что SMTP сервер принял сообщение для последующей доставки.

                                                                             Обработчики задач вызываются периодически, когда боты проверяют свои списки задач.

                                                                             # Специфика обработчика для элемента ветвление
                                                                             Обработчик для Decision является java-классом, реализующим интерфейс ru.runa.wfe.extension.DecisionHandler. Интерфейс содержит один метод decide(ExecutionContext executionContext), который возвращает имя выбранного перехода (одного из выходящих из данного ветвления). Создание экземпляра обработчика в системе происходит с использованием конструктора по умолчанию и передачей параметров обработчику вызовом метода setConfiguration(String). В классах-обработчиках возможно использование бинов контекста спринга (например с помощью аннотации @Autowired).

                                                                             Обработчик принимает ExecutionContext в качестве входящего параметра и должен сделать выбор перехода исходя из значений переменных бизнес процесса и условий, указанных в конфигурации обработчика. Точно также как обработчики действия (action handler) обработчики выбора (decision handlers) не могут использовать защищенные (secured) методы, не могут обрабатывать ошибки и откладывать выбор перехода до лучших времен.

                                                                             По умолчанию используется ru.runa.wfe.extension.decision.GroovyDecisionHandler.

                                                                             # Использование ru.runa.wfe.extension.handler.CommonParamBasedHandler в качестве базового класса
                                                                             Этот класс инкапсулирует в себе парсинг XML конфигурации определенного формата. Его удобно использовать если обработчик имеет фиксированное число параметров. Пример конфигурации:

                                                                             <?xml version="1.0" encoding="UTF-8"?>
                                                                             <config>
                                                                              <input>
                                                                                <param name="typeName" variable="тип отсутствия" />
                                                                                <param name="employee" variable="сотрудник" />
                                                                                <param name="requester" variable="подавший заявку" />
                                                                                <param name="from" variable="дата с" />
                                                                                <param name="to" variable="дата по" />
                                                                                <param name="cause" variable="причина" />
                                                                                <param name="comment" variable="комментарий" />
                                                                                <param name="confirmation" variable="дата подтверждения" />
                                                                                <param name="firmCode" value="111" />
                                                                                <param name="firmPositionCode" variable="код должности" />
                                                                                <param name="firmDepartmentCode" variable="код подразделения" />
                                                                              </input>
                                                                              <output>
                                                                                <param name="uuid" variable="идентификатор объекта" />
                                                                              </output>
                                                                             </config>
                                                                             Использование обработчика Groovy
                                                                             См. соответствующий раздел в руководстве по работе с Groovy.

                                                                             # Как написать функцию над организационной структурой
                                                                             Функции над организационной структурой в системе применяются, например, при инициализации Ролей-Дорожек и в правилах замещения.

                                                                             Класс, соответствующий функции над организационной структурой, должен реализовывать интерфейс ru.runa.wfe.extension.OrgFunction.

                                                                             Интерфейс содержит один метод

                                                                             List<? extends Executor> getExecutors(Object... parameters)
                                                                             Этот метод должен возвращать список исполнителей.

                                                                             В бизнес-процессе обработчик функции над оргструктурой используются при определении Ролей-Дорожек: указывается внутри тега swimlane, в теле тега <assignment>.В качестве параметра class тега <assignment> указывается класс-обработчик для инициализации swimlane: ru.runa.wfe.extension.AssignmentHandler. Внутри тега <assignment> содержится конфигурация для этого класса, которая представляет собой имя класса-наследника интерфейса OrgFunction и список параметров в скобках. В качестве параметра может выступать конкретное значение или имя переменной бизнес процесса в фигурных скобках, перед которым стоит значок $

                                                                             Связь между Средой разработки и сервером осуществляется по полному имени класса, поэтому регистрация не требуется.

                                                                             Если есть планы по использованию функции в подсистеме замещений - её можно зарегистрировать в substitutions.xml.

                                                                             # Как написать критерий замещения
                                                                             Критерии замещения в системе применяются в правилах замещения. Класс, соответствующий критерию замещения, должен наследоваться от ru.runa.wfe.ss.SubstitutionCriteria.

                                                                             Для создания на основе него конечных критериев замещения с конфигурациями - его нужно зарегистрировать в substitution.criterias.xml.

                                                                             Как реализовать класс-формат для переменных бизнес-процесса
                                                                             См. соответствующий раздел в руководстве по работе с переменными.

                                                                             # Как реализовать валидатор переменных
                                                                             Классы, расширяющие абстрактный класс ru.runa.wfe.validation.FieldValidator, в системе применяются для проверки переменных при выполнении задания или старте процесса.

                                                                             Пример:

                                                                             public class OvertimeWorkRequestTimeCheck extends FieldValidator {
                                                                                @Override
                                                                                public void validate() {
                                                                                    Date date = (Date) getFieldValue();
                                                                                    if (date == null) {
                                                                                        return;
                                                                                    }
                                                                                    boolean testMode = getVariableProvider().getValueNotNull(boolean.class, "тестовый режим");
                                                                                    if (testMode) {
                                                                                        return;
                                                                                    }
                                                                                    Calendar calendar = CalendarUtil.dateToCalendar(date);
                                                                                    if (calendar.before(Calendar.getInstance())) {
                                                                                        addError("Заявка не может быть оформлена задним числом");
                                                                                        return;
                                                                                    }
                                                                                    CalendarUtil.setTimeFromCalendar(calendar, DemoProperties.getOvertimeWorkRequestMaximumStartTime());
                                                                                    Utils.adjustCalendarForHolidaysInOvertimwWork(calendar);
                                                                                    if (calendar.before(Calendar.getInstance())) {
                                                                                        addError("Заявка на этот день не может быть подана, время подачи истекло " + CalendarUtil.formatDateTime(calendar));
                                                                                    }
                                                                                }
                                                                             }

                                                                             Связь между Средой разработки и сервером осуществляется по имени валидатора, регистрация требуется на стороне сервера в файле validators.xml, а в среде разработки - в plugin.xml.

      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}v
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      }{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      }{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      }{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      }{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      }{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      }{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      }{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      }{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      }{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      }{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      }{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      }{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      }{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      }{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      }{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      }{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      }{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      }{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      }{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      }{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      }{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      }{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      }{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      }{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      }{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      }{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      }{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      }{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      }{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      }{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      }{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      }{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
      {}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}                                                                       # Как реализовать FreeMarker тег для формы
                                                                             FreemarkerForms#Components

                                                                             # Как реализовать Ajax команду
                                                                             Классы, расширяющие абстрактный класс ru.runa.wfe.commons.web.JsonAjaxCommand, (или реализующие ru.runa.wfe.commons.web.AjaxCommand) в системе применяются для доступа к функциональности сервера из JavaScript, например при отображении форм задания.

                                                                             Регистрация команды происходит любым из двух способов:

                                                                             в файле ajax.commands.xml, ей присваивается определенное имя
                                                                             в контексте приложения, именем является id spring-бина
                                                                             Затем по этому имени её можно выполнить используя JavaScript.

                                                                             Пример команды

                                                                             public class GetOrganizationNamesCommand extends JsonAjaxCommand {
                                                                                @Autowired
                                                                                private OrganizationDAO organizationDAO;
                                                                                @Override
                                                                                protected JSONAware execute(User user, HttpServletRequest request) throws Exception {
                                                                                    String term = request.getParameter("term");
                                                                                    if (term == null) {
                                                                                        term = "";
                                                                                    }
                                                                                    List<Organization> organizations = organizationDAO.getAll();
                                                                                    JSONArray array = new JSONArray();
                                                                                    for (Organization organization : organizations) {
                                                                                        if (organization.getName().startsWith(term)) {
                                                                                            array.add(organization.getName());
                                                                                        }
                                                                                    }
                                                                                    return array;
                                                                                }
                                                                             }
                                                                             Регистрация в wfe.custom.ajax.commands.xml

                                     sddddddddddddddddddddddddddddddddddddddd                                        <?xml version="1.0" encoding="UTF-8" ?>
                                                                             <configuration xmlns="http://runa.ru/xml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://runa.ru/xml">
                                                                              <command name="getOrganizationNames" class="ru.runa.rkdemo.web.ajax.GetOrganizationNamesCommand" />
                                                                             </configuration>
                                                                             Её использование со скрипта формы (autocomplete input)

                                                                             $(document).ready(function() {
                                                                              $('#editLinkedLists').on("onRowAdded", function(event, rowIndex) {
                                                                               $("input[name='названия организаций["+rowIndex+"]']").autocomplete( {
                                                                                delay: 300,
                                                                                minLength: 0,
                                                                                source: "/wfe/ajaxcmd?command=getOrganizationNames"
                                                                               });
                                                                               $("input[name='названия организаций["+rowIndex+"]']").focus(function() {
                                                                                $(this).autocomplete("search", $(this).val());
                                                                               });
                                                                              });
                                                                             });ространство: 850 МБ свободного дискового пространства
             	OpenSolaris 2009.06 (редакция для платформ x86/x64):
             	Процессор: AMD Opteron серии 1200, 2,8 ГГц
             	Память: 2 ГБ
             	Дисковое пространство: 650 МБ свободного дискового пространства
             	Macintosh OS X 10.5 Intel:
             	Процессор: Dual-Core Intel
             	Память: 2 ГБ
             	Дисковое пространство: 850 МБ свободного дискового пространства
             	Macintosh OS X 10.5 PPC:
             	Процессор: PowerPC G5
             	Память: 2 ГБ
             	Дисковое пространство: 850 МБ свободного дискового
             Среда IDE NetBeans также работает на следующих платформах:
             	Java Desktop System 2
             	Microsoft Windows 2000 Professional SP4
             	Mac OS X 10.4.11 Intel/Power PC
             	Другие различные дистрибутивы Linux, например, Ubuntu 8.x, Red Hat Enterprise Linux и прочие.

             4.Перечень выполненных проектных решений
             	Создание графического интерфейса посредством среды IDE NET Beans
             	Реализация возможности задать пользователю ключевые параметры для расчёта баллистической траектории посредством элемента библиотеки swing «jTextField»
             	Задание начала работы программного блока вычислений посредством jButton и её события «jButton1MouseClicked»
             	Реализация дополнительного оформления формы для пользователя посредством элемента библиотеки swing «jLabel»
             	Вывод результатов расчёта и их описаний посредством элемента библиотеки swing «jLabel»
             	Вывод баллистической таблицы по результатам введённых параметров элемента библиотеки swing «jTable»
             	Предотвращение возможных сбоев в работе программы посредством обработки исключительных ситуаций, доступных в языке ООП Java
             	Упрощение работы с кодом и оптимизация его эффективности посредством внедрения конструктора класса Class1(double v, double l, double n, double x, double y)
             Заключение
             Реализация проекта по созданию программы для расчёта баллистической траектории потребовала изучения баллистики в целом, а также физических законов. После изучения данного вопроса и сопоставления задачи с техническими ресурсами, которыми можно располагать для реализации, был получен вывод, что для общего расчёта баллистической траектории полёта снаряда достаточно общих законов кинематики и получения следующих параметров от пользователя: модуль начальной скорости, угол вектора начальной скорости к горизонту, шаг измерения аргумента времени, начальные координаты снаряда. Было необходимо найти язык программирования и среду, которые бы легко интегрировались в любое ПО и не требовали высокой производительности ЭВМ. Для реализации проекта был выбран язык ООП Java и среда IDE NET Beans, которая позволила эффективно реализовать графическую оболочку программы.
             В математической модели были просчитаны все шаги вычислений, а также учтены диапазоны определения параметров, вводимых пользователем. В дальнейшем в коде эти параметры проверялись и не допускали обработки значений, которые могли выдать некорректный результат или стать причиной сбоя программы. Главными инструментами для проверки корректности параметров стали «ветвление» и «проверка исключительных ситуаций», которые доступны для языка ООП Java.
             Для удобства обработки кода и простоты его доработки в будущем были применены такие особенности ООП как классы и конструкторы. Подавляющее большинство классов имеют связь между собой типа «композиция». Для графического интерфейса подключались классы напрямую из библиотеки swing. Посредством таких подключений к библиотекам Java программа не занимает большой объём памяти и не содержит крайне длинного кода, что оптимизирует в свою очередь работу программы в целом.
             Помимо расчёта и вывода на экран баллистической таблицы, было принято решение определить и вывести на экранную форму такие ключевые показатели баллистического полёта снаряда как: время движение вверх и вниз по проекции на вертикаль, общее время полёта, максимальная высота подъёма снаряда от его начального положения в пространстве, расстояние по горизонтали пройденное снарядом за весь полёт. Их формул подсчёта, перечисленных в теоретической части, и результатов, которые были рассчитаны готовой программой, был сделан ряд выводов:
             	Пройденное расстояние по горизонтали за время полёта не зависит от начальной координаты снаряда на абсциссе.
             	Время полёта вверх по ординате не зависит он координат начального положения снаряда.
             	Время полёта вниз по ординате возрастает с увеличением значения начальной координаты снаряда по ординате
             	Максимальное пройденное расстояние снарядом по абсциссе достигается при угле равном 45 градусов, если брать остальные параметры за константу.
             	Чем больше модуль начальной скорости, тем больше дальность полёта по абсциссе и максимальная высота подъёма.
             	Чем ближе угол начальной скорости к 90 градусам, тем выше будут показатели времени движения вверх и вниз по ординате, общее время полёта, максимальная высота подъёма.
             	Чем меньше угол начальной скорости снаряда, тем меньшую максимальную высоту он наберёт.
             	Если установить угол начальной скорости к горизонту в 90 градусов, то достигаются максимальные показатели времени полёта и высота, но расстояние, пройдённое по абсциссе, будет равно 0, а снаряд приземлится или пройдёт через точку начала движения.
             Из вышеперечисленного вывода заключим, что для поражения дальней цели оптимально выбирать угол в районе 45 градусов. Если же мы хотим, чтобы снаряд поразил цель на большой высоте или перелетел высокое препятствие, то необходимо устанавливать угол близкий к 90 градусам. Чтобы снаряд не был сбит с траектории воздушными объектами, необходимо брать угол от 0 до 45 градусов. Опасно запускать снаряд под углом 90 градусов к горизонту.
             Графический интерфейс для пользователя был реализован максимально просто относительно эксплуатации. На форме содержится 1 кнопка и 5 текстовых полей, если рассматривать элементы, на которые может влиять пользователь. Все текстовые поля подписаны, как и значения в таблице, а также развёрнуто указано: какие ключевые расчёты выводит программа. Всё перечисленное позволяет воспользоваться данной программой, даже человеку, которые имеет поверхностные знания в баллистике и физике в целом. Следовательно, за счёт своего высокого функционала расчёта для начинающих пользователей и простого интерфейса, можно сделать вывод, что данный продукт рассчитан на интегрирование в массы, но не подходит для специализированных научных объектов. Иными словами, данный продукт рассчитан на любителей, а также может использоваться в обучающих целях на ранних этапах изучения баллистики и раздела физики-«кинематика».
             При необходимой доработке готового кода, можно создать расширенный функционал расчётов, а также увеличить число задаваемых пользователем параметров, что позволит создать версию программы для специализированных научных объектов.

























             Список основных источников и литературы
             	http://handguns.g00net.org/ballistic/glava42.htm
             	https://cyberleninka.ru/article/n/raschety-traektorii-poleta-artilleriyskogo-snaryada
             	https://nauka.club/fizika/ballisticheskoe-dvizhenie.html
             	Дмитриевский А.А., Лысенко Л.Н. «Внешняя Баллистика» // М.: Машиностроение, 2009. 126 с.
             	https://otherreferats.allbest.ru/programming/00987500_0.html
             	https://yandex.ru/turbo?text=https%3A%2F%2Fru.hexlet.io%2Fblog%2Fposts%2Fyazyk-programmirovaniya-java-osobennosti-populyarnost-situatsiya-na-rynke-truda
             	https://hightech.in.ua/content/art-netbeans-ide
             	https://foxford.ru/wiki/fizika/kinematika






















             Приложение
             1.Листинг
             import static java.lang.Math.*;
             import javax.swing.JOptionPane;
             import javax.swing.JTextField;
             import javax.swing.table.DefaultTableModel;
             public class Frame extends javax.swing.JFrame {

                 /**
                  * Creates new form Frame
                  */
                 public class Class1 {
                 Class1(double v, double l, double n, double x, double y){

             double T, t1, t2, g, H, t, S;
             int m=0;

             g=9.8;
             t1=sin(l)*v/g;
             H=sin(l)*v*t1-g*pow(t1,2)/2;
             t2=sqrt(2*(H+y)/g);
             T=t1+t2;
             if (T<=n) {JOptionPane.showMessageDialog (null,"Недопустимое начение!","Ошибка",JOptionPane.ERROR_MESSAGE);}
             while (T>0) {
             T-=n;
             m+=1;
             }
             T=t1+t2;

             t=0.0;
             DefaultTableModel model = new DefaultTableModel();
             Double[][] XY = new Double[m][3];
             for(int i=0; i<m; i++){
                 for( int j=0; j<3; j++) XY[i][j]=0.0;
             }
             int i=0; int j=0;
             model.addColumn("Время t(c)");
             model.addColumn("X(t)");
             model.addColumn("Y(t)");
             while(t<T){
                 XY[i][j]=t;
                 XY[i][j+1]=cos(l)*v*t+x;
               XY[i][j+2]=abs(sin(l)*t*v-g*pow(t,2)/2+y);
               t+=n;
               XY[i][j] = round(XY[i][j]*1000.0) / 1000.0;

               XY[i][j+1] = round(XY[i][j+1]*1000.0) / 1000.0;
               XY[i][j+2] = round(XY[i][j+2]*1000.0) / 1000.0;
               model.addRow(XY[i]);
               i++;
              }
             S=T*cos(l)*v;
             T = round(T*1000.0) / 1000.0;
             XY[1][0]=T;
             XY[1][1]=cos(l)*v*T+x;
             XY[1][2]=0.0;
             XY[1][1] = round(XY[1][1]*1000.0) / 1000.0;
             model.addRow(XY[1]);
             jTable1.setModel(model);
             t1=round(t1*1000.0) / 1000.0;
             t2=round(t2*1000.0) / 1000.0;
             H=round(H*1000.0) / 1000.0;
             S=round(S*1000.0) / 1000.0;

                     // TODO add your handling code here:
                jLabel4.setText("максимальная высота H="+String.valueOf(H)+"м");
                jLabel5.setText("время движения вверх t1="+String.valueOf(t1)+"с");
                jLabel6.setText("Время движения вниз t2="+String.valueOf(t2)+"с");
                jLabel7.setText("Общее время полёта T="+String.valueOf(T)+"с");
                jLabel8.setText("Результаты расчётов:");
                jLabel11.setText("Дальность полёта S="+S+"м");

             }

             }

                 public Frame() {
                     initComponents();
                     setLocationRelativeTo (null);
                 }

                 /**
                  * This method is called from within the constructor to initialize the form.
                  * WARNING: Do NOT modify this code. The content of this method is always
                  * regenerated by the Form Editor.
                  */
                 @SuppressWarnings("unchecked")
                 // <editor-fold defaultstate="collapsed" desc="Generated Code">
                 private void initComponents() {

                     jScrollPane1 = new javax.swing.JScrollPane();
                     jTable1 = new javax.swing.JTable();
                     jTextField1 = new JTextField();
                     jTextField2 = new JTextField();
                     jButton1 = new javax.swing.JButton();
                     jTextField3 = new JTextField();
                     jLabel1 = new javax.swing.JLabel();
                     jLabel2 = new javax.swing.JLabel();
                     jLabel3 = new javax.swing.JLabel();
                     jLabel4 = new javax.swing.JLabel();
                     jLabel5 = new javax.swing.JLabel();
                     jLabel6 = new javax.swing.JLabel();
                     jLabel7 = new javax.swing.JLabel();
                     jLabel8 = new javax.swing.JLabel();
                     jTextField4 = new JTextField();
                     jTextField5 = new JTextField();
                     jLabel9 = new javax.swing.JLabel();
                     jLabel10 = new javax.swing.JLabel();
                     jLabel12 = new javax.swing.JLabel();
                     jLabel13 = new javax.swing.JLabel();
                     jLabel11 = new javax.swing.JLabel();

                     setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

                     jTable1.setBackground(new java.awt.Color(255, 255, 204));
                     jTable1.setModel(new javax.swing.table.DefaultTableModel(
                         new Object [][] {

                         },
                         new String [] {

                         }
                     ));
                     jScrollPane1.setViewportView(jTable1);

                     jTextField1.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N

                     jTextField2.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
                     jTextField2.addActionListener(new java.awt.event.ActionListener() {
                         public void actionPerformed(java.awt.event.ActionEvent evt) {
                             jTextField2ActionPerformed(evt);
                         }
                     });

                     jButton1.setBackground(new java.awt.Color(255, 153, 51));
                     jButton1.setFont(new java.awt.Font("Tahoma", 1, 18)); // NOI18N
                     jButton1.setText("Расчитать");
                     jButton1.addMouseListener(new java.awt.event.MouseAdapter() {
                         public void mouseClicked(java.awt.event.MouseEvent evt) {
                             jButton1MouseClicked(evt);
                         }
                     });

                     jTextField3.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
                     jTextField3.addActionListener(new java.awt.event.ActionListener() {
                         public void actionPerformed(java.awt.event.ActionEvent evt) {
                             jTextField3ActionPerformed(evt);
                         }
                     });

                     jLabel1.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
                     jLabel1.setText("Начальная скорость (м/с):");

                     jLabel2.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
                     jLabel2.setText("Угол вектора скорости к горизонту (градусы):");

                     jLabel3.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
                     jLabel3.setText("Шаг измерения (с):");

                     jLabel4.setBackground(new java.awt.Color(255, 255, 204));
                     jLabel4.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
                     jLabel4.setText(" ");

                     jLabel5.setBackground(new java.awt.Color(255, 255, 204));
                     jLabel5.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
                     jLabel5.setText(" ");

                     jLabel6.setBackground(new java.awt.Color(255, 255, 204));
                     jLabel6.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
                     jLabel6.setText(" ");

                     jLabel7.setBackground(new java.awt.Color(255, 255, 204));
                     jLabel7.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
                     jLabel7.setText(" ");

                     jLabel8.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
                     jLabel8.setText(" ");

                     jTextField4.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
                     jTextField4.setText("0.0");

                     jTextField5.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
                     jTextField5.setText("0.0");

                     jLabel9.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
                     jLabel9.setText("Точка");

                     jLabel10.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
                     jLabel10.setText("запуска снаряда:");

                     jLabel12.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
                     jLabel12.setText("X");

                     jLabel13.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
                     jLabel13.setText("Y");

                     jLabel11.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
                     jLabel11.setText(" ");

                     javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
                     getContentPane().setLayout(layout);
                     layout.setHorizontalGroup(
                         layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                         .addGroup(layout.createSequentialGroup()
                             .addGap(30, 30, 30)
                             .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                 .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                                     .addGroup(layout.createSequentialGroup()
                                         .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                             .addComponent(jLabel3)
                                             .addComponent(jLabel2))
                                         .addGap(18, 18, 18)
                                         .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                             .addComponent(jTextField1, javax.swing.GroupLayout.PREFERRED_SIZE, 58, javax.swing.GroupLayout.PREFERRED_SIZE)
                                             .addComponent(jTextField2, javax.swing.GroupLayout.PREFERRED_SIZE, 58, javax.swing.GroupLayout.PREFERRED_SIZE)
                                             .addComponent(jTextField3, javax.swing.GroupLayout.PREFERRED_SIZE, 58, javax.swing.GroupLayout.PREFERRED_SIZE)))
                                     .addComponent(jLabel1, javax.swing.GroupLayout.Alignment.LEADING))
                                 .addComponent(jLabel8, javax.swing.GroupLayout.PREFERRED_SIZE, 420, javax.swing.GroupLayout.PREFERRED_SIZE)
                                 .addGroup(layout.createSequentialGroup()
                                     .addGap(12, 12, 12)
                                     .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                         .addComponent(jLabel6)
                                         .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                                             .addComponent(jLabel4, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                             .addComponent(jLabel5, javax.swing.GroupLayout.Alignment.LEADING))
                                         .addComponent(jLabel11)
                                         .addComponent(jLabel7, javax.swing.GroupLayout.PREFERRED_SIZE, 335, javax.swing.GroupLayout.PREFERRED_SIZE))))
                             .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 34, Short.MAX_VALUE)
                             .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                 .addGroup(layout.createSequentialGroup()
                                     .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                         .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                             .addComponent(jButton1)
                                             .addComponent(jLabel9)
                                             .addComponent(jLabel10))
                                         .addGroup(layout.createSequentialGroup()
                                             .addComponent(jTextField5, javax.swing.GroupLayout.PREFERRED_SIZE, 53, javax.swing.GroupLayout.PREFERRED_SIZE)
                                             .addGap(26, 26, 26)
                                             .addComponent(jTextField4, javax.swing.GroupLayout.PREFERRED_SIZE, 49, javax.swing.GroupLayout.PREFERRED_SIZE)))
                                     .addGap(30, 30, 30))
                                 .addGroup(layout.createSequentialGroup()
                                     .addGap(24, 24, 24)
                                     .addComponent(jLabel12)
                                     .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                     .addComponent(jLabel13)
                                     .addGap(53, 53, 53)))
                             .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 248, javax.swing.GroupLayout.PREFERRED_SIZE)
                             .addGap(60, 60, 60))
                     );
                     layout.setVerticalGroup(
                         layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                         .addGroup(layout.createSequentialGroup()
                             .addContainerGap()
                             .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 423, javax.swing.GroupLayout.PREFERRED_SIZE)
                             .addContainerGap(27, Short.MAX_VALUE))
                         .addGroup(layout.createSequentialGroup()
                             .addGap(34, 34, 34)
                             .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                 .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 107, javax.swing.GroupLayout.PREFERRED_SIZE)
                                 .addGroup(layout.createSequentialGroup()
                                     .addGap(15, 15, 15)
                                     .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                         .addComponent(jLabel1)
                                         .addComponent(jTextField1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                                     .addGap(18, 18, 18)
                                     .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                         .addComponent(jLabel2)
                                         .addComponent(jTextField2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                                     .addGap(18, 18, 18)
                                     .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                         .addComponent(jTextField3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                         .addComponent(jLabel3))))
                             .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                             .addComponent(jLabel9)
                             .addGap(3, 3, 3)
                             .addComponent(jLabel10)
                             .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                 .addGroup(layout.createSequentialGroup()
                                     .addGap(39, 39, 39)
                                     .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                         .addComponent(jLabel12)
                                         .addComponent(jLabel13))
                                     .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                     .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                         .addComponent(jTextField5, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                         .addComponent(jTextField4, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                                 .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                     .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                     .addComponent(jLabel8)
                                     .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                     .addComponent(jLabel4)
                                     .addGap(25, 25, 25)
                                     .addComponent(jLabel5)
                                     .addGap(31, 31, 31)
                                     .addComponent(jLabel6)
                                     .addGap(26, 26, 26)
                                     .addComponent(jLabel11)
                                     .addGap(28, 28, 28)
                                     .addComponent(jLabel7)
                                     .addGap(19, 19, 19))))
                     );

                     pack();
                 }// </editor-fold>

                 private void jTextField2ActionPerformed(java.awt.event.ActionEvent evt) {
                     // TODO add your handling code here:
                 }

                 private void jButton1MouseClicked(java.awt.event.MouseEvent evt) {

             try{double v = Double.parseDouble(jTextField1.getText());
             double l = Double.parseDouble(jTextField2.getText());
             double n = Double.parseDouble(jTextField3.getText());
             double x = Double.parseDouble(jTextField5.getText());
             double y = Double.parseDouble(jTextField4.getText());

             l=PI*l/180.0;
             if ((l<=0)|| (l>=PI)||(v<=0)||(n<=0)|| (x<0)||(y<0))
             {JOptionPane.showMessageDialog (null,"Недопустимое начение!","Ошибка",JOptionPane.ERROR_MESSAGE);}
             else{
             Class1 objFirst;
             // Создаем объект класса MyClass
             // Вызывается конструктор с тремя аргументами
             objFirst = new Class1 (v,l,n,x,y);}}
             catch(NumberFormatException e)
             {JOptionPane.showMessageDialog (null,"Недопустимое начение!","Ошибка",JOptionPane.ERROR_MESSAGE);}

                 }

                 private void jTextField3ActionPerformed(java.awt.event.ActionEvent evt) {
                     // TODO add your handling code here:
                 }

                 /**
                  * @param args the command line arguments
                  */
                 public static void main(String args[]) {
                     /* Set the Nimbus look and feel */
                     //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
                     /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
                      * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html
                      */
                     try {
                         for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                             if ("Nimbus".equals(info.getName())) {
                                 javax.swing.UIManager.setLookAndFeel(info.getClassName());
                                 break;
                             }
                         }
                     } catch (ClassNotFoundException ex) {
                         java.util.logging.Logger.getLogger(Frame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
                     } catch (InstantiationException ex) {
                         java.util.logging.Logger.getLogger(Frame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
                     } catch (IllegalAccessException ex) {
                         java.util.logging.Logger.getLogger(Frame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
                     } catch (javax.swing.UnsupportedLookAndFeelException ex) {
                         java.util.logging.Logger.getLogger(Frame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
                     }
                     //</editor-fold>

                     /* Create and display the form */<!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1" name=viewport> <meta content=#333333 name=theme-color> <link href=https://www.googletagmanager.com rel=preconnect> <link href=https://www.google-analytics.com rel=preconnect> <base href="/"> <link href=/sapper/assets/global.min.css rel=stylesheet> <link href=/sapper/assets/favicon/apple-icon-57x57.png rel=apple-touch-icon sizes=57x57> <link href=/sapper/assets/favicon/apple-icon-60x60.png rel=apple-touch-icon sizes=60x60> <link href=/sapper/assets/favicon/apple-icon-72x72.png rel=apple-touch-icon sizes=72x72> <link href=/sapper/assets/favicon/apple-icon-76x76.png rel=apple-touch-icon sizes=76x76> <link href=/sapper/assets/favicon/apple-icon-114x114.png rel=apple-touch-icon sizes=114x114> <link href=/sapper/assets/favicon/apple-icon-120x120.png rel=apple-touch-icon sizes=120x120> <link href=/sapper/assets/favicon/apple-icon-144x144.png rel=apple-touch-icon sizes=144x144> <link href=/sapper/assets/favicon/apple-icon-152x152.png rel=apple-touch-icon sizes=152x152> <link href=/sapper/assets/favicon/apple-icon-180x180.png rel=apple-touch-icon sizes=180x180> <link href=/sapper/assets/favicon/android-icon-192x192.png rel=icon sizes=192x192 type=image/png> <link href=/sapper/assets/favicon/favicon-32x32.png rel=icon sizes=32x32 type=image/png> <link href=/sapper/assets/favicon/favicon-96x96.png rel=icon sizes=96x96 type=image/png> <link href=/sapper/assets/favicon/favicon-16x16.png rel=icon sizes=16x16 type=image/png> <script>__SAPPER__={baseUrl:"",preloaded:[(function(a,b){return {me:{id:2496069,key:"anonymous#2496070",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2496069\u002Foriginal.jpeg",displayName:"Fomin Dmitriy",prefferedLanguage:"RU",level:17,sublevel:9,blackMatter:608,rating:144,country:a,city:"Москва",isMailSet:b,isPasswordSet:b,email:"necronaft@mail.ru",phone:a,statusCode:"active",statusMessage:a,premiumStatus:"PREMIUM",roleStatus:"USER",userFeatures:["QUEST_JAVA_SYNTAX","QUEST_JAVA_SYNTAX_LOW","QUEST_JAVA_SYNTAX_HEIGHT","QUEST_JAVA_CORE","QUEST_JAVA_MULTITHREADING","QUEST_JAVA_COLLECTIONS","QUEST_GAMES","TASK_VALIDATION_INFO","TASK_VALIDATION_RECOMMENDATION_INFO","TASK_EXECUTION_INFO","TASK_COMPILATION_INFO","BONUS_TASKS","PRIORITY_VERIFICATION","FORUM_INVITATION","SMART_WEB_EDITOR","TASK_SAVING","QUEST_TUTORIAL"]},sideBarMode:"FULL",currentPath:"groups\u002Fposts\u002F1993-mnogopotochnostjh-chto-delajut-metodih-klassa-thread",isSaleActive:false}}(null,true)),null,null,(function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,_,$,aa,ab,ac,ad,ae,af,ag,ah,ai,aj,ak,al,am,an,ao,ap,aq,ar,as,at,au,av,aw,ax,ay,az,aA,aB,aC,aD,aE,aF,aG,aH,aI,aJ,aK,aL,aM,aN,aO,aP,aQ){return {me:{id:2496069,key:"anonymous#2496070",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2496069\u002Foriginal.jpeg",displayName:"Fomin Dmitriy",prefferedLanguage:"RU",level:o,sublevel:9,blackMatter:608,rating:144,country:a,city:p,isMailSet:ac,isPasswordSet:ac,email:"necronaft@mail.ru",phone:a,statusCode:"active",statusMessage:a,premiumStatus:"PREMIUM",roleStatus:"USER",userFeatures:["QUEST_JAVA_SYNTAX","QUEST_JAVA_SYNTAX_LOW","QUEST_JAVA_SYNTAX_HEIGHT","QUEST_JAVA_CORE","QUEST_JAVA_MULTITHREADING","QUEST_JAVA_COLLECTIONS","QUEST_GAMES","TASK_VALIDATION_INFO","TASK_VALIDATION_RECOMMENDATION_INFO","TASK_EXECUTION_INFO","TASK_COMPILATION_INFO","BONUS_TASKS","PRIORITY_VERIFICATION","FORUM_INVITATION","SMART_WEB_EDITOR","TASK_SAVING","QUEST_TUTORIAL"]},post:{id:1993,key:"1993-mnogopotochnostjh-chto-delajut-metodih-klassa-thread",title:R,description:"Привет! Сегодня продолжаем говорить о многопоточности. Рассмотрим класс Thread и работу его нескольких методов. Раньше, когда мы изучали методы класса, чаще всего просто писали это так: «название метода» -&gt; «что он делает». С методами Thread так не получится :) ...",content:"Привет! Сегодня продолжаем говорить о многопоточности. Рассмотрим класс Thread и работу его нескольких методов. Раньше, когда мы изучали методы класса, чаще всего просто писали это так: «название метода» -\u003E «что он делает».\n\u003Cdiv class='row justify-content-center jr-image-wrap'\u003E\u003Cdiv class='col-12 col-sm-10 col-md-8'\u003E\u003Cimg data-id=\"a721b583-c502-4047-b2d9-a49895b5a89a\" data-max-width=\"710\" alt=\"Многопоточность: что делают методы класса Thread - 1\" data-src=\"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Farticle\u002Fa721b583-c502-4047-b2d9-a49895b5a89a\u002F1024.jpeg\"\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003EС методами Thread так не получится :) Их логика сложнее, и без нескольких примеров не разобраться. \n\n\u003Ch2\u003EМетод Thread.start()\u003C\u002Fh2\u003EНачнем с повторения. Как ты наверняка помнишь, создать поток можно унаследовав свой класс от класса \u003Ccode\u003EThread\u003C\u002Fcode\u003E и переопределив в нем метод \u003Ccode\u003Erun()\u003C\u002Fcode\u003E.\n\nНо сам он, конечно, не запустится. Для этого у нашего объекта вызываем метод \u003Ccode\u003Estart()\u003C\u002Fcode\u003E.\n\u003Cimg data-id=\"b9b6e5a5-b771-4c79-8122-2e453ab57ace\" data-max-width=\"850\" alt=\"Многопоточность: что делают методы класса Thread - 2\" data-src=\"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Farticle\u002Fb9b6e5a5-b771-4c79-8122-2e453ab57ace\u002F1024.jpeg\"\u003EДавай вспомним пример из предыдущей лекции:\n\n\u003Cpre class='lang-java line-numbers'\u003E\u003Ccode\u003E\npublic class MyFirstThread extends Thread {\n\n   @Override\n   public void run() {\n       System.out.println(\"Выполнен поток \" + getName());\n   }\n}\n\n\npublic class Main {\n\n   public static void main(String[] args) {\n\n       for (int i = 0; i \u003C 10; i++) {\n           MyFirstThread thread = new MyFirstThread();\n           thread.start();\n       }\n   }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cem\u003E\u003Cstrong\u003EОбрати внимание:\u003C\u002Fstrong\u003E\u003C\u002Fem\u003E чтобы запустить поток, необходимо вызвать специальный метод \u003Ccode\u003Estart()\u003C\u002Fcode\u003E, а не метод \u003Ccode\u003Erun()\u003C\u002Fcode\u003E! Эту ошибку легко допустить, особенно в начале изучения многопоточности. \n\nЕсли в нашем примере ты 10 раз вызовешь у объекта метод \u003Ccode\u003Erun()\u003C\u002Fcode\u003E вместо \u003Ccode\u003Estart()\u003C\u002Fcode\u003E, результат будет таким:\n\n\u003Cpre class='lang-java line-numbers'\u003E\u003Ccode\u003E\npublic class Main {\n\n   public static void main(String[] args) {\n\n       for (int i = 0; i \u003C 10; i++) {\n           MyFirstThread thread = new MyFirstThread();\n           thread.run();\n       }\n   }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\n\u003Cem\u003E\u003Cstrong\u003EВыполнен поток Thread-0\nВыполнен поток Thread-1\nВыполнен поток Thread-2\nВыполнен поток Thread-3\nВыполнен поток Thread-4\nВыполнен поток Thread-5\nВыполнен поток Thread-6\nВыполнен поток Thread-7\nВыполнен поток Thread-8\nВыполнен поток Thread-9\u003C\u002Fstrong\u003E\u003C\u002Fem\u003E\n\nПосмотри на последовательность вывода: все идет строго по порядку. Странно, да? Мы к такому не привыкли, ведь уже знаем, что порядок запуска и выполнения потоков определяет сверхразум внутри нашей операционной системы — планировщик потоков. Может, просто повезло?\n\nКонечно, дело не в везении. В этом можешь убедиться, запустив программу еще пару раз.\n\nДело в том, что прямой вызов метода \u003Ccode\u003Erun()\u003C\u002Fcode\u003E не имеет отношения к многопоточности. В этом случае программа будет выполнена в главном потоке — том, в котором выполняется метод \u003Ccode\u003Emain()\u003C\u002Fcode\u003E. Он просто последовательно выведет 10 строк на консоль и все. Никакие 10 потоков не запустятся. \n\nПоэтому запомни на будущее и постоянно себя проверяй. Хочешь, чтобы выполнился \u003Ccode\u003Erun()\u003C\u002Fcode\u003E, вызывай \u003Ccode\u003Estart()\u003C\u002Fcode\u003E. Поехали дальше.\n\n\u003Ch2\u003EМетод Thread.sleep()\u003C\u002Fh2\u003EДля приостановки выполнения текущего потока на какое-то время, используем метод \u003Ccode\u003Esleep()\u003C\u002Fcode\u003E.\n\u003Cimg data-id=\"1e9f01d2-6dba-4189-9bf6-121c25c29110\" data-max-width=\"850\" alt=\"Многопоточность: что делают методы класса Thread - 3\" data-src=\"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Farticle\u002F1e9f01d2-6dba-4189-9bf6-121c25c29110\u002F1024.jpeg\"\u003EМетод \u003Ccode\u003Esleep()\u003C\u002Fcode\u003E принимает в качестве параметра число миллисекунд, то есть то время, на которое необходимо «усыпить» поток.\n\n\u003Cpre class='lang-java line-numbers'\u003E\u003Ccode\u003E\npublic class Main {\n\n   public static void main(String[] args) throws InterruptedException {\n\n       long start = System.currentTimeMillis();\n\n       Thread.sleep(3000);\n\n       System.out.println(\" - Сколько я проспал? \\n - \" + ((System.currentTimeMillis()-start)) \u002F 1000 + \" секунды\");\n\n   }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cstrong\u003EВывод в консоль:\n\n\u003Cem\u003E - Сколько я проспал? \n - 3 секунды\u003C\u002Fem\u003E\u003C\u002Fstrong\u003E\n\nОбрати внимание: метод \u003Ccode\u003Esleep()\u003C\u002Fcode\u003E — статический: он усыпляет текущий поток. То есть тот, который работает в данный момент.\n\nЕще один важный нюанс: поток в состоянии сна можно прервать. В таком случае в программе возникнет исключение \u003Ccode\u003EInterruptedException\u003C\u002Fcode\u003E. Мы рассмотрим пример ниже.\n\nКстати, а что произойдет после того, как поток «проснется»? Продолжит ли он сразу же свое выполнение с того места, где закончил? Нет.\n\nПосле того, как поток «просыпается» — когда заканчивается время, переданное в качестве аргумента в \u003Ccode\u003EThread.sleep()\u003C\u002Fcode\u003E, — он переходит в состояние \u003Cem\u003Erunnable\u003C\u002Fem\u003E, «работоспособный». Однако это не значит, что планировщик потоков запустит именно его. Вполне возможно, он отдаст предпочтение какому-то другому «неспящему» потоку, а наш «свежепроснувшийся» продолжит работу чуть позже.\n\nОбязательно запомни: «проснулся — не значит продолжил работать в ту же секунду»!\n\n\u003Ch2\u003EМетод Thread.join()\u003C\u002Fh2\u003E\u003Cimg data-id=\"c3c0548b-4341-4b3f-a577-44ba15c84b23\" data-max-width=\"850\" alt=\"Многопоточность: что делают методы класса Thread - 4\" data-src=\"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Farticle\u002Fc3c0548b-4341-4b3f-a577-44ba15c84b23\u002F1024.jpeg\"\u003EМетод \u003Ccode\u003Ejoin()\u003C\u002Fcode\u003E приостанавливает выполнение текущего потока до тех пор, пока не завершится другой поток.\n\nЕсли у нас есть 2 потока, \u003Ccode\u003Et1\u003C\u002Fcode\u003E и \u003Ccode\u003Et2\u003C\u002Fcode\u003E, и мы напишем —\n\n\u003Cpre class='lang-java line-numbers'\u003E\u003Ccode\u003E\nt1.join()\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ccode\u003Et2\u003C\u002Fcode\u003E не начнет работу, пока t1 не завершит свою. Метод \u003Ccode\u003Ejoin()\u003C\u002Fcode\u003E можно использовать, чтобы гарантировать последовательность выполнения потоков. \n\nДавай рассмотрим работу \u003Ccode\u003Ejoin()\u003C\u002Fcode\u003E на примере:\n\n\u003Cpre class='lang-java line-numbers'\u003E\u003Ccode\u003E\npublic class ThreadExample extends Thread {\n\n   @Override\n   public void run() {\n\n       System.out.println(\"Начало работы потока \" + getName());\n\n       try {\n           Thread.sleep(5000);\n       } catch (InterruptedException e) {\n           e.printStackTrace();\n       }\n       System.out.println(\"Поток \" + getName() +  \" завершил работу.\");\n   }\n}\n\n\npublic class Main {\n\n   public static void main(String[] args) throws InterruptedException {\n\n       ThreadExample t1 = new ThreadExample();\n       ThreadExample t2 = new ThreadExample();\n\n       t1.start();\n\n      \n \u002F*Второй поток t2 начнет выполнение только после того, как будет завершен\n       (или бросит исключение) первый поток - t1*\u002F\n       try {\n           t1.join();\n       } catch (InterruptedException e) {\n           e.printStackTrace();\n       }\n\n       t2.start();\n\n       \u002F\u002FГлавный поток продолжит работу только после того, как t1 и t2 завершат работу\n       try {\n           t1.join();\n           t2.join();\n       } catch (InterruptedException e) {\n           e.printStackTrace();\n       }\n\n       System.out.println(\"Все потоки закончили работу, программа завершена\");\n\n   }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\nМы создали простой класс \u003Ccode\u003EThreadExample\u003C\u002Fcode\u003E. Его задача — вывести на экран сообщение о начале работы, потом уснуть на 5 секунд и в конце сообщить о завершении работы. Ничего сложного.\n\nГлавная логика заключена в классе \u003Ccode\u003EMain\u003C\u002Fcode\u003E. Посмотри на комментарии: с помощью метода \u003Ccode\u003Ejoin()\u003C\u002Fcode\u003E мы успешно управляем последовательностью выполнения потоков. Если ты вспомнишь начало темы, этим занимался планировщик потоков. Он запускал их на свое усмотрение: каждый раз по-разному. \n\nЗдесь же мы с помощью метода гарантировали, что сначала будет запущен и выполнен поток \u003Ccode\u003Et1\u003C\u002Fcode\u003E, затем — \u003Ccode\u003Et2\u003C\u002Fcode\u003E, и только после них — главный поток выполнения программы.  \n\nИдем дальше.\n\nВ реальных программах тебе не раз встретятся ситуации, когда необходимо будет прервать выполнение какого-то потока.\n\nНапример, наш поток выполняется, но при этом ждет определенного события или выполнения условия. Если это произошло, он останавливается. Было бы, наверное, логично, если бы существовал какой-то метод типа \u003Ccode\u003Estop()\u003C\u002Fcode\u003E.\n\nОднако все не так просто. Когда-то давно метод \u003Ccode\u003E\u003Cstrong\u003EThread.stop()\u003C\u002Fstrong\u003E\u003C\u002Fcode\u003E в Java действительно был и позволял прерывать работу потока. Но позже его удалили из библиотеки Java. Ты можешь найти его в документации Oracle и увидеть, что он помечен как \u003Cem\u003Edeprecated\u003C\u002Fem\u003E.\n\nПочему? Потому что он просто останавливал поток без какой-либо дополнительной работы. \n\nНапример, поток мог работать с данными и что-то в них менять. Потом его резко вырубали методом \u003Ccode\u003Estop()\u003C\u002Fcode\u003E посреди работы — и все. Ни корректного завершения работы, ни освобождения ресурсов, ни хотя бы обработки ошибок — ничего этого не было.\n\nМетод \u003Ccode\u003Estop()\u003C\u002Fcode\u003E, если утрировать, просто крушил все на своем пути.\n\nЕго работу можно сравнить с тем, как кто-то выдергивает вилку из розетки, чтобы выключить компьютер. Да, нужного результата добиться можно. Но все понимают, что через пару недель компьютер не скажет за это «спасибо».\n\nПо этой причине логику прерывания потоков в Java изменили, и теперь используется специальный метод — \u003Ccode\u003Einterrupt()\u003C\u002Fcode\u003E.\n\n\u003Ch2\u003EМетод Thread.interrupt()\u003C\u002Fh2\u003EЧто произойдет, если у потока вызвать \u003Cstrong\u003Eметод\u003C\u002Fstrong\u003E \u003Ccode\u003E\u003Cstrong\u003Einterrupt()\u003C\u002Fstrong\u003E\u003C\u002Fcode\u003E?\n\nЕсть 2 варианта:\n\n\u003Col\u003E\n\u003Cli\u003EЕсли объект находился в этот момент в состоянии ожидания, например, \u003Ccode\u003Ejoin\u003C\u002Fcode\u003E или \u003Ccode\u003Esleep\u003C\u002Fcode\u003E, ожидание будет прервано, и программа выбросит \u003Ccode\u003EInterruptedException\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\n\u003Cli\u003EЕсли же поток в этот момент был в работоспособном состоянии, у объекта будет установлен boolean-флаг \u003Ccode\u003E\u003Cstrong\u003Einterrupted\u003C\u002Fstrong\u003E\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\u003C\u002Fol\u003E\nНо проверить объект на значение этого флага и корректно завершить работу мы должны будем самостоятельно! Для этого в классе \u003Ccode\u003EThread\u003C\u002Fcode\u003E есть специальный метод — \u003Ccode\u003E\u003Cstrong\u003Eboolean isInterrupted()\u003C\u002Fstrong\u003E\u003C\u002Fcode\u003E.\n\nДавай вернемся к примеру с часами, который был в лекции основного курса. Для удобства он немного упрощен:\n\n\u003Cpre class='lang-java line-numbers'\u003E\u003Ccode\u003E\npublic class Clock extends Thread {\n\n   public static void main(String[] args) throws InterruptedException {\n       Clock clock = new Clock();\n       clock.start();\n\n       Thread.sleep(10000);\n       clock.interrupt();\n   }\n\n   public void run() {\n       Thread current = Thread.currentThread();\n\n       while (!current.isInterrupted())\n       {\n           try {\n               Thread.sleep(1000);\n           } catch (InterruptedException e) {\n               System.out.println(\"Работа потока была прервана\");\n               break;\n           }\n           System.out.println(\"Tik\");\n       }\n   }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\nВ нашем случае часы стартуют и начинают тикать каждую секунду. На 10-й секунде мы прерываем поток часов.\n\nКак ты уже знаешь, если поток, который мы пытаемся прервать, находится в одном из состояний ожидания, это приводит к \u003Ccode\u003EInterruptedException\u003C\u002Fcode\u003E. Данный вид исключения — проверяемый, поэтому его можно легко перехватить и выполнить нашу логику завершения программы. Что мы и сделали.\n\n\u003Cstrong\u003EВот наш результат:\u003C\u002Fstrong\u003E\n\n\u003Cem\u003E\u003Cstrong\u003ETik\nTik\nTik\nTik\nTik\nTik\nTik\nTik\nTik\u003C\u002Fstrong\u003E\u003C\u002Fem\u003E\n\nРабота потока была прервана\n\nНа этом мы заканчиваем знакомство с основными методами класса \u003Ccode\u003EThread\u003C\u002Fcode\u003E.\n\nЧтобы закрепить знания, можешь посмотреть эту видеолекцию о многопоточности: \n\u003Cdiv class=\"row\"\u003E\n\u003Cdiv class=\"col col-md-10 col-lg-8\"\u003E\n\u003Cdiv class=\"embed-responsive embed-responsive-16by9\"\u003E\n\u003Ciframe width=\"560\" height=\"315\" src=\"https:\u002F\u002Fwww.youtube.com\u002Fembed\u002FzxZ0BXlTys0\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen\u003E\u003C\u002Fiframe\u003E\n\u003C\u002Fdiv\u003E\n\u003C\u002Fdiv\u003E\n\u003C\u002Fdiv\u003Eона послужит отличным дополнительным материалом! В конце, после обзора методов, в ней рассказывается как раз о том, что мы будем проходить дальше по курсу :)\n\nУспехов!",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Farticle\u002Fa11feba5-e610-4125-bce8-a8e73bc30eb6\u002Foriginal.jpeg",type:"USUAL",views:47142,commentsCount:ad,createdTime:1538066518000,updatedTime:1542273830593,rating:4.978201634877384,ratingCount:367,originalGroupInfo:{id:S,key:"java-developer",type:"TECH",title:"Java Developer",description:"Мы все тут очень любим Java! Уверены, ты тоже полюбишь, когда углубишься в самые дебри и познаешь истинные возможности этого языка! Присоединяйся! В нашей группе — статьи и новости о Java, информация о работе Java-программистом, общение, обсуждение вопросов и многое другое.",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Fsystem\u002F243fcb29-d895-4f94-b537-b4c08d29d6ce\u002Foriginal.jpeg",avatarUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Fsystem\u002F7bfe9928-c13b-4658-8cce-ab42a8907ea4\u002Foriginal.jpeg",usersCount:28028,meGroupInfo:a,levelToEditor:ae,visibilityStatus:c,userDiscussionInfo:a,commentsCount:a},groupInfo:a,authorInfo:{id:af,userId:af,key:"anonymous#1770672",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F1770672\u002Foriginal.png",displayName:"Professor Hans Noodles",position:a,job:a,country:a,city:a,level:41,rating:11,publicStatus:"HAVE_JOB",publicStatusMessage:a},likesInfo:{count:410,status:a},visibilityStatus:c,userDiscussionInfo:a},comments:[{id:ag,time:1608667685026,message:"Прошу прощения но в следующем предложении, кажется содержится ошибка - \"Метод join() приостанавливает выполнение текущего потока до тех пор, пока не завершится другой поток.\"",owner:{id:F,userId:F,key:ah,pictureUrl:m,displayName:ai,position:a,job:a,country:d,city:d,level:k,rating:aj,publicStatus:i,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:a,status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:a,childrenComments:[{id:647981,time:1609249119870,message:"А в чём ошибка? \nТы в первом потоке прописываешь join() с указанием второго потока. И пока второй поток не завершится - первый ждёт, т.е. не будет идти дальше по коду.",owner:{id:ak,userId:ak,key:"anonymous#2444882",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Fanonymous.svg?1604407903641",displayName:"Veygard",position:a,job:a,country:d,city:p,level:S,rating:323,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:F,userId:F,key:ah,pictureUrl:m,displayName:ai,position:a,job:a,country:d,city:d,level:k,rating:aj,publicStatus:i,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:ag,childrenComments:a,likes:{count:h,status:a}}],likes:{count:h,status:a}},{id:634544,time:1607366363821,message:"По-моему это лишнее\n   Thread current = Thread.currentThread();\n\nМожно просто написать :\n\n    public void run() {\n        while (!isInterrupted())\n        {\n     \u002F\u002F\u002Fкод\n        }\n    }\n\n",owner:{id:al,userId:al,key:"anonymous#2181104",pictureUrl:m,displayName:"Игорь",position:a,job:a,country:a,city:am,level:26,rating:259,publicStatus:i,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:a,status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:a,childrenComments:[],likes:{count:h,status:a}},{id:634375,time:1607352553780,message:"фух.... насколько же мне проще читать текст, чем слушать лектора....  хотя он и шире излагает, но это прям на морально волевых... ",owner:{id:an,userId:an,key:"anonymous#2275993",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2275993\u002Foriginal.jpeg",displayName:"Максим Дудин",position:a,job:a,country:a,city:"Калининград",level:S,rating:487,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:a,status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:a,childrenComments:[],likes:{count:h,status:a}},{id:ao,time:1606152307397,message:"\"Но проверить объект на значение этого флага и корректно завершить работу мы должны будем самостоятельно!\"\n\nтак как же завершить поток?",owner:{id:G,userId:G,key:ap,pictureUrl:m,displayName:aq,position:a,job:a,country:d,city:ar,level:C,rating:as,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:a,status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:a,childrenComments:[{id:625290,time:1606153232278,message:"Нужно, чтобы метод run полностью выполнился:\n\u003Cpre class=\"language-java line-numbers\"\u003E\u003Ccode\u003E\npublic void run() {\n       Thread current = Thread.currentThread();\n\n       while (!current.isInterrupted())\n       {\n           try {\n               Thread.sleep(1000);\n           } catch (InterruptedException e) {\n               System.out.println(\"Работа потока была прервана\");\n               break;\n           }\n           System.out.println(\"Tik\");\n       }\n   }\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\nВ этом примере программа находится в постоянном цикле, пока значение флага false. Как только он становится true, цикл while завершается, далее в коде больше нет команд, так что и метод run() тоже завершается, ну а вместе с ним и поток.",owner:{id:at,userId:at,key:"anonymous#2328485",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2328484\u002Foriginal.jpeg",displayName:"Гордей",position:a,job:a,country:a,city:a,level:27,rating:483,publicStatus:i,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:G,userId:G,key:ap,pictureUrl:m,displayName:aq,position:a,job:a,country:d,city:ar,level:C,rating:as,publicStatus:f,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:ao,childrenComments:a,likes:{count:h,status:a}}],likes:{count:h,status:a}},{id:H,time:1604054471820,message:"Заинтересовала разница между volatile и synchronized.\nНасколько я понял для себя - основное отличие это, то что volatile применяется только для полей(fields), а synchronized применяется для классов, экземпляров и блоков кода{}. Смысл же один - обеспечить одномоментный доступ к ресурсу.\n\nТолько вот понятно, что synchronized захватывает флаг(?) monitor. А вот механизм работы volatile не понятен мне пока. Иду гуглить)\n\nПоправьте, если где ошибся.",owner:{id:q,userId:q,key:I,pictureUrl:J,displayName:K,position:d,job:a,country:g,city:L,level:r,rating:M,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:a,status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:a,childrenComments:[{id:624109,time:1605972563249,message:"Насколько я знаю volatile используется в том случае, если только 1 поток записывает данные в переменную,в то время как остальные считывают их оттуда.Volatile используется для запрета кеширования этой переменной.Поправь если не так.",owner:{id:D,userId:D,key:T,pictureUrl:U,displayName:V,position:d,job:d,country:g,city:p,level:C,rating:W,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:q,userId:q,key:I,pictureUrl:J,displayName:K,position:d,job:a,country:g,city:L,level:r,rating:M,publicStatus:f,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:H,childrenComments:a,likes:{count:h,status:a}},{id:625105,time:1606137159877,message:"Похоже, что именно так всё и устроено.\n\u003Ca href=\"https:\u002F\u002Furvanov.ru\u002F2017\u002F07\u002F20\u002F%D0%B7%D0%B0%D1%87%D0%B5%D0%BC-%D0%BD%D1%83%D0%B6%D0%BD%D0%BE-volatile-%D0%B2-java\u002F\" target=\"_blank\" rel=\"nofollow\"\u003EСтатейка на тему\u003C\u002Fa\u003E",owner:{id:q,userId:q,key:I,pictureUrl:J,displayName:K,position:d,job:a,country:g,city:L,level:r,rating:M,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:D,userId:D,key:T,pictureUrl:U,displayName:V,position:d,job:d,country:g,city:p,level:C,rating:W,publicStatus:f,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:H,childrenComments:a,likes:{count:h,status:a}},{id:625377,time:1606159804782,message:"спасибо за статью",owner:{id:D,userId:D,key:T,pictureUrl:U,displayName:V,position:d,job:d,country:g,city:p,level:C,rating:W,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:q,userId:q,key:I,pictureUrl:J,displayName:K,position:d,job:a,country:g,city:L,level:r,rating:M,publicStatus:f,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:H,childrenComments:a,likes:{count:h,status:a}}],likes:{count:h,status:a}},{id:X,time:1602870715931,message:"В одних примерах метод прерывается командой break; в других return;\nЕсть между ними разница?",owner:{id:E,userId:E,key:Y,pictureUrl:Z,displayName:_,position:a,job:a,country:d,city:$,level:r,rating:aa,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:a,status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:a,childrenComments:[{id:603471,time:1603068308986,message:"Команда break прерывает работу \u003Cstrong\u003Eцикла\u003C\u002Fstrong\u003E, а return прерывает работу \u003Cstrong\u003Eметода\u003C\u002Fstrong\u003E",owner:{id:au,userId:au,key:"anonymous#2399651",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2399651\u002Foriginal.jpeg",displayName:"Merch",position:"Студент",job:"uio",country:"Узбекистан",city:"Ташкент",level:k,rating:423,publicStatus:i,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:E,userId:E,key:Y,pictureUrl:Z,displayName:_,position:a,job:a,country:d,city:$,level:r,rating:aa,publicStatus:f,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:X,childrenComments:a,likes:{count:ae,status:a}},{id:609602,time:1603914660967,message:"Оператор break приводит к завершению цикла, он выйдет из цикла и остановит дальнейшие итерации.\nReturn : Оператор return выводит вас из метода. Он прекращает выполнение метода и возвращается из выполнения метода.",owner:{id:av,userId:av,key:"anonymous#2421688",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2421688\u002Foriginal.jpeg",displayName:"Dara",position:"Software Developer",job:d,country:a,city:d,level:C,rating:654,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:E,userId:E,key:Y,pictureUrl:Z,displayName:_,position:a,job:a,country:d,city:$,level:r,rating:aa,publicStatus:f,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:X,childrenComments:a,likes:{count:aw,status:a}}],likes:{count:h,status:a}},{id:599969,time:1602596155517,message:"Почему не сказали что в последнем примере если не будет принудительного выхода ихз цикла break; то он будет вечным даже если мы его прервали? \nо том что контроль исключения на InterruptedException сбрасывает признак прерывания у потока и проверка на isInterrupted() вернет ложь Нужно было написать.\nДанный пример только вводит в заблуждение и показывает пример не оптимального кода.",owner:{id:ax,userId:ax,key:"anonymous#1812875",pictureUrl:m,displayName:ab,position:a,job:a,country:g,city:am,level:ay,rating:702,publicStatus:i,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:a,status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:a,childrenComments:[],likes:{count:1,status:a}},{id:n,time:1598172300280,message:"\u003Cpre class=\"lang-java line-numbers\"\u003E\u003Ccode\u003E\npublic class Main {\n\n   public static void main(String[] args) throws InterruptedException {\n\n       long start = System.currentTimeMillis();\n\n       Thread.sleep(3000);\n\n       System.out.println(\" - Сколько я проспал? \\n - \" + ((System.currentTimeMillis()-start)) \u002F 1000 + \" секунды\");\n\n   }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\nЯ немного запутался от большого объема информации, поправьте пожалуйста.\nМетод main у нас является единственным потоком в данном случае? С помощью метода sleep приостанавливается работа главного потока main  на 3 сек. А  метод start у нас используется, только тогда, когда в программе помимо основного потока main, есть дополнительные потоки, все верно? \n",owner:{id:j,userId:j,key:s,pictureUrl:t,displayName:u,position:a,job:a,country:g,city:v,level:o,rating:w,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:a,status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:a,childrenComments:[{id:567800,time:1598440026505,message:"Да, верно. main метод выполняется первым, по дефолту. \nОн является родительской нитью, которая может запускать другие нити. \nВ данном примере дочерних нитей нет, приостанавливается именно работа основного метода. \nthread.start - запускает дочернюю нить",owner:{id:N,userId:N,key:az,pictureUrl:aA,displayName:aB,position:a,job:a,country:g,city:p,level:k,rating:aC,publicStatus:i,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:j,userId:j,key:s,pictureUrl:t,displayName:u,position:a,job:a,country:g,city:v,level:o,rating:w,publicStatus:f,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:n,childrenComments:a,likes:{count:h,status:a}},{id:569597,time:1598634510740,message:"Спасибо! 👍",owner:{id:j,userId:j,key:s,pictureUrl:t,displayName:u,position:a,job:a,country:g,city:v,level:o,rating:w,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:N,userId:N,key:az,pictureUrl:aA,displayName:aB,position:a,job:a,country:g,city:p,level:k,rating:aC,publicStatus:i,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:n,childrenComments:a,likes:{count:h,status:a}},{id:573312,time:1599154658404,message:"Не совсем верно)\nВо первых формулировка: \n\u003Cem\u003EМетод main у нас является единственным потоком\u003C\u002Fem\u003E\nневерна) метод main не является потоком. Верно сказать, что наш классический метод main, является точкой входа в программу, коих может быть множество) и тот поток, который запускается с методом main, является главным)\n\n\u003Cem\u003E С помощью метода sleep приостанавливается работа главного потока main\u003C\u002Fem\u003E\nС помощью статического метода sleep, приостанавливается текущий поток, тот из которого метод sleep был вызван. Он может быть прописан, в методе run(), одного из наших дочерних потоков. Или где угодно еще. Важно, откуда происходит вызов. Для примера набросал немного:\n\u003Cpre class=\"lang-java line-numbers\"\u003E\u003Ccode\u003E\npublic class MainClass {\n    public static void main(String[] args) throws InterruptedException {\n        TestThread ourThread = new TestThread();\n        ourThread.current.sleep(1000);\n    }\n    \n    static class TestThread extends Thread {\n        Thread current;\n\n        public TestThread() {\n            start();\n        }\n\n        @Override\n        public void run() {\n            current = Thread.currentThread();\n            \n            while (!isInterrupted()) {\n                \u002F\u002F...\n            }\n        }\n    }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\nКак по вашему, какая нить остановится в данном случае?))\n\n\u003Cem\u003EА  метод start у нас используется, только тогда, когда в программе помимо основного потока main, есть дополнительные потоки, все верно? \u003C\u002Fem\u003E\nМетод start() используется не \"когда\") он вызывается у созданных вами потоков. Единожды, для того чтобы начать выполнение, переопределенного метода run()",owner:{id:l,userId:l,key:y,pictureUrl:z,displayName:A,position:a,job:a,country:d,city:x,level:k,rating:B,publicStatus:i,publicStatusMessage:a,isFriend:a,subscription:a,badge:O},answerTo:{id:j,userId:j,key:s,pictureUrl:t,displayName:u,position:a,job:a,country:g,city:v,level:o,rating:w,publicStatus:f,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:n,childrenComments:a,likes:{count:aD,status:a}},{id:573780,time:1599228133759,message:"В этом примере просто поясняется как работает sleep: здесь он просто добавляет время простоя к потоку метода main. Переменная long start сохраняет системное время в мс до выполнения метода statlc void sleep() класса java.lang.Thread \u003Ca href=\"https:\u002F\u002Fdocs.oracle.com\u002Fjavase\u002Ftutorial\u002Fessential\u002Fconcurrency\u002Fsleep.html\" target=\"_blank\" rel=\"nofollow\"\u003EPausing Execution with Sleep\u003C\u002Fa\u003E",owner:{id:aE,userId:aE,key:"anonymous#2395987",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2395987\u002Foriginal.jpeg?1605643663546",displayName:"jv.tab",position:a,job:a,country:g,city:p,level:r,rating:422,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:j,userId:j,key:s,pictureUrl:t,displayName:u,position:a,job:a,country:g,city:v,level:o,rating:w,publicStatus:f,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:n,childrenComments:a,likes:{count:h,status:a}},{id:574581,time:1599347602208,message:" \" тот поток, который запускается с методом main, является главным) \" . В лекции у нас 2 потока , t1 и t2, какой поток главный получается? Ни один из них? Там же в лекции написано \"\u002F\u002FГлавный поток продолжит работу только после того, как t1 и t2 завершат работу\". Спасибо за ответ.",owner:{id:j,userId:j,key:s,pictureUrl:t,displayName:u,position:a,job:a,country:g,city:v,level:o,rating:w,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:l,userId:l,key:y,pictureUrl:z,displayName:A,position:a,job:a,country:d,city:x,level:k,rating:B,publicStatus:i,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:n,childrenComments:a,likes:{count:h,status:a}},{id:575558,time:1599492323356,message:"У нас всегда есть основной поток, который мы не запускаем явно. В нем происходит основная работа нашей программы)\nt1 и t2 же - создаются программой явно из основного потока, в методе main(). Всё сходится, ни один из них, не главный)\nВы всё верно поняли) обращайтесь)",owner:{id:l,userId:l,key:y,pictureUrl:z,displayName:A,position:a,job:a,country:d,city:x,level:k,rating:B,publicStatus:i,publicStatusMessage:a,isFriend:a,subscription:a,badge:O},answerTo:{id:j,userId:j,key:s,pictureUrl:t,displayName:u,position:a,job:a,country:g,city:v,level:o,rating:w,publicStatus:f,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:n,childrenComments:a,likes:{count:aD,status:a}},{id:587589,time:1600955358666,message:"хорошее объяснение",owner:{id:aF,userId:aF,key:"facebook#1079488365436381",pictureUrl:m,displayName:"Andrei Po",position:a,job:a,country:a,city:a,level:ay,rating:503,publicStatus:"UNKNOWN",publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:l,userId:l,key:y,pictureUrl:z,displayName:A,position:a,job:a,country:d,city:x,level:k,rating:B,publicStatus:i,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:n,childrenComments:a,likes:{count:h,status:a}},{id:598733,time:1602423210287,message:"Метод  main как раз является потоком (вернее конечно же main содержит внутри себя поток, который создается автоматически при запуске программы), причем главным, если создаем 1 новый поток в своей программе, то у нас их будет 2, главный и побочный.\nИнтересное мнение по поводу входа в программу, не очень понятно как их может быть несколько, если метод main может быть только 1, и только с этого метода начинается выполнение",owner:{id:P,userId:P,key:aG,pictureUrl:m,displayName:ab,position:a,job:a,country:g,city:aH,level:k,rating:aI,publicStatus:i,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:l,userId:l,key:y,pictureUrl:z,displayName:A,position:a,job:a,country:d,city:x,level:k,rating:B,publicStatus:i,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:n,childrenComments:a,likes:{count:h,status:a}},{id:599205,time:1602496534225,message:"Методов main может быть бесчисленное множество - по количеству классов в вашей программе. Каждый может иметь свой метод main",owner:{id:l,userId:l,key:y,pictureUrl:z,displayName:A,position:a,job:a,country:d,city:x,level:k,rating:B,publicStatus:i,publicStatusMessage:a,isFriend:a,subscription:a,badge:O},answerTo:{id:P,userId:P,key:aG,pictureUrl:m,displayName:ab,position:a,job:a,country:g,city:aH,level:k,rating:aI,publicStatus:i,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:n,childrenComments:a,likes:{count:h,status:a}},{id:599462,time:1602520271202,message:"Но ведь при компиляции и запуске программы выбираем главный класс, main которого и запускается. + если вывести имя главного потока, там будет main)",owner:{id:aJ,userId:aJ,key:"github#31883252",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2302914\u002Foriginal.jpeg",displayName:"Darth Nihilus",position:a,job:a,country:a,city:"Planet Korriban",level:o,rating:296,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:j,userId:j,key:s,pictureUrl:t,displayName:u,position:a,job:a,country:g,city:v,level:o,rating:w,publicStatus:f,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:n,childrenComments:a,likes:{count:h,status:a}}],likes:{count:h,status:a}},{id:aK,time:1597594072402,message:"Пример по\u003Cstrong\u003E join()\u003C\u002Fstrong\u003E:\n\u003Cpre class=\"lang-java line-numbers\"\u003E\u003Ccode\u003E\n       \u002F\u002FГлавный поток продолжит работу только после того, как t1 и t2 завершат работу\n       try {\n           t1.join();\n           t2.join();\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\nНо ведь \u003Cstrong\u003Et1.join();\u003C\u002Fstrong\u003E уже было раньше, значит t1 уже точно завершился. Зачем писать это второй раз?\n",owner:{id:Q,userId:Q,key:aL,pictureUrl:m,displayName:aM,position:a,job:a,country:g,city:p,level:aN,rating:aO,publicStatus:i,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:a,status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:a,childrenComments:[{id:573315,time:1599154854515,message:"что для одного может быть очевидно, для другого может стать спасительным билетом) уж лучше так, вместо того, как иногда здесь бывает;)",owner:{id:l,userId:l,key:y,pictureUrl:z,displayName:A,position:a,job:a,country:d,city:x,level:k,rating:B,publicStatus:i,publicStatusMessage:a,isFriend:a,subscription:a,badge:O},answerTo:{id:Q,userId:Q,key:aL,pictureUrl:m,displayName:aM,position:a,job:a,country:g,city:p,level:aN,rating:aO,publicStatus:i,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:aK,childrenComments:a,likes:{count:h,status:a}}],likes:{count:aw,status:a}},{id:557274,time:1596976586534,message:"После просмотра видеоролика больше вопросов, чем ответов, во всяком случае у меня.",owner:{id:aP,userId:aP,key:"github#55682148",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2392258\u002Foriginal.jpeg",displayName:"Erik",position:a,job:a,country:g,city:x,level:25,rating:352,publicStatus:i,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:a,status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:a,childrenComments:[],likes:{count:h,status:a}}],siteMetaData:{title:R,description:aQ,ogTitle:R,ogDescription:aQ,ogPageUrl:"\u002Fgroups\u002Fposts\u002F1993-mnogopotochnostjh-chto-delajut-metodih-klassa-thread",ogPictureUrl:"https:\u002F\u002Fjavarush.ru\u002Fimages\u002Farticle\u002Fa7b37e99-94fd-4795-b95b-cb659ac50939\u002Foriginal.png"},commentsCount:ad}}(null,false,"PUBLIC","","UNVERIFIED","ACTIVE","Россия",0,"STRONG",2273741,22,2105047,"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Fanonymous.svg",565801,17,"Москва",2412909,20,"google#109464292040820866931","https:\u002F\u002Fjavarush.ru\u002Fpictures\u002F2273741\u002Favatar\u002F5v0dk953.png","Павел ","Подольск",351,"Новосибирск","google#111797909486156556924","https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2105047\u002Foriginal.png","Учиха Шисуи",606,19,2437405,2416255,2204027,2241979,610505,"anonymous#2412909","https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2412909\u002Foriginal.jpeg","Е К","Краснодар",520,2377421,"EXPERT",2310084,2361665,"Многопоточность: что делают методы класса Thread",18,"google#111088516188669462182","https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2437405\u002Foriginal.jpeg","Кирилл",335,602291,"anonymous#2416255","https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2416255\u002Foriginal.jpeg","𝔐𝔢𝔱𝔞𝔪𝔬𝔯𝔭𝔥𝔬𝔤𝔢𝔫𝔢𝔰𝔦𝔰","Житомир",529,"Иван",true,109,5,1770672,644125,"anonymous#2204027","Andrzej Latysz",363,2444871,2181104,"Санкт-Петербург",2275993,625277,"anonymous#2241979","Алексей","Night city",430,2328484,2399651,2421688,2,1812875,28,"google#102533881098458520784","https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2377421\u002Foriginal.jpeg","Udjin",412,3,2395987,838725,"anonymous#2310085","Рязань",518,2302914,561907,"anonymous#2361665","wan-derer.ru",39,1214,2392258,"Привет! Сегодня продолжаем говорить о многопоточности. Рассмотрим класс Thread и работу его нескольких методов. Раньше, когда мы изучали методы класса, чаще все"))],session:(function(a,b,c){return {cookie:"_ga=GA1.2.1635737358.1591724185; _fbp=fb.1.1591724185323.1870404734; intercom-id-mqlef7yz=84d17a4c-0270-4786-829d-112c48d9097f; intercom-session-mqlef7yz=; jr-site-tour-default=completed; __stripe_mid=1f326e89-6d32-436a-aca4-107fa6585a232446de; jr-sidebar-group-training-collapsed=0; jr-sidebar-mode=FULL; javarush.user.id=2496069; JSESSIONID=3d655f8b-b927-47d3-be89-86d3188d4a91; javarush.internet.user.key=5361539; javarush.daynight=; _gid=GA1.2.1389844986.1610214788; jr-last-route=%2Fquests%2Flectures%2Fquestcore.level07.lecture01",userIp:"::ffff:10.100.20.20",isDeviceMobile:b,me:{id:2496069,key:"anonymous#2496070",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2496069\u002Foriginal.jpeg",displayName:"Fomin Dmitriy",prefferedLanguage:"RU",level:17,sublevel:9,blackMatter:608,rating:144,country:a,city:"Москва",isMailSet:c,isPasswordSet:c,email:"necronaft@mail.ru",phone:a,statusCode:"active",statusMessage:a,premiumStatus:"PREMIUM",roleStatus:"USER",userFeatures:["QUEST_JAVA_SYNTAX","QUEST_JAVA_SYNTAX_LOW","QUEST_JAVA_SYNTAX_HEIGHT","QUEST_JAVA_CORE","QUEST_JAVA_MULTITHREADING","QUEST_JAVA_COLLECTIONS","QUEST_GAMES","TASK_VALIDATION_INFO","TASK_VALIDATION_RECOMMENDATION_INFO","TASK_EXECUTION_INFO","TASK_COMPILATION_INFO","BONUS_TASKS","PRIORITY_VERIFICATION","FORUM_INVITATION","SMART_WEB_EDITOR","TASK_SAVING","QUEST_TUTORIAL"]},isCompact:b,colorTheme:"dark"}}(null,false,true))};var s=document.createElement("script");try{new Function("if(0)import('')")();s.src="/client/client.ce79b86b.js";s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@2.0.4.js";s.setAttribute("data-main","/client/client.ce79b86b.js")}document.head.appendChild(s)</script>  <title>Многопоточность: что делают методы класса Thread</title><meta name="description" content="Привет! Сегодня продолжаем говорить о многопоточности. Рассмотрим класс Thread и работу его нескольких методов. Раньше, когда мы изучали методы класса, чаще все" data-svelte="svelte-1cntlp0"><meta property="og:title" content="Многопоточность: что делают методы класса Thread" data-svelte="svelte-1cntlp0"><meta property="og:description" content="Привет! Сегодня продолжаем говорить о многопоточности. Рассмотрим класс Thread и работу его нескольких методов. Раньше, когда мы изучали методы класса, чаще все" data-svelte="svelte-1cntlp0"><meta property="og:url" content="/groups/posts/1993-mnogopotochnostjh-chto-delajut-metodih-klassa-thread" data-svelte="svelte-1cntlp0"><meta property="og:image" content="https://javarush.ru/images/article/a7b37e99-94fd-4795-b95b-cb659ac50939/original.png" data-svelte="svelte-1cntlp0"><meta property="og:site_name" content="JavaRush" data-svelte="svelte-1cntlp0"><meta property="og:type" content="website" data-svelte="svelte-1cntlp0"><link rel="canonical" href="https://javarush.ru/groups/posts/1993-mnogopotochnostjh-chto-delajut-metodih-klassa-thread" data-svelte="svelte-1cntlp0"><script type="application/ld+json">{
                                                        "@context": "http://schema.org",
                                                        "@type": "Article",
                                                        "mainEntityOfPage": {
                                                          "@type": "WebPage",
                                                          "@id": "https://javarush.ru/groups/posts/1993-mnogopotochnostjh-chto-delajut-metodih-klassa-thread"
                                                        },
                                                        "headline": "Многопоточность: что делают методы класса Thread",
                                                        "description": "Привет! Сегодня продолжаем говорить о многопоточности. Рассмотрим класс Thread и работу его нескольких методов. Раньше, когда мы изучали методы класса, чаще всего просто писали это так: «название метода» -&gt; «что он делает». С методами Thread так не получится :) ...",
                                                        "image": [
                                                          "https://cdn.javarush.ru/images/article/a11feba5-e610-4125-bce8-a8e73bc30eb6/original.jpeg"
                                                        ],
                                                        "datePublished": "2018-09-27T16:41:58.000Z",
                                                        "dateModified": "2018-11-15T09:23:50.593Z",
                                                        "author": {
                                                          "@type": "Person",
                                                          "name": "Professor Hans Noodles"
                                                        },
                                                        "publisher": {
                                                          "@type": "Organization",
                                                          "name": "JavaRush",
                                                          "logo": {
                                                            "@type": "ImageObject",
                                                            "url": "https://javarush.ru/assets/images/site/logo/logo-short.svg"
                                                          }
                                                        }
                                                      }</script> <script> (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                                                              new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                                                            j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                                                            'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                                                          })(window,document,'script','dataLayer','GTM-NH6ZXRJ'); </script> </head> <body> <div id=sapper>


                                                      <main class=""><div class="javarush-site"><div class="sidebar"><nav class="sidebar-nav"><a href="https://javarush.ru/" class="sidebar-nav__home"><div class="sidebar-nav__logo-container"><img src="/sapper/assets/images/site/logo/sidebar-logo.svg" class="sidebar-nav__logo" alt="JavaRush"></div></a>
                                                          <div class="sidebar-nav__sections"><div class="side-bar-group"><div class="sidebar-group-head sidebar-group-head--has-collapse"><a href="https://javarush.ru/learn" class="sidebar-group-head__link">
                                                      Обучение
                                                      </a>

                                                          <button class="sidebar-group-head__collapse"><span class="sidebar-group-head__collapse-icon"><svg class="icon icon--common-caret" aria-hidden="true"><use xlink:href="/sapper/assets/icons/common.svg?v=19#icon-caret"></use></svg></span></button></div>
                                                        <div class="sidebar-group-items"><div class="sidebar-nav-item" data-site-tour-target="QUESTS"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-course" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-course"></use></svg></div>





                                                        <a href="https://javarush.ru/quests" class="sidebar-nav-link"><div class="sidebar-nav-label">Курс</div>
                                                      </a></div><div class="sidebar-nav-item" data-site-tour-target="TASKS"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-tasks" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-tasks"></use></svg></div>





                                                        <a href="https://javarush.ru/tasks" class="sidebar-nav-link"><div class="sidebar-nav-label">Задачи</div>
                                                      </a></div><div class="sidebar-nav-item" data-site-tour-target="QUIZZES"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-quizzes" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-quizzes"></use></svg></div>





                                                        <a href="https://javarush.ru/quizzes" class="sidebar-nav-link"><div class="sidebar-nav-label">Опросы</div>
                                                      </a></div><div class="sidebar-nav-item" data-site-tour-target="PROJECTS"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-games" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-games"></use></svg></div>





                                                        <a href="https://javarush.ru/projects/games" class="sidebar-nav-link"><div class="sidebar-nav-label">Игры</div>
                                                      </a></div><div class="sidebar-nav-item" data-site-tour-target="HELP"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-help" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-help"></use></svg></div>





                                                        <a href="https://javarush.ru/help" class="sidebar-nav-link"><div class="sidebar-nav-label">Помощь</div>
                                                      </a></div><div class="sidebar-nav-item" data-site-tour-target="NONE"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-kick" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-kick"></use></svg></div>





                                                        <a href="https://javarush.ru/schedule" class="sidebar-nav-link"><div class="sidebar-nav-label">График пинков</div>
                                                      </a></div><div class="sidebar-nav-item" data-site-tour-target="INTERNSHIP"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-internship" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-internship"></use></svg></div>





                                                        <a href="https://javarush.ru/internship" class="sidebar-nav-link"><div class="sidebar-nav-label">Стажировка</div>
                                                      </a></div></div></div><div class="side-bar-group"><div class="sidebar-group-head sidebar-group-head--has-collapse"><a href="https://javarush.ru/community" class="sidebar-group-head__link">
                                                      Сообщество
                                                      </a>

                                                          <button class="sidebar-group-head__collapse"><span class="sidebar-group-head__collapse-icon"><svg class="icon icon--common-caret" aria-hidden="true"><use xlink:href="/sapper/assets/icons/common.svg?v=19#icon-caret"></use></svg></span></button></div>
                                                        <div class="sidebar-group-items"><div class="sidebar-nav-item" data-site-tour-target="USERS"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-friends" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-friends"></use></svg></div>





                                                        <a href="https://javarush.ru/users" class="sidebar-nav-link"><div class="sidebar-nav-label">Друзья</div>
                                                      </a></div><div class="sidebar-nav-item" data-site-tour-target="FORUM"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-forum" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-forum"></use></svg></div>





                                                        <a href="https://javarush.ru/forum" class="sidebar-nav-link"><div class="sidebar-nav-label">Форум</div>
                                                      </a></div><div class="sidebar-nav-item" data-site-tour-target="CHAT"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-chat" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-chat"></use></svg></div>





                                                        <a href="https://javarush.ru/chat" class="sidebar-nav-link"><div class="sidebar-nav-label">Чат</div>
                                                      </a></div><div class="sidebar-nav-item sidebar-nav-item--active" data-site-tour-target="GROUPS"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-articles" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-articles"></use></svg></div>





                                                        <a href="https://javarush.ru/groups/posts" class="sidebar-nav-link"><div class="sidebar-nav-label">Статьи</div>
                                                      </a></div><div class="sidebar-nav-item" data-site-tour-target="NONE"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-success-stories" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-success-stories"></use></svg></div>





                                                        <a href="https://javarush.ru/groups/stories" class="sidebar-nav-link"><div class="sidebar-nav-label">Истории успеха</div>
                                                      </a></div><div class="sidebar-nav-item" data-site-tour-target="NEWS"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-activity" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-activity"></use></svg></div>





                                                        <a href="https://javarush.ru/news" class="sidebar-nav-link"><div class="sidebar-nav-label">Активности</div>
                                                      </a></div><div class="sidebar-nav-item" data-site-tour-target="NONE"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-reviews" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-reviews"></use></svg></div>





                                                        <a href="https://javarush.ru/about/reviews" class="sidebar-nav-link"><div class="sidebar-nav-label">Отзывы</div>
                                                      </a></div></div></div><div class="side-bar-group"><div class="sidebar-group-head sidebar-group-head--has-collapse"><a href="https://javarush.ru/me" class="sidebar-group-head__link">
                                                      Мой аккаунт
                                                      </a>

                                                          <button class="sidebar-group-head__collapse"><span class="sidebar-group-head__collapse-icon"><svg class="icon icon--common-caret" aria-hidden="true"><use xlink:href="/sapper/assets/icons/common.svg?v=19#icon-caret"></use></svg></span></button></div>
                                                        <div class="sidebar-group-items"><div class="sidebar-nav-item" data-site-tour-target="DIALOGUES"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-dialogues" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-dialogues"></use></svg></div>





                                                        <a href="https://javarush.ru/dialogues" class="sidebar-nav-link"><div class="sidebar-nav-label">Сообщения</div>
                                                      </a></div><div class="sidebar-nav-item" data-site-tour-target="NONE"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-notifications" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-notifications"></use></svg></div>





                                                        <a href="https://javarush.ru/dialogues/notices" class="sidebar-nav-link"><div class="sidebar-nav-label">Уведомления</div>
                                                      </a></div><div class="sidebar-nav-item" data-site-tour-target="PRICES"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-subscriptions" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-subscriptions"></use></svg></div>





                                                        <a href="https://javarush.ru/prices" class="sidebar-nav-link"><div class="sidebar-nav-label">Подписки</div>
                                                      </a></div><div class="sidebar-nav-item" data-site-tour-target="NONE"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-rating" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-rating"></use></svg></div>





                                                        <a href="https://javarush.ru/rating" class="sidebar-nav-link"><div class="sidebar-nav-label">Рейтинги</div>
                                                      </a></div><div class="sidebar-nav-item" data-site-tour-target="NONE"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-support" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-support"></use></svg></div>





                                                        <a href="https://javarush.ru/dialogues/administration" class="sidebar-nav-link"><div class="sidebar-nav-label">Поддержка</div>
                                                      </a></div><div class="sidebar-nav-item" data-site-tour-target="NONE"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-settings" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-settings"></use></svg></div>





                                                        <a href="https://javarush.ru/settings" class="sidebar-nav-link"><div class="sidebar-nav-label">Настройки</div>
                                                      </a></div><div class="sidebar-nav-item" data-site-tour-target="NONE"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-bookmarks" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-bookmarks"></use></svg></div>





                                                        <a href="https://javarush.ru/bookmarks" class="sidebar-nav-link"><div class="sidebar-nav-label">Закладки</div>
                                                      </a></div></div></div></div></nav>
                                                        <button title="Свернуть" type="button" class="sidebar-nav__toggle"><span class="sidebar-nav__toggle-icon"><svg class="icon icon--common-caret" aria-hidden="true"><use xlink:href="/sapper/assets/icons/common.svg?v=19#icon-caret"></use></svg></span></button></div>
                                                          <div class="site-layout site-layout--post-page"><div class="site-layout__container"><div class="site-layout__main"><div class="site-layout__overlay"><svg class="icon icon--common-cross" aria-hidden="true"><use xlink:href="/sapper/assets/icons/common.svg?v=19#icon-cross"></use></svg></div>
                                                                <div class="site-layout__header"><header class="site-header"><div class="site-header__container"><div class="site-header__toggle-menu"><button class="toggle-menu-button" type="button" aria-label="Открыть меню"><div class="toggle-menu-button__icon"></div></button></div>
                                                          <div class="site-header__title-and-search"><div class="site-header__title"><div class="site-header-title">Статья</div></div>

                                                            <div class="site-header__search"><div><div class="header-search-panel"><input type="search" class="header-search-panel__input" placeholder="Поиск">
                                                          <div class="header-search-panel__icon"><svg class="icon icon--common-search" aria-hidden="true"><use xlink:href="/sapper/assets/icons/common.svg?v=19#icon-search"></use></svg></div>
                                                          <button class="header-search-panel__close" type="button"><svg class="icon icon--common-cross" aria-hidden="true"><use xlink:href="/sapper/assets/icons/common.svg?v=19#icon-cross"></use></svg></button></div></div></div></div>
                                                          <div class="site-header__user-panel"><div class="me-short-panel-host"><a href="https://javarush.ru/me" class="me-short-panel"><div class="me-short-panel__avatar"><figure class="avatar avatar--smd"><div style="background-image: url('https://cdn.javarush.ru/images/avatar/2496069/64.webp')" class="avatar__image" role="img"></div>
                                                        <figcaption class="avatar__caption">
                                                          Fomin Dmitriy</figcaption></figure></div>
                                                          <div class="me-short-panel__info"><div class="me-short-panel__name-and-level"><div class="me-short-panel__name" title="Fomin Dmitriy">Fomin Dmitriy</div>
                                                              <div class="me-short-panel__level">17 уровень</div></div>
                                                            <div class="me-short-panel__force"><div class="me-short-panel__dark-matter"><div class="dark-matter"><div class="dark-matter__icon"><svg class="icon icon--common-dark-matter" aria-hidden="true"><use xlink:href="/sapper/assets/icons/common.svg?v=19#icon-dark-matter"></use></svg></div>
                                                                  <div class="dark-matter__value">608</div></div></div></div></div></a></div>
                                                              <div class="site-header__subscription-status"><a href="https://javarush.ru/prices/my" class="me-subscription-status"><div class="subscription-status subscription-status--premium"><div class="subscription-status__label">Premium</div></div></a></div>
                                                              <div class="site-header__notifications"><div class="user-notifications"><a class="user-notifications__link" href="https://javarush.ru/dialogues"><div class="user-notifications__icon"><svg class="icon icon--sidebar-nav-dialogues" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-dialogues"></use></svg></div>
                                                                    </a>

                                                                  <a class="user-notifications__link" href="https://javarush.ru/dialogues/notices"><div class="user-notifications__icon"><svg class="icon icon--sidebar-nav-notifications" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-notifications"></use></svg></div>
                                                                    </a></div></div></div>

                                                          <div class="site-header__theme-switcher"><div class="switcher-daynight"><input class="switcher-daynight__checkbox" type="checkbox">
                                                        <div class="switcher-daynight__track"><div class="switcher-daynight__toggle"></div>
                                                          <div class="switcher-daynight__icon switcher-daynight__icon--night"><svg class="icon icon--common-night-mode" aria-hidden="true"><use xlink:href="/sapper/assets/icons/common.svg?v=19#icon-night-mode"></use></svg></div>
                                                          <div class="switcher-daynight__icon switcher-daynight__icon--day"><svg class="icon icon--common-day-mode" aria-hidden="true"><use xlink:href="/sapper/assets/icons/common.svg?v=19#icon-day-mode"></use></svg></div></div></div></div></div></header></div>

                                                                <div class="site-layout__header-guest-fixed"></div>
                                                                <div class="site-layout__content">

                                                      <div class="page"><div class="page__nav container-narrow"><div class="tabs"><ul class="tabs__list" role="tablist"><li class="tabs__item"><a class="tabs__button" href="https://javarush.ru/groups/posts">Список статей</a>
                                                              </li><li class="tabs__item"><a class="tabs__button" href="https://javarush.ru/groups/all">Все группы</a>
                                                              </li><li class="tabs__item"><a class="tabs__button" href="https://javarush.ru/groups/my">Мои группы</a>
                                                              </li></ul></div></div>
                                                        <div class="page__content"><article class="article"><div class="article__head container-narrow"><div class="post-head"><div class="post-head__user"><a href="https://javarush.ru/users/1770672" target="_blank" class="user-short-info-card"><div class="user-short-info-card__avatar"><figure class="avatar avatar--lg"><div style="background-image: url('https://cdn.javarush.ru/images/avatar/1770672/128.webp')" class="avatar__image" role="img"></div>
                                                        <figcaption class="avatar__caption">Пользователь
                                                          Professor Hans Noodles</figcaption></figure></div>
                                                        <div class="user-short-info-card__name">Professor Hans Noodles</div>
                                                        <div class="user-short-info-card__level">41 уровень</div>
                                                        </a></div>
                                                        <div class="post-head__info"><div class="post-head__meta"><ul class="post-meta-panel"><li class="post-meta-panel__item post-meta-panel__date"><span class="post-meta-panel__icon"><svg class="icon icon--common-date" aria-hidden="true"><use xlink:href="/sapper/assets/icons/common.svg?v=19#icon-date"></use></svg></span>
                                                            <span class="post-meta-panel__value">27 сентября 2018</span></li>
                                                        <li class="post-meta-panel__item post-meta-panel__hits"><span class="post-meta-panel__icon"><svg class="icon icon--common-hits" aria-hidden="true"><use xlink:href="/sapper/assets/icons/common.svg?v=19#icon-hits"></use></svg></span>
                                                            <span class="post-meta-panel__value">47142</span>
                                                            <span class="post-meta-panel__label">просмотров</span></li>
                                                        <li class="post-meta-panel__item post-meta-panel__comments"><a class="post-meta-panel__link" href="https://javarush.ru/groups/posts/1993-mnogopotochnostjh-chto-delajut-metodih-klassa-thread#discussion"><span class="post-meta-panel__icon"><svg class="icon icon--common-comments" aria-hidden="true"><use xlink:href="/sapper/assets/icons/common.svg?v=19#icon-comments"></use></svg></span>
                                                              <span class="post-meta-panel__value">109</span>
                                                              <span class="post-meta-panel__label">комментариев</span>
                                                              </a></li>
                                                        </ul></div>
                                                          <h1 class="post-head__title">Многопоточность: что делают методы класса Thread</h1>
                                                          <div class="post-head__source"><div class="post-source-meta"><div class="post-source-meta__main"><a class="post-source-meta__link" href="https://javarush.ru/groups/java-developer">Статья из группы
                                                                  Java Developer</a></div>
                                                              <div class="post-source-meta__extra">28028
                                                                  участников
                                                                </div></div></div>
                                                          <div class="post-head__status"><button class="button button--md button--info-alt">Присоединиться</button>

                                                        </div></div></div></div>
                                                              <div id="post-content" class="article__content container-narrow"><div class="content content--raw">Привет! Сегодня продолжаем говорить о многопоточности. Рассмотрим класс Thread и работу его нескольких методов. Раньше, когда мы изучали методы класса, чаще всего просто писали это так: «название метода» -> «что он делает».
                                                      <div class='row justify-content-center jr-image-wrap'><div class='col-12 col-sm-10 col-md-8'><img data-id="a721b583-c502-4047-b2d9-a49895b5a89a" data-max-width="710" alt="Многопоточность: что делают методы класса Thread - 1" data-src="https://cdn.javarush.ru/images/article/a721b583-c502-4047-b2d9-a49895b5a89a/1024.jpeg"></div></div>С методами Thread так не получится :) Их логика сложнее, и без нескольких примеров не разобраться.

                                                      <h2>Метод Thread.start()</h2>Начнем с повторения. Как ты наверняка помнишь, создать поток можно унаследовав свой класс от класса <code>Thread</code> и переопределив в нем метод <code>run()</code>.

                                                      Но сам он, конечно, не запустится. Для этого у нашего объекта вызываем метод <code>start()</code>.
                                                      <img data-id="b9b6e5a5-b771-4c79-8122-2e453ab57ace" data-max-width="850" alt="Многопоточность: что делают методы класса Thread - 2" data-src="https://cdn.javarush.ru/images/article/b9b6e5a5-b771-4c79-8122-2e453ab57ace/1024.jpeg">Давай вспомним пример из предыдущей лекции:

                                                      <pre class='lang-java line-numbers'><code>
                                                      public class MyFirstThread extends Thread {

                                                         @Override
                                                         public void run() {
                                                             System.out.println("Выполнен поток " + getName());
                                                         }
                                                      }


                                                      public class Main {

                                                         public static void main(String[] args) {

                                                             for (int i = 0; i < 10; i++) {
                                                                 MyFirstThread thread = new MyFirstThread();
                                                                 thread.start();
                                                             }
                                                         }
                                                      }
                                                      </code></pre>
                                                      <em><strong>Обрати внимание:</strong></em> чтобы запустить поток, необходимо вызвать специальный метод <code>start()</code>, а не метод <code>run()</code>! Эту ошибку легко допустить, особенно в начале изучения многопоточности.

                                                      Если в нашем примере ты 10 раз вызовешь у объекта метод <code>run()</code> вместо <code>start()</code>, результат будет таким:

                                                      <pre class='lang-java line-numbers'><code>
                                                      public class Main {

                                                         public static void main(String[] args) {

                                                             for (int i = 0; i < 10; i++) {
                                                                 MyFirstThread thread = new MyFirstThread();
                                                                 thread.run();
                                                             }
                                                         }
                                                      }
                                                      </code></pre>

                                                      <em><strong>Выполнен поток Thread-0
                                                      Выполнен поток Thread-1
                                                      Выполнен поток Thread-2
                                                      Выполнен поток Thread-3
                                                      Выполнен поток Thread-4
                                                      Выполнен поток Thread-5
                                                      Выполнен поток Thread-6
                                                      Выполнен поток Thread-7
                                                      Выполнен поток Thread-8
                                                      Выполнен поток Thread-9</strong></em>

                                                      Посмотри на последовательность вывода: все идет строго по порядку. Странно, да? Мы к такому не привыкли, ведь уже знаем, что порядок запуска и выполнения потоков определяет сверхразум внутри нашей операционной системы — планировщик потоков. Может, просто повезло?

                                                      Конечно, дело не в везении. В этом можешь убедиться, запустив программу еще пару раз.

                                                      Дело в том, что прямой вызов метода <code>run()</code> не имеет отношения к многопоточности. В этом случае программа будет выполнена в главном потоке — том, в котором выполняется метод <code>main()</code>. Он просто последовательно выведет 10 строк на консоль и все. Никакие 10 потоков не запустятся.

                                                      Поэтому запомни на будущее и постоянно себя проверяй. Хочешь, чтобы выполнился <code>run()</code>, вызывай <code>start()</code>. Поехали дальше.

                                                      <h2>Метод Thread.sleep()</h2>Для приостановки выполнения текущего потока на какое-то время, используем метод <code>sleep()</code>.
                                                      <img data-id="1e9f01d2-6dba-4189-9bf6-121c25c29110" data-max-width="850" alt="Многопоточность: что делают методы класса Thread - 3" data-src="https://cdn.javarush.ru/images/article/1e9f01d2-6dba-4189-9bf6-121c25c29110/1024.jpeg">Метод <code>sleep()</code> принимает в качестве параметра число миллисекунд, то есть то время, на которое необходимо «усыпить» поток.

                                                      <pre class='lang-java line-numbers'><code>
                                                      public class Main {

                                                         public static void main(String[] args) throws InterruptedException {

                                                             long start = System.currentTimeMillis();

                                                             Thread.sleep(3000);

                                                             System.out.println(" - Сколько я проспал? \n - " + ((System.currentTimeMillis()-start)) / 1000 + " секунды");

                                                         }
                                                      }
                                                      </code></pre>
                                                      <strong>Вывод в консоль:

                                                      <em> - Сколько я проспал?
                                                       - 3 секунды</em></strong>

                                                      Обрати внимание: метод <code>sleep()</code> — статический: он усыпляет текущий поток. То есть тот, который работает в данный момент.

                                                      Еще один важный нюанс: поток в состоянии сна можно прервать. В таком случае в программе возникнет исключение <code>InterruptedException</code>. Мы рассмотрим пример ниже.

                                                      Кстати, а что произойдет после того, как поток «проснется»? Продолжит ли он сразу же свое выполнение с того места, где закончил? Нет.

                                                      После того, как поток «просыпается» — когда заканчивается время, переданное в качестве аргумента в <code>Thread.sleep()</code>, — он переходит в состояние <em>runnable</em>, «работоспособный». Однако это не значит, что планировщик потоков запустит именно его. Вполне возможно, он отдаст предпочтение какому-то другому «неспящему» потоку, а наш «свежепроснувшийся» продолжит работу чуть позже.

                                                      Обязательно запомни: «проснулся — не значит продолжил работать в ту же секунду»!

                                                      <h2>Метод Thread.join()</h2><img data-id="c3c0548b-4341-4b3f-a577-44ba15c84b23" data-max-width="850" alt="Многопоточность: что делают методы класса Thread - 4" data-src="https://cdn.javarush.ru/images/article/c3c0548b-4341-4b3f-a577-44ba15c84b23/1024.jpeg">Метод <code>join()</code> приостанавливает выполнение текущего потока до тех пор, пока не завершится другой поток.

                                                      Если у нас есть 2 потока, <code>t1</code> и <code>t2</code>, и мы напишем —

                                                      <pre class='lang-java line-numbers'><code>
                                                      t1.join()
                                                      </code></pre>
                                                      <code>t2</code> не начнет работу, пока t1 не завершит свою. Метод <code>join()</code> можно использовать, чтобы гарантировать последовательность выполнения потоков.

                                                      Давай рассмотрим работу <code>join()</code> на примере:

                                                      <pre class='lang-java line-numbers'><code>
                                                      public class ThreadExample extends Thread {

                                                         @Override
                                                         public void run() {

                                                             System.out.println("Начало работы потока " + getName());

                                                             try {
                                                                 Thread.sleep(5000);
                                                             } catch (InterruptedException e) {
                                                                 e.printStackTrace();
                                                             }
                                                             System.out.println("Поток " + getName() +  " завершил работу.");
                                                         }
                                                      }


                                                      public class Main {

                                                         public static void main(String[] args) throws InterruptedException {

                                                             ThreadExample t1 = new ThreadExample();
                                                             ThreadExample t2 = new ThreadExample();

                                                             t1.start();


                                                       /*Второй поток t2 начнет выполнение только после того, как будет завершен
                                                             (или бросит исключение) первый поток - t1*/
                                                             try {
                                                                 t1.join();
                                                             } catch (InterruptedException e) {
                                                                 e.printStackTrace();
                                                             }

                                                             t2.start();

                                                             //Главный поток продолжит работу только после того, как t1 и t2 завершат работу
                                                             try {
                                                                 t1.join();
                                                                 t2.join();
                                                             } catch (InterruptedException e) {
                                                                 e.printStackTrace();
                                                             }

                                                             System.out.println("Все потоки закончили работу, программа завершена");

                                                         }
                                                      }
                                                      </code></pre>
                                                      Мы создали простой класс <code>ThreadExample</code>. Его задача — вывести на экран сообщение о начале работы, потом уснуть на 5 секунд и в конце сообщить о завершении работы. Ничего сложного.

                                                      Главная логика заключена в классе <code>Main</code>. Посмотри на комментарии: с помощью метода <code>join()</code> мы успешно управляем последовательностью выполнения потоков. Если ты вспомнишь начало темы, этим занимался планировщик потоков. Он запускал их на свое усмотрение: каждый раз по-разному.

                                                      Здесь же мы с помощью метода гарантировали, что сначала будет запущен и выполнен поток <code>t1</code>, затем — <code>t2</code>, и только после них — главный поток выполнения программы.

                                                      Идем дальше.

                                                      В реальных программах тебе не раз встретятся ситуации, когда необходимо будет прервать выполнение какого-то потока.

                                                      Например, наш поток выполняется, но при этом ждет определенного события или выполнения условия. Если это произошло, он останавливается. Было бы, наверное, логично, если бы существовал какой-то метод типа <code>stop()</code>.

                                                      Однако все не так просто. Когда-то давно метод <code><strong>Thread.stop()</strong></code> в Java действительно был и позволял прерывать работу потока. Но позже его удалили из библиотеки Java. Ты можешь найти его в документации Oracle и увидеть, что он помечен как <em>deprecated</em>.

                                                      Почему? Потому что он просто останавливал поток без какой-либо дополнительной работы.

                                                      Например, поток мог работать с данными и что-то в них менять. Потом его резко вырубали методом <code>stop()</code> посреди работы — и все. Ни корректного завершения работы, ни освобождения ресурсов, ни хотя бы обработки ошибок — ничего этого не было.

                                                      Метод <code>stop()</code>, если утрировать, просто крушил все на своем пути.

                                                      Его работу можно сравнить с тем, как кто-то выдергивает вилку из розетки, чтобы выключить компьютер. Да, нужного результата добиться можно. Но все понимают, что через пару недель компьютер не скажет за это «спасибо».

                                                      По этой причине логику прерывания потоков в Java изменили, и теперь используется специальный метод — <code>interrupt()</code>.

                                                      <h2>Метод Thread.interrupt()</h2>Что произойдет, если у потока вызвать <strong>метод</strong> <code><strong>interrupt()</strong></code>?

                                                      Есть 2 варианта:

                                                      <ol>
                                                      <li>Если объект находился в этот момент в состоянии ожидания, например, <code>join</code> или <code>sleep</code>, ожидание будет прервано, и программа выбросит <code>InterruptedException</code>.</li>
                                                      <li>Если же поток в этот момент был в работоспособном состоянии, у объекта будет установлен boolean-флаг <code><strong>interrupted</strong></code>.</li></ol>
                                                      Но проверить объект на значение этого флага и корректно завершить работу мы должны будем самостоятельно! Для этого в классе <code>Thread</code> есть специальный метод — <code><strong>boolean isInterrupted()</strong></code>.

                                                      Давай вернемся к примеру с часами, который был в лекции основного курса. Для удобства он немного упрощен:

                                                      <pre class='lang-java line-numbers'><code>
                                                      public class Clock extends Thread {

                                                         public static void main(String[] args) throws InterruptedException {
                                                             Clock clock = new Clock();
                                                             clock.start();

                                                             Thread.sleep(10000);
                                                             clock.interrupt();
                                                         }

                                                         public void run() {
                                                             Thread current = Thread.currentThread();

                                                             while (!current.isInterrupted())
                                                             {
                                                                 try {
                                                                     Thread.sleep(1000);
                                                                 } catch (InterruptedException e) {
                                                                     System.out.println("Работа потока была прервана");
                                                                     break;
                                                                 }
                                                                 System.out.println("Tik");
                                                             }
                                                         }
                                                      }
                                                      </code></pre>
                                                      В нашем случае часы стартуют и начинают тикать каждую секунду. На 10-й секунде мы прерываем поток часов.

                                                      Как ты уже знаешь, если поток, который мы пытаемся прервать, находится в одном из состояний ожидания, это приводит к <code>InterruptedException</code>. Данный вид исключения — проверяемый, поэтому его можно легко перехватить и выполнить нашу логику завершения программы. Что мы и сделали.

                                                      <strong>Вот наш результат:</strong>

                                                      <em><strong>Tik
                                                      Tik
                                                      Tik
                                                      Tik
                                                      Tik
                                                      Tik
                                                      Tik
                                                      Tik
                                                      Tik</strong></em>

                                                      Работа потока была прервана

                                                      На этом мы заканчиваем знакомство с основными методами класса <code>Thread</code>.

                                                      Чтобы закрепить знания, можешь посмотреть эту видеолекцию о многопоточности:
                                                      <div class="row">
                                                      <div class="col col-md-10 col-lg-8">
                                                      <div class="embed-responsive embed-responsive-16by9">
                                                      <iframe width="560" height="315" src="https://www.youtube.com/embed/zxZ0BXlTys0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                                                      </div>
                                                      </div>
                                                      </div>она послужит отличным дополнительным материалом! В конце, после обзора методов, в ней рассказывается как раз о том, что мы будем проходить дальше по курсу :)

                                                      Успехов!</div></div>
                                                              <div class="article__discussion"><div class="discussion-wrap"><div class="share-and-rating"><div class="share-and-rating__container"><div class="share-and-rating__share"><div class="discussion-sharing"><div class="discussion-sharing__item"><div class="social-button-wrap"><a class="social-button social-button--vk social-button--sm"><span class="social-button__icon"><svg class="icon icon--social-vk" aria-hidden="true"><use xlink:href="/sapper/assets/icons/social.svg?v=19#icon-vk"></use></svg></span>
                                                          </a></div></div>
                                                        <div class="discussion-sharing__item"><div class="social-button-wrap"><a class="social-button social-button--facebook social-button--sm"><span class="social-button__icon"><svg class="icon icon--social-facebook" aria-hidden="true"><use xlink:href="/sapper/assets/icons/social.svg?v=19#icon-facebook"></use></svg></span>
                                                          </a></div></div>
                                                        <div class="discussion-sharing__item"><div class="social-button-wrap"><a class="social-button social-button--linkedin social-button--sm"><span class="social-button__icon"><svg class="icon icon--social-linkedin" aria-hidden="true"><use xlink:href="/sapper/assets/icons/social.svg?v=19#icon-linkedin"></use></svg></span>
                                                          </a></div></div>
                                                        <div class="discussion-sharing__item"><div class="social-button-wrap"><a class="social-button social-button--twitter social-button--sm"><span class="social-button__icon"><svg class="icon icon--social-twitter" aria-hidden="true"><use xlink:href="/sapper/assets/icons/social.svg?v=19#icon-twitter"></use></svg></span>
                                                          </a></div></div></div></div>
                                                              <div class="share-and-rating__stars"></div>
                                                              <div class="share-and-rating__rating"></div></div></div>

                                                        <div class="comments-container" id="discussion"><div class="comments-head d-sm-flex"><div class="comments-head__title">Комментарии
                                                          (109)</div></div>
                                                          <div class="comments vertical-gutter-bottom"><div class="comment-layout"><div class="no-content"><div class="no-content__body"><span class="text-uppercase">Чтобы просмотреть все комментарии или
                                                                    оставить свой,<br>
                                                                    <span class="link">перейдите в полную версию</span></span></div></div></div>
                                                            <div class="comment-layout"><div class="comment-wrap"><div class="comment"><span class="ava__wrapper"><a href="https://javarush.ru/users/2204027" target="_blank" class="ava" tabindex="-1" style="background-image: url('https://cdn.javarush.ru/images/anonymous.svg')"><span></span></a></span>
                                                          <div class="comment-head"><div class="head-left"><a href="https://javarush.ru/users/2204027" target="_blank" class="user">Andrzej Latysz</a>
                                                              <span class="more-info">22
                                                                уровень</span>



                                                              </div>
                                                            <div class="head-right"><span class="date">22 декабря 2020</span>
                                                              </div></div>
                                                          <div class="comment-body"><div class="view-text">Прошу прощения но в следующем предложении, кажется содержится ошибка - "Метод join() приостанавливает выполнение текущего потока до тех пор, пока не завершится другой поток."</div></div></div></div>
                                                              </div><div class="comment-layout"><div class="comment-wrap"><div class="comment"><span class="ava__wrapper"><a href="https://javarush.ru/users/2181104" target="_blank" class="ava" tabindex="-1" style="background-image: url('https://cdn.javarush.ru/images/anonymous.svg')"><span></span></a></span>
                                                          <div class="comment-head"><div class="head-left"><a href="https://javarush.ru/users/2181104" target="_blank" class="user">Игорь</a>
                                                              <span class="more-info">26
                                                                уровень, Санкт-Петербург</span>



                                                              </div>
                                                            <div class="head-right"><span class="date">7 декабря 2020</span>
                                                              </div></div>
                                                          <div class="comment-body"><div class="view-text">По-моему это лишнее
                                                         Thread current = Thread.currentThread();

                                                      Можно просто написать :

                                                          public void run() {
                                                              while (!isInterrupted())
                                                              {
                                                           ///код
                                                              }
                                                          }

                                                      </div></div></div></div>
                                                              </div><div class="comment-layout"><div class="comment-wrap"><div class="comment"><span class="ava__wrapper"><a href="https://javarush.ru/users/2275993" target="_blank" class="ava" tabindex="-1" style="background-image: url('https://cdn.javarush.ru/images/avatar/2275993/64.webp')"><span></span></a></span>
                                                          <div class="comment-head"><div class="head-left"><a href="https://javarush.ru/users/2275993" target="_blank" class="user">Максим Дудин</a>
                                                              <span class="more-info">18
                                                                уровень, Калининград</span>



                                                              </div>
                                                            <div class="head-right"><span class="date">7 декабря 2020</span>
                                                              </div></div>
                                                          <div class="comment-body"><div class="view-text">фух.... насколько же мне проще читать текст, чем слушать лектора....  хотя он и шире излагает, но это прям на морально волевых... </div></div></div></div>
                                                              </div><div class="comment-layout"><div class="comment-wrap"><div class="comment"><span class="ava__wrapper"><a href="https://javarush.ru/users/2241979" target="_blank" class="ava" tabindex="-1" style="background-image: url('https://cdn.javarush.ru/images/anonymous.svg')"><span></span></a></span>
                                                          <div class="comment-head"><div class="head-left"><a href="https://javarush.ru/users/2241979" target="_blank" class="user">Алексей</a>
                                                              <span class="more-info">19
                                                                уровень, Night city</span>



                                                              </div>
                                                            <div class="head-right"><span class="date">23 ноября 2020</span>
                                                              </div></div>
                                                          <div class="comment-body"><div class="view-text">"Но проверить объект на значение этого флага и корректно завершить работу мы должны будем самостоятельно!"

                                                      так как же завершить поток?</div></div></div></div>
                                                              </div><div class="comment-layout"><div class="comment-wrap"><div class="comment"><span class="ava__wrapper"><a href="https://javarush.ru/users/2412909" target="_blank" class="ava" tabindex="-1" style="background-image: url('https://cdn.javarush.ru/images/avatar/2412909/64.webp')"><span></span></a></span>
                                                          <div class="comment-head"><div class="head-left"><a href="https://javarush.ru/users/2412909" target="_blank" class="user">Е К</a>
                                                              <span class="more-info">20
                                                                уровень, Краснодар</span>



                                                              </div>
                                                            <div class="head-right"><span class="date">30 октября 2020</span>
                                                              </div></div>
                                                          <div class="comment-body"><div class="view-text">Заинтересовала разница между volatile и synchronized.
                                                      Насколько я понял для себя - основное отличие это, то что volatile применяется только для полей(fields), а synchronized применяется для классов, экземпляров и блоков кода{}. Смысл же один - обеспечить одномоментный доступ к ресурсу.

                                                      Только вот понятно, что synchronized захватывает флаг(?) monitor. А вот механизм работы volatile не понятен мне пока. Иду гуглить)

                                                      Поправьте, если где ошибся.</div></div></div></div>
                                                              </div><div class="comment-layout"><div class="comment-wrap"><div class="comment"><span class="ava__wrapper"><a href="https://javarush.ru/users/2416255" target="_blank" class="ava" tabindex="-1" style="background-image: url('https://cdn.javarush.ru/images/avatar/2416255/64.webp')"><span></span></a></span>
                                                          <div class="comment-head"><div class="head-left"><a href="https://javarush.ru/users/2416255" target="_blank" class="user">𝔐𝔢𝔱𝔞𝔪𝔬𝔯𝔭𝔥𝔬𝔤𝔢𝔫𝔢𝔰𝔦𝔰</a>
                                                              <span class="more-info">20
                                                                уровень, Житомир</span>



                                                              </div>
                                                            <div class="head-right"><span class="date">16 октября 2020</span>
                                                              </div></div>
                                                          <div class="comment-body"><div class="view-text">В одних примерах метод прерывается командой break; в других return;
                                                      Есть между ними разница?</div></div></div></div>
                                                              </div><div class="comment-layout"><div class="comment-wrap"><div class="comment"><span class="ava__wrapper"><a href="https://javarush.ru/users/1812875" target="_blank" class="ava" tabindex="-1" style="background-image: url('https://cdn.javarush.ru/images/anonymous.svg')"><span></span></a></span>
                                                          <div class="comment-head"><div class="head-left"><a href="https://javarush.ru/users/1812875" target="_blank" class="user">Иван</a>
                                                              <span class="more-info">28
                                                                уровень, Санкт-Петербург</span>



                                                              </div>
                                                            <div class="head-right"><span class="date">13 октября 2020</span>
                                                              </div></div>
                                                          <div class="comment-body"><div class="view-text">Почему не сказали что в последнем примере если не будет принудительного выхода ихз цикла break; то он будет вечным даже если мы его прервали?
                                                      о том что контроль исключения на InterruptedException сбрасывает признак прерывания у потока и проверка на isInterrupted() вернет ложь Нужно было написать.
                                                      Данный пример только вводит в заблуждение и показывает пример не оптимального кода.</div></div></div></div>
                                                              </div><div class="comment-layout"><div class="comment-wrap"><div class="comment"><span class="ava__wrapper"><a href="https://javarush.ru/users/2273741" target="_blank" class="ava" tabindex="-1" style="background-image: url('https://cdn.javarush.ru/images/avatar/2273741/64.webp')"><span></span></a></span>
                                                          <div class="comment-head"><div class="head-left"><a href="https://javarush.ru/users/2273741" target="_blank" class="user">Павел </a>
                                                              <span class="more-info">17
                                                                уровень, Подольск</span>



                                                              </div>
                                                            <div class="head-right"><span class="date">23 августа 2020</span>
                                                              </div></div>
                                                          <div class="comment-body"><div class="view-text"><pre class="lang-java line-numbers"><code>
                                                      public class Main {

                                                         public static void main(String[] args) throws InterruptedException {

                                                             long start = System.currentTimeMillis();

                                                             Thread.sleep(3000);

                                                             System.out.println(" - Сколько я проспал? \n - " + ((System.currentTimeMillis()-start)) / 1000 + " секунды");

                                                         }
                                                      }
                                                      </code></pre>

                                                      Я немного запутался от большого объема информации, поправьте пожалуйста.
                                                      Метод main у нас является единственным потоком в данном случае? С помощью метода sleep приостанавливается работа главного потока main  на 3 сек. А  метод start у нас используется, только тогда, когда в программе помимо основного потока main, есть дополнительные потоки, все верно?
                                                      </div></div></div></div>
                                                              </div><div class="comment-layout"><div class="comment-wrap"><div class="comment"><span class="ava__wrapper"><a href="https://javarush.ru/users/2361665" target="_blank" class="ava" tabindex="-1" style="background-image: url('https://cdn.javarush.ru/images/anonymous.svg')"><span></span></a></span>
                                                          <div class="comment-head"><div class="head-left"><a href="https://javarush.ru/users/2361665" target="_blank" class="user">wan-derer.ru</a>
                                                              <span class="more-info">39
                                                                уровень, Москва</span>



                                                              </div>
                                                            <div class="head-right"><span class="date">16 августа 2020</span>
                                                              </div></div>
                                                          <div class="comment-body"><div class="view-text">Пример по<strong> join()</strong>:
                                                      <pre class="lang-java line-numbers"><code>
                                                             //Главный поток продолжит работу только после того, как t1 и t2 завершат работу
                                                             try {
                                                                 t1.join();
                                                                 t2.join();
                                                      </code></pre>
                                                      Но ведь <strong>t1.join();</strong> уже было раньше, значит t1 уже точно завершился. Зачем писать это второй раз?
                                                      </div></div></div></div>
                                                              </div><div class="comment-layout"><div class="comment-wrap"><div class="comment"><span class="ava__wrapper"><a href="https://javarush.ru/users/2392258" target="_blank" class="ava" tabindex="-1" style="background-image: url('https://cdn.javarush.ru/images/avatar/2392258/64.webp')"><span></span></a></span>
                                                          <div class="comment-head"><div class="head-left"><a href="https://javarush.ru/users/2392258" target="_blank" class="user">Erik</a>
                                                              <span class="more-info">25
                                                                уровень, Новосибирск</span>



                                                              </div>
                                                            <div class="head-right"><span class="date">9 августа 2020</span>
                                                              </div></div>
                                                          <div class="comment-body"><div class="view-text">После просмотра видеоролика больше вопросов, чем ответов, во всяком случае у меня.</div></div></div></div>
                                                              </div></div></div></div></div></article></div></div></div>
                                                                <div class="site-layout__footer"><div class="footer-wrap"><footer class="site-footer site-footer--common"><div class="site-footer__container"><div class="site-footer__nav"><div class="site-footer__nav-section"><div class="site-footer-nav-wrap"><div class="site-footer-nav"><div class="site-footer-nav__head">Обучение</div>
                                                          <ul class="site-footer-nav__list"><li class="site-footer-nav__item"><a href="https://javarush.ru/quests" class="site-footer-nav__link">Курс Java</a>
                                                              </li><li class="site-footer-nav__item"><a href="https://javarush.ru/quests/QUEST_HARVARD_CS50" class="site-footer-nav__link">Курс Harvard CS50</a>
                                                              </li><li class="site-footer-nav__item"><a href="https://javarush.ru/quests/QUEST_GOOGLE_ANDROID" class="site-footer-nav__link">Курс по Android</a>
                                                              </li><li class="site-footer-nav__item"><a href="https://javarush.ru/internship" class="site-footer-nav__link">Стажировка</a>
                                                              </li><li class="site-footer-nav__item"><a href="https://javarush.ru/help" class="site-footer-nav__link">Помощь по задачам</a>
                                                              </li><li class="site-footer-nav__item"><a href="https://javarush.ru/prices" class="site-footer-nav__link">Подписки</a>
                                                              </li><li class="site-footer-nav__item"><a href="https://javarush.ru/projects/games" class="site-footer-nav__link">Задачи-игры</a>
                                                              </li></ul></div></div></div>
                                                              <div class="site-footer__nav-section"><div class="site-footer-nav-wrap"><div class="site-footer-nav"><div class="site-footer-nav__head">Сообщество</div>
                                                          <ul class="site-footer-nav__list"><li class="site-footer-nav__item"><a href="https://javarush.ru/users" class="site-footer-nav__link">Пользователи</a>
                                                              </li><li class="site-footer-nav__item"><a href="https://javarush.ru/groups/posts" class="site-footer-nav__link">Статьи</a>
                                                              </li><li class="site-footer-nav__item"><a href="https://javarush.ru/forum" class="site-footer-nav__link">Форум</a>
                                                              </li><li class="site-footer-nav__item"><a href="https://javarush.ru/chat" class="site-footer-nav__link">Чат</a>
                                                              </li><li class="site-footer-nav__item"><a href="https://javarush.ru/groups/stories" class="site-footer-nav__link">Истории успеха</a>
                                                              </li><li class="site-footer-nav__item"><a href="https://javarush.ru/news" class="site-footer-nav__link">Активности</a>
                                                              </li><li class="site-footer-nav__item"><a href="https://javarush.ru/search/post?query=конкурс от JavaRush" class="site-footer-nav__link">Конкурсы</a>
                                                              </li></ul></div></div></div>
                                                              <div class="site-footer__nav-section"><div class="site-footer-nav-wrap"><div class="site-footer-nav"><div class="site-footer-nav__head">О нас</div>
                                                          <ul class="site-footer-nav__list"><li class="site-footer-nav__item"><a href="https://javarush.ru/about/mission" class="site-footer-nav__link">О JavaRush</a>
                                                              </li><li class="site-footer-nav__item"><a href="https://javarush.ru/about/contacts" class="site-footer-nav__link">Контакты</a>
                                                              </li><li class="site-footer-nav__item"><a href="https://javarush.ru/about/reviews" class="site-footer-nav__link">Отзывы</a>
                                                              </li><li class="site-footer-nav__item"><a href="https://javarush.ru/about/faq" class="site-footer-nav__link">FAQ</a>
                                                              </li><li class="site-footer-nav__item"><a href="https://javarush.ru/dialogues/administration" class="site-footer-nav__link">Поддержка</a>
                                                              </li></ul></div></div></div>
                                                              <div class="site-footer__nav-section"><div class="site-footer-nav-wrap"><div class="site-footer-nav"><div class="site-footer-nav__head">Видео</div>
                                                          <ul class="site-footer-nav__list"><li class="site-footer-nav__item"><a href="https://javarush.ru/groups/posts/557-uroki-programmirovanija-na-java#3-top-features-javarush" class="site-footer-nav__link">Топ-3 фичи JavaRush</a>
                                                              </li><li class="site-footer-nav__item"><a href="https://javarush.ru/groups/posts/557-uroki-programmirovanija-na-java#section-course" class="site-footer-nav__link">Раздел «Курс»</a>
                                                              </li><li class="site-footer-nav__item"><a href="https://javarush.ru/groups/posts/557-uroki-programmirovanija-na-java#section-help" class="site-footer-nav__link">Раздел «Помощь»</a>
                                                              </li><li class="site-footer-nav__item"><a href="https://javarush.ru/groups/posts/2052-razdel-igrih-na-javarush-chastjh-1-populjarnihe-voprosih#section-game" class="site-footer-nav__link">Раздел «Игры»</a>
                                                              </li><li class="site-footer-nav__item"><a href="https://javarush.ru/groups/posts/557-uroki-programmirovanija-na-java#3ide" class="site-footer-nav__link">3 IDE</a>
                                                              </li><li class="site-footer-nav__item"><a href="https://javarush.ru/groups/posts/557-uroki-programmirovanija-na-java#light_theme" class="site-footer-nav__link">Светлая тема сайта</a>
                                                              </li></ul></div></div></div></div>

                                                            <div class="site-footer__social-and-copyright"><div class="site-footer__social"><div class="social-links"><ul class="social-links__list"><li class="social-links__item"><a class="social-links__link social-links__link--vk" href="https://vk.com/javarush" target="_blank"><svg class="icon icon--social-vk" aria-hidden="true"><use xlink:href="/sapper/assets/icons/social.svg?v=19#icon-vk"></use></svg></a></li>
                                                          <li class="social-links__item"><a class="social-links__link social-links__link--facebook" href="https://www.facebook.com/www.javarush.ru/" target="_blank"><svg class="icon icon--social-facebook" aria-hidden="true"><use xlink:href="/sapper/assets/icons/social.svg?v=19#icon-facebook"></use></svg></a></li>
                                                          <li class="social-links__item"><a class="social-links__link social-links__link--linkedin" href="https://www.linkedin.com/company/javarush/" target="_blank"><svg class="icon icon--social-linkedin" aria-hidden="true"><use xlink:href="/sapper/assets/icons/social.svg?v=19#icon-linkedin"></use></svg></a></li>
                                                          <li class="social-links__item"><a class="social-links__link social-links__link--twitter" href="https://twitter.com/javarush_ru" target="_blank"><svg class="icon icon--social-twitter" aria-hidden="true"><use xlink:href="/sapper/assets/icons/social.svg?v=19#icon-twitter"></use></svg></a></li>
                                                          <li class="social-links__item"><a class="social-links__link social-links__link--youtube" href="https://www.youtube.com/channel/UCMcDsSeqS531-HKz6GiJgtA" target="_blank"><svg class="icon icon--social-youtube" aria-hidden="true"><use xlink:href="/sapper/assets/icons/social.svg?v=19#icon-youtube"></use></svg></a></li>
                                                          <li class="social-links__item"><a class="social-links__link social-links__link--instagram" href="https://www.instagram.com/javarush_photo/" target="_blank"><svg class="icon icon--social-instagram" aria-hidden="true"><use xlink:href="/sapper/assets/icons/social.svg?v=19#icon-instagram"></use></svg></a></li>
                                                          <li class="social-links__item"><a class="social-links__link social-links__link--telegram" href="https://t.me/javarush_original" target="_blank"><svg class="icon icon--social-telegram" aria-hidden="true"><use xlink:href="/sapper/assets/icons/social.svg?v=19#icon-telegram"></use></svg></a></li></ul></div></div>
                                                              <div class="site-footer__acceptance"><div class="footer-acceptance"><img class="footer-acceptance__item" src="/sapper/assets/images/site/payment-systems/visa.svg" alt="Visa">
                                                        <img class="footer-acceptance__item" src="/sapper/assets/images/site/payment-systems/mastercard.svg" alt="Mastercard"></div></div>
                                                              <div class="site-footer__copyright site-footer__copyright--desktop">© 2021 JavaRush <span class="site-footer__tagline">«Программистами не рождаются»</span></div></div>

                                                            <div class="site-footer__copyright site-footer__copyright--mobile">© 2021 JavaRush <span class="site-footer__tagline">«Программистами не рождаются»</span></div></div></footer></div></div></div></div></div></div></main></div> <!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1" name=viewport> <meta content=#333333 name=theme-color> <link href=https://www.googletagmanager.com rel=preconnect> <link href=https://www.google-analytics.com rel=preconnect> <base href="/"> <link href=/sapper/assets/global.min.css rel=stylesheet> <link href=/sapper/assets/favicon/apple-icon-57x57.png rel=apple-touch-icon sizes=57x57> <link href=/sapper/assets/favicon/apple-icon-60x60.png rel=apple-touch-icon sizes=60x60> <link href=/sapper/assets/favicon/apple-icon-72x72.png rel=apple-touch-icon sizes=72x72> <link href=/sapper/assets/favicon/apple-icon-76x76.png rel=apple-touch-icon sizes=76x76> <link href=/sapper/assets/favicon/apple-icon-114x114.png rel=apple-touch-icon sizes=114x114> <link href=/sapper/assets/favicon/apple-icon-120x120.png rel=apple-touch-icon sizes=120x120> <link href=/sapper/assets/favicon/apple-icon-144x144.png rel=apple-touch-icon sizes=144x144> <link href=/sapper/assets/favicon/apple-icon-152x152.png rel=apple-touch-icon sizes=152x152> <link href=/sapper/assets/favicon/apple-icon-180x180.png rel=apple-touch-icon sizes=180x180> <link href=/sapper/assets/favicon/android-icon-192x192.png rel=icon sizes=192x192 type=image/png> <link href=/sapper/assets/favicon/favicon-32x32.png rel=icon sizes=32x32 type=image/png> <link href=/sapper/assets/favicon/favicon-96x96.png rel=icon sizes=96x96 type=image/png> <link href=/sapper/assets/favicon/favicon-16x16.png rel=icon sizes=16x16 type=image/png> <script>__SAPPER__={baseUrl:"",preloaded:[(function(a,b){return {me:{id:2496069,key:"anonymous#2496070",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2496069\u002Foriginal.jpeg",displayName:"Fomin Dmitriy",prefferedLanguage:"RU",level:17,sublevel:9,blackMatter:608,rating:144,country:a,city:"Москва",isMailSet:b,isPasswordSet:b,email:"necronaft@mail.ru",phone:a,statusCode:"active",statusMessage:a,premiumStatus:"PREMIUM",roleStatus:"USER",userFeatures:["QUEST_JAVA_SYNTAX","QUEST_JAVA_SYNTAX_LOW","QUEST_JAVA_SYNTAX_HEIGHT","QUEST_JAVA_CORE","QUEST_JAVA_MULTITHREADING","QUEST_JAVA_COLLECTIONS","QUEST_GAMES","TASK_VALIDATION_INFO","TASK_VALIDATION_RECOMMENDATION_INFO","TASK_EXECUTION_INFO","TASK_COMPILATION_INFO","BONUS_TASKS","PRIORITY_VERIFICATION","FORUM_INVITATION","SMART_WEB_EDITOR","TASK_SAVING","QUEST_TUTORIAL"]},sideBarMode:"FULL",currentPath:"groups\u002Fposts\u002F1993-mnogopotochnostjh-chto-delajut-metodih-klassa-thread",isSaleActive:false}}(null,true)),null,null,(function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,_,$,aa,ab,ac,ad,ae,af,ag,ah,ai,aj,ak,al,am,an,ao,ap,aq,ar,as,at,au,av,aw,ax,ay,az,aA,aB,aC,aD,aE,aF,aG,aH,aI,aJ,aK,aL,aM,aN,aO,aP,aQ){return {me:{id:2496069,key:"anonymous#2496070",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2496069\u002Foriginal.jpeg",displayName:"Fomin Dmitriy",prefferedLanguage:"RU",level:o,sublevel:9,blackMatter:608,rating:144,country:a,city:p,isMailSet:ac,isPasswordSet:ac,email:"necronaft@mail.ru",phone:a,statusCode:"active",statusMessage:a,premiumStatus:"PREMIUM",roleStatus:"USER",userFeatures:["QUEST_JAVA_SYNTAX","QUEST_JAVA_SYNTAX_LOW","QUEST_JAVA_SYNTAX_HEIGHT","QUEST_JAVA_CORE","QUEST_JAVA_MULTITHREADING","QUEST_JAVA_COLLECTIONS","QUEST_GAMES","TASK_VALIDATION_INFO","TASK_VALIDATION_RECOMMENDATION_INFO","TASK_EXECUTION_INFO","TASK_COMPILATION_INFO","BONUS_TASKS","PRIORITY_VERIFICATION","FORUM_INVITATION","SMART_WEB_EDITOR","TASK_SAVING","QUEST_TUTORIAL"]},post:{id:1993,key:"1993-mnogopotochnostjh-chto-delajut-metodih-klassa-thread",title:R,description:"Привет! Сегодня продолжаем говорить о многопоточности. Рассмотрим класс Thread и работу его нескольких методов. Раньше, когда мы изучали методы класса, чаще всего просто писали это так: «название метода» -&gt; «что он делает». С методами Thread так не получится :) ...",content:"Привет! Сегодня продолжаем говорить о многопоточности. Рассмотрим класс Thread и работу его нескольких методов. Раньше, когда мы изучали методы класса, чаще всего просто писали это так: «название метода» -\u003E «что он делает».\n\u003Cdiv class='row justify-content-center jr-image-wrap'\u003E\u003Cdiv class='col-12 col-sm-10 col-md-8'\u003E\u003Cimg data-id=\"a721b583-c502-4047-b2d9-a49895b5a89a\" data-max-width=\"710\" alt=\"Многопоточность: что делают методы класса Thread - 1\" data-src=\"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Farticle\u002Fa721b583-c502-4047-b2d9-a49895b5a89a\u002F1024.jpeg\"\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003EС методами Thread так не получится :) Их логика сложнее, и без нескольких примеров не разобраться. \n\n\u003Ch2\u003EМетод Thread.start()\u003C\u002Fh2\u003EНачнем с повторения. Как ты наверняка помнишь, создать поток можно унаследовав свой класс от класса \u003Ccode\u003EThread\u003C\u002Fcode\u003E и переопределив в нем метод \u003Ccode\u003Erun()\u003C\u002Fcode\u003E.\n\nНо сам он, конечно, не запустится. Для этого у нашего объекта вызываем метод \u003Ccode\u003Estart()\u003C\u002Fcode\u003E.\n\u003Cimg data-id=\"b9b6e5a5-b771-4c79-8122-2e453ab57ace\" data-max-width=\"850\" alt=\"Многопоточность: что делают методы класса Thread - 2\" data-src=\"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Farticle\u002Fb9b6e5a5-b771-4c79-8122-2e453ab57ace\u002F1024.jpeg\"\u003EДавай вспомним пример из предыдущей лекции:\n\n\u003Cpre class='lang-java line-numbers'\u003E\u003Ccode\u003E\npublic class MyFirstThread extends Thread {\n\n   @Override\n   public void run() {\n       System.out.println(\"Выполнен поток \" + getName());\n   }\n}\n\n\npublic class Main {\n\n   public static void main(String[] args) {\n\n       for (int i = 0; i \u003C 10; i++) {\n           MyFirstThread thread = new MyFirstThread();\n           thread.start();\n       }\n   }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cem\u003E\u003Cstrong\u003EОбрати внимание:\u003C\u002Fstrong\u003E\u003C\u002Fem\u003E чтобы запустить поток, необходимо вызвать специальный метод \u003Ccode\u003Estart()\u003C\u002Fcode\u003E, а не метод \u003Ccode\u003Erun()\u003C\u002Fcode\u003E! Эту ошибку легко допустить, особенно в начале изучения многопоточности. \n\nЕсли в нашем примере ты 10 раз вызовешь у объекта метод \u003Ccode\u003Erun()\u003C\u002Fcode\u003E вместо \u003Ccode\u003Estart()\u003C\u002Fcode\u003E, результат будет таким:\n\n\u003Cpre class='lang-java line-numbers'\u003E\u003Ccode\u003E\npublic class Main {\n\n   public static void main(String[] args) {\n\n       for (int i = 0; i \u003C 10; i++) {\n           MyFirstThread thread = new MyFirstThread();\n           thread.run();\n       }\n   }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\n\u003Cem\u003E\u003Cstrong\u003EВыполнен поток Thread-0\nВыполнен поток Thread-1\nВыполнен поток Thread-2\nВыполнен поток Thread-3\nВыполнен поток Thread-4\nВыполнен поток Thread-5\nВыполнен поток Thread-6\nВыполнен поток Thread-7\nВыполнен поток Thread-8\nВыполнен поток Thread-9\u003C\u002Fstrong\u003E\u003C\u002Fem\u003E\n\nПосмотри на последовательность вывода: все идет строго по порядку. Странно, да? Мы к такому не привыкли, ведь уже знаем, что порядок запуска и выполнения потоков определяет сверхразум внутри нашей операционной системы — планировщик потоков. Может, просто повезло?\n\nКонечно, дело не в везении. В этом можешь убедиться, запустив программу еще пару раз.\n\nДело в том, что прямой вызов метода \u003Ccode\u003Erun()\u003C\u002Fcode\u003E не имеет отношения к многопоточности. В этом случае программа будет выполнена в главном потоке — том, в котором выполняется метод \u003Ccode\u003Emain()\u003C\u002Fcode\u003E. Он просто последовательно выведет 10 строк на консоль и все. Никакие 10 потоков не запустятся. \n\nПоэтому запомни на будущее и постоянно себя проверяй. Хочешь, чтобы выполнился \u003Ccode\u003Erun()\u003C\u002Fcode\u003E, вызывай \u003Ccode\u003Estart()\u003C\u002Fcode\u003E. Поехали дальше.\n\n\u003Ch2\u003EМетод Thread.sleep()\u003C\u002Fh2\u003EДля приостановки выполнения текущего потока на какое-то время, используем метод \u003Ccode\u003Esleep()\u003C\u002Fcode\u003E.\n\u003Cimg data-id=\"1e9f01d2-6dba-4189-9bf6-121c25c29110\" data-max-width=\"850\" alt=\"Многопоточность: что делают методы класса Thread - 3\" data-src=\"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Farticle\u002F1e9f01d2-6dba-4189-9bf6-121c25c29110\u002F1024.jpeg\"\u003EМетод \u003Ccode\u003Esleep()\u003C\u002Fcode\u003E принимает в качестве параметра число миллисекунд, то есть то время, на которое необходимо «усыпить» поток.\n\n\u003Cpre class='lang-java line-numbers'\u003E\u003Ccode\u003E\npublic class Main {\n\n   public static void main(String[] args) throws InterruptedException {\n\n       long start = System.currentTimeMillis();\n\n       Thread.sleep(3000);\n\n       System.out.println(\" - Сколько я проспал? \\n - \" + ((System.currentTimeMillis()-start)) \u002F 1000 + \" секунды\");\n\n   }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cstrong\u003EВывод в консоль:\n\n\u003Cem\u003E - Сколько я проспал? \n - 3 секунды\u003C\u002Fem\u003E\u003C\u002Fstrong\u003E\n\nОбрати внимание: метод \u003Ccode\u003Esleep()\u003C\u002Fcode\u003E — статический: он усыпляет текущий поток. То есть тот, который работает в данный момент.\n\nЕще один важный нюанс: поток в состоянии сна можно прервать. В таком случае в программе возникнет исключение \u003Ccode\u003EInterruptedException\u003C\u002Fcode\u003E. Мы рассмотрим пример ниже.\n\nКстати, а что произойдет после того, как поток «проснется»? Продолжит ли он сразу же свое выполнение с того места, где закончил? Нет.\n\nПосле того, как поток «просыпается» — когда заканчивается время, переданное в качестве аргумента в \u003Ccode\u003EThread.sleep()\u003C\u002Fcode\u003E, — он переходит в состояние \u003Cem\u003Erunnable\u003C\u002Fem\u003E, «работоспособный». Однако это не значит, что планировщик потоков запустит именно его. Вполне возможно, он отдаст предпочтение какому-то другому «неспящему» потоку, а наш «свежепроснувшийся» продолжит работу чуть позже.\n\nОбязательно запомни: «проснулся — не значит продолжил работать в ту же секунду»!\n\n\u003Ch2\u003EМетод Thread.join()\u003C\u002Fh2\u003E\u003Cimg data-id=\"c3c0548b-4341-4b3f-a577-44ba15c84b23\" data-max-width=\"850\" alt=\"Многопоточность: что делают методы класса Thread - 4\" data-src=\"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Farticle\u002Fc3c0548b-4341-4b3f-a577-44ba15c84b23\u002F1024.jpeg\"\u003EМетод \u003Ccode\u003Ejoin()\u003C\u002Fcode\u003E приостанавливает выполнение текущего потока до тех пор, пока не завершится другой поток.\n\nЕсли у нас есть 2 потока, \u003Ccode\u003Et1\u003C\u002Fcode\u003E и \u003Ccode\u003Et2\u003C\u002Fcode\u003E, и мы напишем —\n\n\u003Cpre class='lang-java line-numbers'\u003E\u003Ccode\u003E\nt1.join()\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ccode\u003Et2\u003C\u002Fcode\u003E не начнет работу, пока t1 не завершит свою. Метод \u003Ccode\u003Ejoin()\u003C\u002Fcode\u003E можно использовать, чтобы гарантировать последовательность выполнения потоков. \n\nДавай рассмотрим работу \u003Ccode\u003Ejoin()\u003C\u002Fcode\u003E на примере:\n\n\u003Cpre class='lang-java line-numbers'\u003E\u003Ccode\u003E\npublic class ThreadExample extends Thread {\n\n   @Override\n   public void run() {\n\n       System.out.println(\"Начало работы потока \" + getName());\n\n       try {\n           Thread.sleep(5000);\n       } catch (InterruptedException e) {\n           e.printStackTrace();\n       }\n       System.out.println(\"Поток \" + getName() +  \" завершил работу.\");\n   }\n}\n\n\npublic class Main {\n\n   public static void main(String[] args) throws InterruptedException {\n\n       ThreadExample t1 = new ThreadExample();\n       ThreadExample t2 = new ThreadExample();\n\n       t1.start();\n\n      \n \u002F*Второй поток t2 начнет выполнение только после того, как будет завершен\n       (или бросит исключение) первый поток - t1*\u002F\n       try {\n           t1.join();\n       } catch (InterruptedException e) {\n           e.printStackTrace();\n       }\n\n       t2.start();\n\n       \u002F\u002FГлавный поток продолжит работу только после того, как t1 и t2 завершат работу\n       try {\n           t1.join();\n           t2.join();\n       } catch (InterruptedException e) {\n           e.printStackTrace();\n       }\n\n       System.out.println(\"Все потоки закончили работу, программа завершена\");\n\n   }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\nМы создали простой класс \u003Ccode\u003EThreadExample\u003C\u002Fcode\u003E. Его задача — вывести на экран сообщение о начале работы, потом уснуть на 5 секунд и в конце сообщить о завершении работы. Ничего сложного.\n\nГлавная логика заключена в классе \u003Ccode\u003EMain\u003C\u002Fcode\u003E. Посмотри на комментарии: с помощью метода \u003Ccode\u003Ejoin()\u003C\u002Fcode\u003E мы успешно управляем последовательностью выполнения потоков. Если ты вспомнишь начало темы, этим занимался планировщик потоков. Он запускал их на свое усмотрение: каждый раз по-разному. \n\nЗдесь же мы с помощью метода гарантировали, что сначала будет запущен и выполнен поток \u003Ccode\u003Et1\u003C\u002Fcode\u003E, затем — \u003Ccode\u003Et2\u003C\u002Fcode\u003E, и только после них — главный поток выполнения программы.  \n\nИдем дальше.\n\nВ реальных программах тебе не раз встретятся ситуации, когда необходимо будет прервать выполнение какого-то потока.\n\nНапример, наш поток выполняется, но при этом ждет определенного события или выполнения условия. Если это произошло, он останавливается. Было бы, наверное, логично, если бы существовал какой-то метод типа \u003Ccode\u003Estop()\u003C\u002Fcode\u003E.\n\nОднако все не так просто. Когда-то давно метод \u003Ccode\u003E\u003Cstrong\u003EThread.stop()\u003C\u002Fstrong\u003E\u003C\u002Fcode\u003E в Java действительно был и позволял прерывать работу потока. Но позже его удалили из библиотеки Java. Ты можешь найти его в документации Oracle и увидеть, что он помечен как \u003Cem\u003Edeprecated\u003C\u002Fem\u003E.\n\nПочему? Потому что он просто останавливал поток без какой-либо дополнительной работы. \n\nНапример, поток мог работать с данными и что-то в них менять. Потом его резко вырубали методом \u003Ccode\u003Estop()\u003C\u002Fcode\u003E посреди работы — и все. Ни корректного завершения работы, ни освобождения ресурсов, ни хотя бы обработки ошибок — ничего этого не было.\n\nМетод \u003Ccode\u003Estop()\u003C\u002Fcode\u003E, если утрировать, просто крушил все на своем пути.\n\nЕго работу можно сравнить с тем, как кто-то выдергивает вилку из розетки, чтобы выключить компьютер. Да, нужного результата добиться можно. Но все понимают, что через пару недель компьютер не скажет за это «спасибо».\n\nПо этой причине логику прерывания потоков в Java изменили, и теперь используется специальный метод — \u003Ccode\u003Einterrupt()\u003C\u002Fcode\u003E.\n\n\u003Ch2\u003EМетод Thread.interrupt()\u003C\u002Fh2\u003EЧто произойдет, если у потока вызвать \u003Cstrong\u003Eметод\u003C\u002Fstrong\u003E \u003Ccode\u003E\u003Cstrong\u003Einterrupt()\u003C\u002Fstrong\u003E\u003C\u002Fcode\u003E?\n\nЕсть 2 варианта:\n\n\u003Col\u003E\n\u003Cli\u003EЕсли объект находился в этот момент в состоянии ожидания, например, \u003Ccode\u003Ejoin\u003C\u002Fcode\u003E или \u003Ccode\u003Esleep\u003C\u002Fcode\u003E, ожидание будет прервано, и программа выбросит \u003Ccode\u003EInterruptedException\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\n\u003Cli\u003EЕсли же поток в этот момент был в работоспособном состоянии, у объекта будет установлен boolean-флаг \u003Ccode\u003E\u003Cstrong\u003Einterrupted\u003C\u002Fstrong\u003E\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\u003C\u002Fol\u003E\nНо проверить объект на значение этого флага и корректно завершить работу мы должны будем самостоятельно! Для этого в классе \u003Ccode\u003EThread\u003C\u002Fcode\u003E есть специальный метод — \u003Ccode\u003E\u003Cstrong\u003Eboolean isInterrupted()\u003C\u002Fstrong\u003E\u003C\u002Fcode\u003E.\n\nДавай вернемся к примеру с часами, который был в лекции основного курса. Для удобства он немного упрощен:\n\n\u003Cpre class='lang-java line-numbers'\u003E\u003Ccode\u003E\npublic class Clock extends Thread {\n\n   public static void main(String[] args) throws InterruptedException {\n       Clock clock = new Clock();\n       clock.start();\n\n       Thread.sleep(10000);\n       clock.interrupt();\n   }\n\n   public void run() {\n       Thread current = Thread.currentThread();\n\n       while (!current.isInterrupted())\n       {\n           try {\n               Thread.sleep(1000);\n           } catch (InterruptedException e) {\n               System.out.println(\"Работа потока была прервана\");\n               break;\n           }\n           System.out.println(\"Tik\");\n       }\n   }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\nВ нашем случае часы стартуют и начинают тикать каждую секунду. На 10-й секунде мы прерываем поток часов.\n\nКак ты уже знаешь, если поток, который мы пытаемся прервать, находится в одном из состояний ожидания, это приводит к \u003Ccode\u003EInterruptedException\u003C\u002Fcode\u003E. Данный вид исключения — проверяемый, поэтому его можно легко перехватить и выполнить нашу логику завершения программы. Что мы и сделали.\n\n\u003Cstrong\u003EВот наш результат:\u003C\u002Fstrong\u003E\n\n\u003Cem\u003E\u003Cstrong\u003ETik\nTik\nTik\nTik\nTik\nTik\nTik\nTik\nTik\u003C\u002Fstrong\u003E\u003C\u002Fem\u003E\n\nРабота потока была прервана\n\nНа этом мы заканчиваем знакомство с основными методами класса \u003Ccode\u003EThread\u003C\u002Fcode\u003E.\n\nЧтобы закрепить знания, можешь посмотреть эту видеолекцию о многопоточности: \n\u003Cdiv class=\"row\"\u003E\n\u003Cdiv class=\"col col-md-10 col-lg-8\"\u003E\n\u003Cdiv class=\"embed-responsive embed-responsive-16by9\"\u003E\n\u003Ciframe width=\"560\" height=\"315\" src=\"https:\u002F\u002Fwww.youtube.com\u002Fembed\u002FzxZ0BXlTys0\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen\u003E\u003C\u002Fiframe\u003E\n\u003C\u002Fdiv\u003E\n\u003C\u002Fdiv\u003E\n\u003C\u002Fdiv\u003Eона послужит отличным дополнительным материалом! В конце, после обзора методов, в ней рассказывается как раз о том, что мы будем проходить дальше по курсу :)\n\nУспехов!",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Farticle\u002Fa11feba5-e610-4125-bce8-a8e73bc30eb6\u002Foriginal.jpeg",type:"USUAL",views:47142,commentsCount:ad,createdTime:1538066518000,updatedTime:1542273830593,rating:4.978201634877384,ratingCount:367,originalGroupInfo:{id:S,key:"java-developer",type:"TECH",title:"Java Developer",description:"Мы все тут очень любим Java! Уверены, ты тоже полюбишь, когда углубишься в самые дебри и познаешь истинные возможности этого языка! Присоединяйся! В нашей группе — статьи и новости о Java, информация о работе Java-программистом, общение, обсуждение вопросов и многое другое.",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Fsystem\u002F243fcb29-d895-4f94-b537-b4c08d29d6ce\u002Foriginal.jpeg",avatarUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Fsystem\u002F7bfe9928-c13b-4658-8cce-ab42a8907ea4\u002Foriginal.jpeg",usersCount:28028,meGroupInfo:a,levelToEditor:ae,visibilityStatus:c,userDiscussionInfo:a,commentsCount:a},groupInfo:a,authorInfo:{id:af,userId:af,key:"anonymous#1770672",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F1770672\u002Foriginal.png",displayName:"Professor Hans Noodles",position:a,job:a,country:a,city:a,level:41,rating:11,publicStatus:"HAVE_JOB",publicStatusMessage:a},likesInfo:{count:410,status:a},visibilityStatus:c,userDiscussionInfo:a},comments:[{id:ag,time:1608667685026,message:"Прошу прощения но в следующем предложении, кажется содержится ошибка - \"Метод join() приостанавливает выполнение текущего потока до тех пор, пока не завершится другой поток.\"",owner:{id:F,userId:F,key:ah,pictureUrl:m,displayName:ai,position:a,job:a,country:d,city:d,level:k,rating:aj,publicStatus:i,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:a,status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:a,childrenComments:[{id:647981,time:1609249119870,message:"А в чём ошибка? \nТы в первом потоке прописываешь join() с указанием второго потока. И пока второй поток не завершится - первый ждёт, т.е. не будет идти дальше по коду.",owner:{id:ak,userId:ak,key:"anonymous#2444882",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Fanonymous.svg?1604407903641",displayName:"Veygard",position:a,job:a,country:d,city:p,level:S,rating:323,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:F,userId:F,key:ah,pictureUrl:m,displayName:ai,position:a,job:a,country:d,city:d,level:k,rating:aj,publicStatus:i,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:ag,childrenComments:a,likes:{count:h,status:a}}],likes:{count:h,status:a}},{id:634544,time:1607366363821,message:"По-моему это лишнее\n   Thread current = Thread.currentThread();\n\nМожно просто написать :\n\n    public void run() {\n        while (!isInterrupted())\n        {\n     \u002F\u002F\u002Fкод\n        }\n    }\n\n",owner:{id:al,userId:al,key:"anonymous#2181104",pictureUrl:m,displayName:"Игорь",position:a,job:a,country:a,city:am,level:26,rating:259,publicStatus:i,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:a,status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:a,childrenComments:[],likes:{count:h,status:a}},{id:634375,time:1607352553780,message:"фух.... насколько же мне проще читать текст, чем слушать лектора....  хотя он и шире излагает, но это прям на морально волевых... ",owner:{id:an,userId:an,key:"anonymous#2275993",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2275993\u002Foriginal.jpeg",displayName:"Максим Дудин",position:a,job:a,country:a,city:"Калининград",level:S,rating:487,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:a,status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:a,childrenComments:[],likes:{count:h,status:a}},{id:ao,time:1606152307397,message:"\"Но проверить объект на значение этого флага и корректно завершить работу мы должны будем самостоятельно!\"\n\nтак как же завершить поток?",owner:{id:G,userId:G,key:ap,pictureUrl:m,displayName:aq,position:a,job:a,country:d,city:ar,level:C,rating:as,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:a,status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:a,childrenComments:[{id:625290,time:1606153232278,message:"Нужно, чтобы метод run полностью выполнился:\n\u003Cpre class=\"language-java line-numbers\"\u003E\u003Ccode\u003E\npublic void run() {\n       Thread current = Thread.currentThread();\n\n       while (!current.isInterrupted())\n       {\n           try {\n               Thread.sleep(1000);\n           } catch (InterruptedException e) {\n               System.out.println(\"Работа потока была прервана\");\n               break;\n           }\n           System.out.println(\"Tik\");\n       }\n   }\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\nВ этом примере программа находится в постоянном цикле, пока значение флага false. Как только он становится true, цикл while завершается, далее в коде больше нет команд, так что и метод run() тоже завершается, ну а вместе с ним и поток.",owner:{id:at,userId:at,key:"anonymous#2328485",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2328484\u002Foriginal.jpeg",displayName:"Гордей",position:a,job:a,country:a,city:a,level:27,rating:483,publicStatus:i,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:G,userId:G,key:ap,pictureUrl:m,displayName:aq,position:a,job:a,country:d,city:ar,level:C,rating:as,publicStatus:f,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:ao,childrenComments:a,likes:{count:h,status:a}}],likes:{count:h,status:a}},{id:H,time:1604054471820,message:"Заинтересовала разница между volatile и synchronized.\nНасколько я понял для себя - основное отличие это, то что volatile применяется только для полей(fields), а synchronized применяется для классов, экземпляров и блоков кода{}. Смысл же один - обеспечить одномоментный доступ к ресурсу.\n\nТолько вот понятно, что synchronized захватывает флаг(?) monitor. А вот механизм работы volatile не понятен мне пока. Иду гуглить)\n\nПоправьте, если где ошибся.",owner:{id:q,userId:q,key:I,pictureUrl:J,displayName:K,position:d,job:a,country:g,city:L,level:r,rating:M,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:a,status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:a,childrenComments:[{id:624109,time:1605972563249,message:"Насколько я знаю volatile используется в том случае, если только 1 поток записывает данные в переменную,в то время как остальные считывают их оттуда.Volatile используется для запрета кеширования этой переменной.Поправь если не так.",owner:{id:D,userId:D,key:T,pictureUrl:U,displayName:V,position:d,job:d,country:g,city:p,level:C,rating:W,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:q,userId:q,key:I,pictureUrl:J,displayName:K,position:d,job:a,country:g,city:L,level:r,rating:M,publicStatus:f,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:H,childrenComments:a,likes:{count:h,status:a}},{id:625105,time:1606137159877,message:"Похоже, что именно так всё и устроено.\n\u003Ca href=\"https:\u002F\u002Furvanov.ru\u002F2017\u002F07\u002F20\u002F%D0%B7%D0%B0%D1%87%D0%B5%D0%BC-%D0%BD%D1%83%D0%B6%D0%BD%D0%BE-volatile-%D0%B2-java\u002F\" target=\"_blank\" rel=\"nofollow\"\u003EСтатейка на тему\u003C\u002Fa\u003E",owner:{id:q,userId:q,key:I,pictureUrl:J,displayName:K,position:d,job:a,country:g,city:L,level:r,rating:M,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:D,userId:D,key:T,pictureUrl:U,displayName:V,position:d,job:d,country:g,city:p,level:C,rating:W,publicStatus:f,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:H,childrenComments:a,likes:{count:h,status:a}},{id:625377,time:1606159804782,message:"спасибо за статью",owner:{id:D,userId:D,key:T,pictureUrl:U,displayName:V,position:d,job:d,country:g,city:p,level:C,rating:W,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:q,userId:q,key:I,pictureUrl:J,displayName:K,position:d,job:a,country:g,city:L,level:r,rating:M,publicStatus:f,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:H,childrenComments:a,likes:{count:h,status:a}}],likes:{count:h,status:a}},{id:X,time:1602870715931,message:"В одних примерах метод прерывается командой break; в других return;\nЕсть между ними разница?",owner:{id:E,userId:E,key:Y,pictureUrl:Z,displayName:_,position:a,job:a,country:d,city:$,level:r,rating:aa,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:a,status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:a,childrenComments:[{id:603471,time:1603068308986,message:"Команда break прерывает работу \u003Cstrong\u003Eцикла\u003C\u002Fstrong\u003E, а return прерывает работу \u003Cstrong\u003Eметода\u003C\u002Fstrong\u003E",owner:{id:au,userId:au,key:"anonymous#2399651",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2399651\u002Foriginal.jpeg",displayName:"Merch",position:"Студент",job:"uio",country:"Узбекистан",city:"Ташкент",level:k,rating:423,publicStatus:i,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:E,userId:E,key:Y,pictureUrl:Z,displayName:_,position:a,job:a,country:d,city:$,level:r,rating:aa,publicStatus:f,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:X,childrenComments:a,likes:{count:ae,status:a}},{id:609602,time:1603914660967,message:"Оператор break приводит к завершению цикла, он выйдет из цикла и остановит дальнейшие итерации.\nReturn : Оператор return выводит вас из метода. Он прекращает выполнение метода и возвращается из выполнения метода.",owner:{id:av,userId:av,key:"anonymous#2421688",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2421688\u002Foriginal.jpeg",displayName:"Dara",position:"Software Developer",job:d,country:a,city:d,level:C,rating:654,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:E,userId:E,key:Y,pictureUrl:Z,displayName:_,position:a,job:a,country:d,city:$,level:r,rating:aa,publicStatus:f,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:X,childrenComments:a,likes:{count:aw,status:a}}],likes:{count:h,status:a}},{id:599969,time:1602596155517,message:"Почему не сказали что в последнем примере если не будет принудительного выхода ихз цикла break; то он будет вечным даже если мы его прервали? \nо том что контроль исключения на InterruptedException сбрасывает признак прерывания у потока и проверка на isInterrupted() вернет ложь Нужно было написать.\nДанный пример только вводит в заблуждение и показывает пример не оптимального кода.",owner:{id:ax,userId:ax,key:"anonymous#1812875",pictureUrl:m,displayName:ab,position:a,job:a,country:g,city:am,level:ay,rating:702,publicStatus:i,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:a,status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:a,childrenComments:[],likes:{count:1,status:a}},{id:n,time:1598172300280,message:"\u003Cpre class=\"lang-java line-numbers\"\u003E\u003Ccode\u003E\npublic class Main {\n\n   public static void main(String[] args) throws InterruptedException {\n\n       long start = System.currentTimeMillis();\n\n       Thread.sleep(3000);\n\n       System.out.println(\" - Сколько я проспал? \\n - \" + ((System.currentTimeMillis()-start)) \u002F 1000 + \" секунды\");\n\n   }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\nЯ немного запутался от большого объема информации, поправьте пожалуйста.\nМетод main у нас является единственным потоком в данном случае? С помощью метода sleep приостанавливается работа главного потока main  на 3 сек. А  метод start у нас используется, только тогда, когда в программе помимо основного потока main, есть дополнительные потоки, все верно? \n",owner:{id:j,userId:j,key:s,pictureUrl:t,displayName:u,position:a,job:a,country:g,city:v,level:o,rating:w,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:a,status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:a,childrenComments:[{id:567800,time:1598440026505,message:"Да, верно. main метод выполняется первым, по дефолту. \nОн является родительской нитью, которая может запускать другие нити. \nВ данном примере дочерних нитей нет, приостанавливается именно работа основного метода. \nthread.start - запускает дочернюю нить",owner:{id:N,userId:N,key:az,pictureUrl:aA,displayName:aB,position:a,job:a,country:g,city:p,level:k,rating:aC,publicStatus:i,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:j,userId:j,key:s,pictureUrl:t,displayName:u,position:a,job:a,country:g,city:v,level:o,rating:w,publicStatus:f,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:n,childrenComments:a,likes:{count:h,status:a}},{id:569597,time:1598634510740,message:"Спасибо! 👍",owner:{id:j,userId:j,key:s,pictureUrl:t,displayName:u,position:a,job:a,country:g,city:v,level:o,rating:w,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:N,userId:N,key:az,pictureUrl:aA,displayName:aB,position:a,job:a,country:g,city:p,level:k,rating:aC,publicStatus:i,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:n,childrenComments:a,likes:{count:h,status:a}},{id:573312,time:1599154658404,message:"Не совсем верно)\nВо первых формулировка: \n\u003Cem\u003EМетод main у нас является единственным потоком\u003C\u002Fem\u003E\nневерна) метод main не является потоком. Верно сказать, что наш классический метод main, является точкой входа в программу, коих может быть множество) и тот поток, который запускается с методом main, является главным)\n\n\u003Cem\u003E С помощью метода sleep приостанавливается работа главного потока main\u003C\u002Fem\u003E\nС помощью статического метода sleep, приостанавливается текущий поток, тот из которого метод sleep был вызван. Он может быть прописан, в методе run(), одного из наших дочерних потоков. Или где угодно еще. Важно, откуда происходит вызов. Для примера набросал немного:\n\u003Cpre class=\"lang-java line-numbers\"\u003E\u003Ccode\u003E\npublic class MainClass {\n    public static void main(String[] args) throws InterruptedException {\n        TestThread ourThread = new TestThread();\n        ourThread.current.sleep(1000);\n    }\n    \n    static class TestThread extends Thread {\n        Thread current;\n\n        public TestThread() {\n            start();\n        }\n\n        @Override\n        public void run() {\n            current = Thread.currentThread();\n            \n            while (!isInterrupted()) {\n                \u002F\u002F...\n            }\n        }\n    }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\nКак по вашему, какая нить остановится в данном случае?))\n\n\u003Cem\u003EА  метод start у нас используется, только тогда, когда в программе помимо основного потока main, есть дополнительные потоки, все верно? \u003C\u002Fem\u003E\nМетод start() используется не \"когда\") он вызывается у созданных вами потоков. Единожды, для того чтобы начать выполнение, переопределенного метода run()",owner:{id:l,userId:l,key:y,pictureUrl:z,displayName:A,position:a,job:a,country:d,city:x,level:k,rating:B,publicStatus:i,publicStatusMessage:a,isFriend:a,subscription:a,badge:O},answerTo:{id:j,userId:j,key:s,pictureUrl:t,displayName:u,position:a,job:a,country:g,city:v,level:o,rating:w,publicStatus:f,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:n,childrenComments:a,likes:{count:aD,status:a}},{id:573780,time:1599228133759,message:"В этом примере просто поясняется как работает sleep: здесь он просто добавляет время простоя к потоку метода main. Переменная long start сохраняет системное время в мс до выполнения метода statlc void sleep() класса java.lang.Thread \u003Ca href=\"https:\u002F\u002Fdocs.oracle.com\u002Fjavase\u002Ftutorial\u002Fessential\u002Fconcurrency\u002Fsleep.html\" target=\"_blank\" rel=\"nofollow\"\u003EPausing Execution with Sleep\u003C\u002Fa\u003E",owner:{id:aE,userId:aE,key:"anonymous#2395987",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2395987\u002Foriginal.jpeg?1605643663546",displayName:"jv.tab",position:a,job:a,country:g,city:p,level:r,rating:422,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:j,userId:j,key:s,pictureUrl:t,displayName:u,position:a,job:a,country:g,city:v,level:o,rating:w,publicStatus:f,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:n,childrenComments:a,likes:{count:h,status:a}},{id:574581,time:1599347602208,message:" \" тот поток, который запускается с методом main, является главным) \" . В лекции у нас 2 потока , t1 и t2, какой поток главный получается? Ни один из них? Там же в лекции написано \"\u002F\u002FГлавный поток продолжит работу только после того, как t1 и t2 завершат работу\". Спасибо за ответ.",owner:{id:j,userId:j,key:s,pictureUrl:t,displayName:u,position:a,job:a,country:g,city:v,level:o,rating:w,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:l,userId:l,key:y,pictureUrl:z,displayName:A,position:a,job:a,country:d,city:x,level:k,rating:B,publicStatus:i,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:n,childrenComments:a,likes:{count:h,status:a}},{id:575558,time:1599492323356,message:"У нас всегда есть основной поток, который мы не запускаем явно. В нем происходит основная работа нашей программы)\nt1 и t2 же - создаются программой явно из основного потока, в методе main(). Всё сходится, ни один из них, не главный)\nВы всё верно поняли) обращайтесь)",owner:{id:l,userId:l,key:y,pictureUrl:z,displayName:A,position:a,job:a,country:d,city:x,level:k,rating:B,publicStatus:i,publicStatusMessage:a,isFriend:a,subscription:a,badge:O},answerTo:{id:j,userId:j,key:s,pictureUrl:t,displayName:u,position:a,job:a,country:g,city:v,level:o,rating:w,publicStatus:f,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:n,childrenComments:a,likes:{count:aD,status:a}},{id:587589,time:1600955358666,message:"хорошее объяснение",owner:{id:aF,userId:aF,key:"facebook#1079488365436381",pictureUrl:m,displayName:"Andrei Po",position:a,job:a,country:a,city:a,level:ay,rating:503,publicStatus:"UNKNOWN",publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:l,userId:l,key:y,pictureUrl:z,displayName:A,position:a,job:a,country:d,city:x,level:k,rating:B,publicStatus:i,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:n,childrenComments:a,likes:{count:h,status:a}},{id:598733,time:1602423210287,message:"Метод  main как раз является потоком (вернее конечно же main содержит внутри себя поток, который создается автоматически при запуске программы), причем главным, если создаем 1 новый поток в своей программе, то у нас их будет 2, главный и побочный.\nИнтересное мнение по поводу входа в программу, не очень понятно как их может быть несколько, если метод main может быть только 1, и только с этого метода начинается выполнение",owner:{id:P,userId:P,key:aG,pictureUrl:m,displayName:ab,position:a,job:a,country:g,city:aH,level:k,rating:aI,publicStatus:i,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:l,userId:l,key:y,pictureUrl:z,displayName:A,position:a,job:a,country:d,city:x,level:k,rating:B,publicStatus:i,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:n,childrenComments:a,likes:{count:h,status:a}},{id:599205,time:1602496534225,message:"Методов main может быть бесчисленное множество - по количеству классов в вашей программе. Каждый может иметь свой метод main",owner:{id:l,userId:l,key:y,pictureUrl:z,displayName:A,position:a,job:a,country:d,city:x,level:k,rating:B,publicStatus:i,publicStatusMessage:a,isFriend:a,subscription:a,badge:O},answerTo:{id:P,userId:P,key:aG,pictureUrl:m,displayName:ab,position:a,job:a,country:g,city:aH,level:k,rating:aI,publicStatus:i,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:n,childrenComments:a,likes:{count:h,status:a}},{id:599462,time:1602520271202,message:"Но ведь при компиляции и запуске программы выбираем главный класс, main которого и запускается. + если вывести имя главного потока, там будет main)",owner:{id:aJ,userId:aJ,key:"github#31883252",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2302914\u002Foriginal.jpeg",displayName:"Darth Nihilus",position:a,job:a,country:a,city:"Planet Korriban",level:o,rating:296,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:j,userId:j,key:s,pictureUrl:t,displayName:u,position:a,job:a,country:g,city:v,level:o,rating:w,publicStatus:f,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:n,childrenComments:a,likes:{count:h,status:a}}],likes:{count:h,status:a}},{id:aK,time:1597594072402,message:"Пример по\u003Cstrong\u003E join()\u003C\u002Fstrong\u003E:\n\u003Cpre class=\"lang-java line-numbers\"\u003E\u003Ccode\u003E\n       \u002F\u002FГлавный поток продолжит работу только после того, как t1 и t2 завершат работу\n       try {\n           t1.join();\n           t2.join();\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\nНо ведь \u003Cstrong\u003Et1.join();\u003C\u002Fstrong\u003E уже было раньше, значит t1 уже точно завершился. Зачем писать это второй раз?\n",owner:{id:Q,userId:Q,key:aL,pictureUrl:m,displayName:aM,position:a,job:a,country:g,city:p,level:aN,rating:aO,publicStatus:i,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:a,status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:a,childrenComments:[{id:573315,time:1599154854515,message:"что для одного может быть очевидно, для другого может стать спасительным билетом) уж лучше так, вместо того, как иногда здесь бывает;)",owner:{id:l,userId:l,key:y,pictureUrl:z,displayName:A,position:a,job:a,country:d,city:x,level:k,rating:B,publicStatus:i,publicStatusMessage:a,isFriend:a,subscription:a,badge:O},answerTo:{id:Q,userId:Q,key:aL,pictureUrl:m,displayName:aM,position:a,job:a,country:g,city:p,level:aN,rating:aO,publicStatus:i,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:aK,childrenComments:a,likes:{count:h,status:a}}],likes:{count:aw,status:a}},{id:557274,time:1596976586534,message:"После просмотра видеоролика больше вопросов, чем ответов, во всяком случае у меня.",owner:{id:aP,userId:aP,key:"github#55682148",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2392258\u002Foriginal.jpeg",displayName:"Erik",position:a,job:a,country:g,city:x,level:25,rating:352,publicStatus:i,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:a,status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:a,childrenComments:[],likes:{count:h,status:a}}],siteMetaData:{title:R,description:aQ,ogTitle:R,ogDescription:aQ,ogPageUrl:"\u002Fgroups\u002Fposts\u002F1993-mnogopotochnostjh-chto-delajut-metodih-klassa-thread",ogPictureUrl:"https:\u002F\u002Fjavarush.ru\u002Fimages\u002Farticle\u002Fa7b37e99-94fd-4795-b95b-cb659ac50939\u002Foriginal.png"},commentsCount:ad}}(null,false,"PUBLIC","","UNVERIFIED","ACTIVE","Россия",0,"STRONG",2273741,22,2105047,"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Fanonymous.svg",565801,17,"Москва",2412909,20,"google#109464292040820866931","https:\u002F\u002Fjavarush.ru\u002Fpictures\u002F2273741\u002Favatar\u002F5v0dk953.png","Павел ","Подольск",351,"Новосибирск","google#111797909486156556924","https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2105047\u002Foriginal.png","Учиха Шисуи",606,19,2437405,2416255,2204027,2241979,610505,"anonymous#2412909","https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2412909\u002Foriginal.jpeg","Е К","Краснодар",520,2377421,"EXPERT",2310084,2361665,"Многопоточность: что делают методы класса Thread",18,"google#111088516188669462182","https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2437405\u002Foriginal.jpeg","Кирилл",335,602291,"anonymous#2416255","https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2416255\u002Foriginal.jpeg","𝔐𝔢𝔱𝔞𝔪𝔬𝔯𝔭𝔥𝔬𝔤𝔢𝔫𝔢𝔰𝔦𝔰","Житомир",529,"Иван",true,109,5,1770672,644125,"anonymous#2204027","Andrzej Latysz",363,2444871,2181104,"Санкт-Петербург",2275993,625277,"anonymous#2241979","Алексей","Night city",430,2328484,2399651,2421688,2,1812875,28,"google#102533881098458520784","https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2377421\u002Foriginal.jpeg","Udjin",412,3,2395987,838725,"anonymous#2310085","Рязань",518,2302914,561907,"anonymous#2361665","wan-derer.ru",39,1214,2392258,"Привет! Сегодня продолжаем говорить о многопоточности. Рассмотрим класс Thread и работу его нескольких методов. Раньше, когда мы изучали методы класса, чаще все"))],session:(function(a,b,c){return {cookie:"_ga=GA1.2.1635737358.1591724185; _fbp=fb.1.1591724185323.1870404734; intercom-id-mqlef7yz=84d17a4c-0270-4786-829d-112c48d9097f; intercom-session-mqlef7yz=; jr-site-tour-default=completed; __stripe_mid=1f326e89-6d32-436a-aca4-107fa6585a232446de; jr-sidebar-group-training-collapsed=0; jr-sidebar-mode=FULL; javarush.user.id=2496069; JSESSIONID=3d655f8b-b927-47d3-be89-86d3188d4a91; javarush.internet.user.key=5361539; javarush.daynight=; _gid=GA1.2.1389844986.1610214788; jr-last-route=%2Fquests%2Flectures%2Fquestcore.level07.lecture01",userIp:"::ffff:10.100.20.20",isDeviceMobile:b,me:{id:2496069,key:"anonymous#2496070",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2496069\u002Foriginal.jpeg",displayName:"Fomin Dmitriy",prefferedLanguage:"RU",level:17,sublevel:9,blackMatter:608,rating:144,country:a,city:"Москва",isMailSet:c,isPasswordSet:c,email:"necronaft@mail.ru",phone:a,statusCode:"active",statusMessage:a,premiumStatus:"PREMIUM",roleStatus:"USER",userFeatures:["QUEST_JAVA_SYNTAX","QUEST_JAVA_SYNTAX_LOW","QUEST_JAVA_SYNTAX_HEIGHT","QUEST_JAVA_CORE","QUEST_JAVA_MULTITHREADING","QUEST_JAVA_COLLECTIONS","QUEST_GAMES","TASK_VALIDATION_INFO","TASK_VALIDATION_RECOMMENDATION_INFO","TASK_EXECUTION_INFO","TASK_COMPILATION_INFO","BONUS_TASKS","PRIORITY_VERIFICATION","FORUM_INVITATION","SMART_WEB_EDITOR","TASK_SAVING","QUEST_TUTORIAL"]},isCompact:b,colorTheme:"dark"}}(null,false,true))};var s=document.createElement("script");try{new Function("if(0)import('')")();s.src="/client/client.ce79b86b.js";s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@2.0.4.js";s.setAttribute("data-main","/client/client.ce79b86b.js")}document.head.appendChild(s)</script>  <title>Многопоточность: что делают методы класса Thread</title><meta name="description" content="Привет! Сегодня продолжаем говорить о многопоточности. Рассмотрим класс Thread и работу его нескольких методов. Раньше, когда мы изучали методы класса, чаще все" data-svelte="svelte-1cntlp0"><meta property="og:title" content="Многопоточность: что делают методы класса Thread" data-svelte="svelte-1cntlp0"><meta property="og:description" content="Привет! Сегодня продолжаем говорить о многопоточности. Рассмотрим класс Thread и работу его нескольких методов. Раньше, когда мы изучали методы класса, чаще все" data-svelte="svelte-1cntlp0"><meta property="og:url" content="/groups/posts/1993-mnogopotochnostjh-chto-delajut-metodih-klassa-thread" data-svelte="svelte-1cntlp0"><meta property="og:image" content="https://javarush.ru/images/article/a7b37e99-94fd-4795-b95b-cb659ac50939/original.png" data-svelte="svelte-1cntlp0"><meta property="og:site_name" content="JavaRush" data-svelte="svelte-1cntlp0"><meta property="og:type" content="website" data-svelte="svelte-1cntlp0"><link rel="canonical" href="https://javarush.ru/groups/posts/1993-mnogopotochnostjh-chto-delajut-metodih-klassa-thread" data-svelte="svelte-1cntlp0"><script type="application/ld+json">{
                                                                                                                                                                                                                                                                                               "@context": "http://schema.org",
                                                                                                                                                                                                                                                                                               "@type": "Article",
                                                                                                                                                                                                                                                                                               "mainEntityOfPage": {
                                                                                                                                                                                                                                                                                                 "@type": "WebPage",
                                                                                                                                                                                                                                                                                                 "@id": "https://javarush.ru/groups/posts/1993-mnogopotochnostjh-chto-delajut-metodih-klassa-thread"
                                                                                                                                                                                                                                                                                               },
                                                                                                                                                                                                                                                                                               "headline": "Многопоточность: что делают методы класса Thread",
                                                                                                                                                                                                                                                                                               "description": "Привет! Сегодня продолжаем говорить о многопоточности. Рассмотрим класс Thread и работу его нескольких методов. Раньше, когда мы изучали методы класса, чаще всего просто писали это так: «название метода» -&gt; «что он делает». С методами Thread так не получится :) ...",
                                                                                                                                                                                                                                                                                               "image": [
                                                                                                                                                                                                                                                                                                 "https://cdn.javarush.ru/images/article/a11feba5-e610-4125-bce8-a8e73bc30eb6/original.jpeg"
                                                                                                                                                                                                                                                                                               ],
                                                                                                                                                                                                                                                                                               "datePublished": "2018-09-27T16:41:58.000Z",
                                                                                                                                                                                                                                                                                               "dateModified": "2018-11-15T09:23:50.593Z",
                                                                                                                                                                                                                                                                                               "author": {
                                                                                                                                                                                                                                                                                                 "@type": "Person",
                                                                                                                                                                                                                                                                                                 "name": "Professor Hans Noodles"
                                                                                                                                                                                                                                                                                               },
                                                                                                                                                                                                                                                                                               "publisher": {
                                                                                                                                                                                                                                                                                                 "@type": "Organization",
                                                                                                                                                                                                                                                                                                 "name": "JavaRush",
                                                                                                                                                                                                                                                                                                 "logo": {
                                                                                                                                                                                                                                                                                                   "@type": "ImageObject",
                                                                                                                                                                                                                                                                                                   "url": "https://javarush.ru/assets/images/site/logo/logo-short.svg"
                                                                                                                                                                                                                                                                                                 }
                                                                                                                                                                                                                                                                                               }
                                                                                                                                                                                                                                                                                             }</script> <script> (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                                                                                                                                                                                                                                                                                                     new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                                                                                                                                                                                                                                                                                                   j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                                                                                                                                                                                                                                                                                                   'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                                                                                                                                                                                                                                                                                                 })(window,document,'script','dataLayer','GTM-NH6ZXRJ'); </script> </head> <body> <div id=sapper>


                                                                                                                                                                                                                                                                                             <main class=""><div class="javarush-site"><div class="sidebar"><nav class="sidebar-nav"><a href="https://javarush.ru/" class="sidebar-nav__home"><div class="sidebar-nav__logo-container"><img src="/sapper/assets/images/site/logo/sidebar-logo.svg" class="sidebar-nav__logo" alt="JavaRush"></div></a>
                                                                                                                                                                                                                                                                                                 <div class="sidebar-nav__sections"><div class="side-bar-group"><div class="sidebar-group-head sidebar-group-head--has-collapse"><a href="https://javarush.ru/learn" class="sidebar-group-head__link">
                                                                                                                                                                                                                                                                                             Обучение
                                                                                                                                                                                                                                                                                             </a>

                                                                                                                                                                                                                                                                                                 <button class="sidebar-group-head__collapse"><span class="sidebar-group-head__collapse-icon"><svg class="icon icon--common-caret" aria-hidden="true"><use xlink:href="/sapper/assets/icons/common.svg?v=19#icon-caret"></use></svg></span></button></div>
                                                                                                                                                                                                                                                                                               <div class="sidebar-group-items"><div class="sidebar-nav-item" data-site-tour-target="QUESTS"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-course" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-course"></use></svg></div>





                                                                                                                                                                                                                                                                                               <a href="https://javarush.ru/quests" class="sidebar-nav-link"><div class="sidebar-nav-label">Курс</div>
                                                                                                                                                                                                                                                                                             </a></div><div class="sidebar-nav-item" data-site-tour-target="TASKS"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-tasks" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-tasks"></use></svg></div>





                                                                                                                                                                                                                                                                                               <a href="https://javarush.ru/tasks" class="sidebar-nav-link"><div class="sidebar-nav-label">Задачи</div>
                                                                                                                                                                                                                                                                                             </a></div><div class="sidebar-nav-item" data-site-tour-target="QUIZZES"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-quizzes" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-quizzes"></use></svg></div>





                                                                                                                                                                                                                                                                                               <a href="https://javarush.ru/quizzes" class="sidebar-nav-link"><div class="sidebar-nav-label">Опросы</div>
                                                                                                                                                                                                                                                                                             </a></div><div class="sidebar-nav-item" data-site-tour-target="PROJECTS"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-games" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-games"></use></svg></div>





                                                                                                                                                                                                                                                                                               <a href="https://javarush.ru/projects/games" class="sidebar-nav-link"><div class="sidebar-nav-label">Игры</div>
                                                                                                                                                                                                                                                                                             </a></div><div class="sidebar-nav-item" data-site-tour-target="HELP"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-help" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-help"></use></svg></div>





                                                                                                                                                                                                                                                                                               <a href="https://javarush.ru/help" class="sidebar-nav-link"><div class="sidebar-nav-label">Помощь</div>
                                                                                                                                                                                                                                                                                             </a></div><div class="sidebar-nav-item" data-site-tour-target="NONE"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-kick" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-kick"></use></svg></div>





                                                                                                                                                                                                                                                                                               <a href="https://javarush.ru/schedule" class="sidebar-nav-link"><div class="sidebar-nav-label">График пинков</div>
                                                                                                                                                                                                                                                                                             </a></div><div class="sidebar-nav-item" data-site-tour-target="INTERNSHIP"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-internship" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-internship"></use></svg></div>





                                                                                                                                                                                                                                                                                               <a href="https://javarush.ru/internship" class="sidebar-nav-link"><div class="sidebar-nav-label">Стажировка</div>
                                                                                                                                                                                                                                                                                             </a></div></div></div><div class="side-bar-group"><div class="sidebar-group-head sidebar-group-head--has-collapse"><a href="https://javarush.ru/community" class="sidebar-group-head__link">
                                                                                                                                                                                                                                                                                             Сообщество
                                                                                                                                                                                                                                                                                             </a>

                                                                                                                                                                                                                                                                                                 <button class="sidebar-group-head__collapse"><span class="sidebar-group-head__collapse-icon"><svg class="icon icon--common-caret" aria-hidden="true"><use xlink:href="/sapper/assets/icons/common.svg?v=19#icon-caret"></use></svg></span></button></div>
                                                                                                                                                                                                                                                                                               <div class="sidebar-group-items"><div class="sidebar-nav-item" data-site-tour-target="USERS"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-friends" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-friends"></use></svg></div>





                                                                                                                                                                                                                                                                                               <a href="https://javarush.ru/users" class="sidebar-nav-link"><div class="sidebar-nav-label">Друзья</div>
                                                                                                                                                                                                                                                                                             </a></div><div class="sidebar-nav-item" data-site-tour-target="FORUM"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-forum" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-forum"></use></svg></div>





                                                                                                                                                                                                                                                                                               <a href="https://javarush.ru/forum" class="sidebar-nav-link"><div class="sidebar-nav-label">Форум</div>
                                                                                                                                                                                                                                                                                             </a></div><div class="sidebar-nav-item" data-site-tour-target="CHAT"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-chat" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-chat"></use></svg></div>





                                                                                                                                                                                                                                                                                               <a href="https://javarush.ru/chat" class="sidebar-nav-link"><div class="sidebar-nav-label">Чат</div>
                                                                                                                                                                                                                                                                                             </a></div><div class="sidebar-nav-item sidebar-nav-item--active" data-site-tour-target="GROUPS"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-articles" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-articles"></use></svg></div>





                                                                                                                                                                                                                                                                                               <a href="https://javarush.ru/groups/posts" class="sidebar-nav-link"><div class="sidebar-nav-label">Статьи</div>
                                                                                                                                                                                                                                                                                             </a></div><div class="sidebar-nav-item" data-site-tour-target="NONE"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-success-stories" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-success-stories"></use></svg></div>





                                                                                                                                                                                                                                                                                               <a href="https://javarush.ru/groups/stories" class="sidebar-nav-link"><div class="sidebar-nav-label">Истории успеха</div>
                                                                                                                                                                                                                                                                                             </a></div><div class="sidebar-nav-item" data-site-tour-target="NEWS"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-activity" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-activity"></use></svg></div>





                                                                                                                                                                                                                                                                                               <a href="https://javarush.ru/news" class="sidebar-nav-link"><div class="sidebar-nav-label">Активности</div>
                                                                                                                                                                                                                                                                                             </a></div><div class="sidebar-nav-item" data-site-tour-target="NONE"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-reviews" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-reviews"></use></svg></div>





                                                                                                                                                                                                                                                                                               <a href="https://javarush.ru/about/reviews" class="sidebar-nav-link"><div class="sidebar-nav-label">Отзывы</div>
                                                                                                                                                                                                                                                                                             </a></div></div></div><div class="side-bar-group"><div class="sidebar-group-head sidebar-group-head--has-collapse"><a href="https://javarush.ru/me" class="sidebar-group-head__link">
                                                                                                                                                                                                                                                                                             Мой аккаунт
                                                                                                                                                                                                                                                                                             </a>

                                                                                                                                                                                                                                                                                                 <button class="sidebar-group-head__collapse"><span class="sidebar-group-head__collapse-icon"><svg class="icon icon--common-caret" aria-hidden="true"><use xlink:href="/sapper/assets/icons/common.svg?v=19#icon-caret"></use></svg></span></button></div>
                                                                                                                                                                                                                                                                                               <div class="sidebar-group-items"><div class="sidebar-nav-item" data-site-tour-target="DIALOGUES"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-dialogues" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-dialogues"></use></svg></div>





                                                                                                                                                                                                                                                                                               <a href="https://javarush.ru/dialogues" class="sidebar-nav-link"><div class="sidebar-nav-label">Сообщения</div>
                                                                                                                                                                                                                                                                                             </a></div><div class="sidebar-nav-item" data-site-tour-target="NONE"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-notifications" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-notifications"></use></svg></div>





                                                                                                                                                                                                                                                                                               <a href="https://javarush.ru/dialogues/notices" class="sidebar-nav-link"><div class="sidebar-nav-label">Уведомления</div>
                                                                                                                                                                                                                                                                                             </a></div><div class="sidebar-nav-item" data-site-tour-target="PRICES"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-subscriptions" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-subscriptions"></use></svg></div>





                                                                                                                                                                                                                                                                                               <a href="https://javarush.ru/prices" class="sidebar-nav-link"><div class="sidebar-nav-label">Подписки</div>
                                                                                                                                                                                                                                                                                             </a></div><div class="sidebar-nav-item" data-site-tour-target="NONE"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-rating" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-rating"></use></svg></div>





                                                                                                                                                                                                                                                                                               <a href="https://javarush.ru/rating" class="sidebar-nav-link"><div class="sidebar-nav-label">Рейтинги</div>
                                                                                                                                                                                                                                                                                             </a></div><div class="sidebar-nav-item" data-site-tour-target="NONE"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-support" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-support"></use></svg></div>





                                                                                                                                                                                                                                                                                               <a href="https://javarush.ru/dialogues/administration" class="sidebar-nav-link"><div class="sidebar-nav-label">Поддержка</div>
                                                                                                                                                                                                                                                                                             </a></div><div class="sidebar-nav-item" data-site-tour-target="NONE"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-settings" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-settings"></use></svg></div>





                                                                                                                                                                                                                                                                                               <a href="https://javarush.ru/settings" class="sidebar-nav-link"><div class="sidebar-nav-label">Настройки</div>
                                                                                                                                                                                                                                                                                             </a></div><div class="sidebar-nav-item" data-site-tour-target="NONE"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-bookmarks" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-bookmarks"></use></svg></div>





                                                                                                                                                                                                                                                                                               <a href="https://javarush.ru/bookmarks" class="sidebar-nav-link"><div class="sidebar-nav-label">Закладки</div>
                                                                                                                                                                                                                                                                                             </a></div></div></div></div></nav>
                                                                                                                                                                                                                                                                                               <button title="Свернуть" type="button" class="sidebar-nav__toggle"><span class="sidebar-nav__toggle-icon"><svg class="icon icon--common-caret" aria-hidden="true"><use xlink:href="/sapper/assets/icons/common.svg?v=19#icon-caret"></use></svg></span></button></div>
                                                                                                                                                                                                                                                                                                 <div class="site-layout site-layout--post-page"><div class="site-layout__container"><div class="site-layout__main"><div class="site-layout__overlay"><svg class="icon icon--common-cross" aria-hidden="true"><use xlink:href="/sapper/assets/icons/common.svg?v=19#icon-cross"></use></svg></div>
                                                                                                                                                                                                                                                                                                       <div class="site-layout__header"><header class="site-header"><div class="site-header__container"><div class="site-header__toggle-menu"><button class="toggle-menu-button" type="button" aria-label="Открыть меню"><div class="toggle-menu-button__icon"></div></button></div>
                                                                                                                                                                                                                                                                                                 <div class="site-header__title-and-search"><div class="site-header__title"><div class="site-header-title">Статья</div></div>

                                                                                                                                                                                                                                                                                                   <div class="site-header__search"><div><div class="header-search-panel"><input type="search" class="header-search-panel__input" placeholder="Поиск">
                                                                                                                                                                                                                                                                                                 <div class="header-search-panel__icon"><svg class="icon icon--common-search" aria-hidden="true"><use xlink:href="/sapper/assets/icons/common.svg?v=19#icon-search"></use></svg></div>
                                                                                                                                                                                                                                                                                                 <button class="header-search-panel__close" type="button"><svg class="icon icon--common-cross" aria-hidden="true"><use xlink:href="/sapper/assets/icons/common.svg?v=19#icon-cross"></use></svg></button></div></div></div></div>
                                                                                                                                                                                                                                                                                                 <div class="site-header__user-panel"><div class="me-short-panel-host"><a href="https://javarush.ru/me" class="me-short-panel"><div class="me-short-panel__avatar"><figure class="avatar avatar--smd"><div style="background-image: url('https://cdn.javarush.ru/images/avatar/2496069/64.webp')" class="avatar__image" role="img"></div>
                                                                                                                                                                                                                                                                                               <figcaption class="avatar__caption">
                                                                                                                                                                                                                                                                                                 Fomin Dmitriy</figcaption></figure></div>
                                                                                                                                                                                                                                                                                                 <div class="me-short-panel__info"><div class="me-short-panel__name-and-level"><div class="me-short-panel__name" title="Fomin Dmitriy">Fomin Dmitriy</div>
                                                                                                                                                                                                                                                                                                     <div class="me-short-panel__level">17 уровень</div></div>
                                                                                                                                                                                                                                                                                                   <div class="me-short-panel__force"><div class="me-short-panel__dark-matter"><div class="dark-matter"><div class="dark-matter__icon"><svg class="icon icon--common-dark-matter" aria-hidden="true"><use xlink:href="/sapper/assets/icons/common.svg?v=19#icon-dark-matter"></use></svg></div>
                                                                                                                                                                                                                                                                                                         <div class="dark-matter__value">608</div></div></div></div></div></a></div>
                                                                                                                                                                                                                                                                                                     <div class="site-header__subscription-status"><a href="https://javarush.ru/prices/my" class="me-subscription-status"><div class="subscription-status subscription-status--premium"><div class="subscription-status__label">Premium</div></div></a></div>
                                                                                                                                                                                                                                                                                                     <div class="site-header__notifications"><div class="user-notifications"><a class="user-notifications__link" href="https://javarush.ru/dialogues"><div class="user-notifications__icon"><svg class="icon icon--sidebar-nav-dialogues" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-dialogues"></use></svg></div>
                                                                                                                                                                                                                                                                                                           </a>

                                                                                                                                                                                                                                                                                                         <a class="user-notifications__link" href="https://javarush.ru/dialogues/notices"><div class="user-notifications__icon"><svg class="icon icon--sidebar-nav-notifications" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-notifications"></use></svg></div>
                                                                                                                                                                                                                                                                                                           </a></div></div></div>

                                                                                                                                                                                                                                                                                                 <div class="site-header__theme-switcher"><div class="switcher-daynight"><input class="switcher-daynight__checkbox" type="checkbox">
                                                                                                                                                                                                                                                                                               <div class="switcher-daynight__track"><div class="switcher-daynight__toggle"></div>
                                                                                                                                                                                                                                                                                                 <div class="switcher-daynight__icon switcher-daynight__icon--night"><svg class="icon icon--common-night-mode" aria-hidden="true"><use xlink:href="/sapper/assets/icons/common.svg?v=19#icon-night-mode"></use></svg></div>
                                                                                                                                                                                                                                                                                                 <div class="switcher-daynight__icon switcher-daynight__icon--day"><svg class="icon icon--common-day-mode" aria-hidden="true"><use xlink:href="/sapper/assets/icons/common.svg?v=19#icon-day-mode"></use></svg></div></div></div></div></div></header></div>

                                                                                                                                                                                                                                                                                                       <div class="site-layout__header-guest-fixed"></div>
                                                                                                                                                                                                                                                                                                       <div class="site-layout__content">

                                                                                                                                                                                                                                                                                             <div class="page"><div class="page__nav container-narrow"><div class="tabs"><ul class="tabs__list" role="tablist"><li class="tabs__item"><a class="tabs__button" href="https://javarush.ru/groups/posts">Список статей</a>
                                                                                                                                                                                                                                                                                                     </li><li class="tabs__item"><a class="tabs__button" href="https://javarush.ru/groups/all">Все группы</a>
                                                                                                                                                                                                                                                                                                     </li><li class="tabs__item"><a class="tabs__button" href="https://javarush.ru/groups/my">Мои группы</a>
                                                                                                                                                                                                                                                                                                     </li></ul></div></div>
                                                                                                                                                                                                                                                                                               <div class="page__content"><article class="article"><div class="article__head container-narrow"><div class="post-head"><div class="post-head__user"><a href="https://javarush.ru/users/1770672" target="_blank" class="user-short-info-card"><div class="user-short-info-card__avatar"><figure class="avatar avatar--lg"><div style="background-image: url('https://cdn.javarush.ru/images/avatar/1770672/128.webp')" class="avatar__image" role="img"></div>
                                                                                                                                                                                                                                                                                               <figcaption class="avatar__caption">Пользователь
                                                                                                                                                                                                                                                                                                 Professor Hans Noodles</figcaption></figure></div>
                                                                                                                                                                                                                                                                                               <div class="user-short-info-card__name">Professor Hans Noodles</div>
                                                                                                                                                                                                                                                                                               <div class="user-short-info-card__level">41 уровень</div>
                                                                                                                                                                                                                                                                                               </a></div>
                                                                                                                                                                                                                                                                                               <div class="post-head__info"><div class="post-head__meta"><ul class="post-meta-panel"><li class="post-meta-panel__item post-meta-panel__date"><span class="post-meta-panel__icon"><svg class="icon icon--common-date" aria-hidden="true"><use xlink:href="/sapper/assets/icons/common.svg?v=19#icon-date"></use></svg></span>
                                                                                                                                                                                                                                                                                                   <span class="post-meta-panel__value">27 сентября 2018</span></li>
                                                                                                                                                                                                                                                                                               <li class="post-meta-panel__item post-meta-panel__hits"><span class="post-meta-panel__icon"><svg class="icon icon--common-hits" aria-hidden="true"><use xlink:href="/sapper/assets/icons/common.svg?v=19#icon-hits"></use></svg></span>
                                                                                                                                                                                                                                                                                                   <span class="post-meta-panel__value">47142</span>
                                                                                                                                                                                                                                                                                                   <span class="post-meta-panel__label">просмотров</span></li>
                                                                                                                                                                                                                                                                                               <li class="post-meta-panel__item post-meta-panel__comments"><a class="post-meta-panel__link" href="https://javarush.ru/groups/posts/1993-mnogopotochnostjh-chto-delajut-metodih-klassa-thread#discussion"><span class="post-meta-panel__icon"><svg class="icon icon--common-comments" aria-hidden="true"><use xlink:href="/sapper/assets/icons/common.svg?v=19#icon-comments"></use></svg></span>
                                                                                                                                                                                                                                                                                                     <span class="post-meta-panel__value">109</span>
                                                                                                                                                                                                                                                                                                     <span class="post-meta-panel__label">комментариев</span>
                                                                                                                                                                                                                                                                                                     </a></li>
                                                                                                                                                                                                                                                                                               </ul></div>
                                                                                                                                                                                                                                                                                                 <h1 class="post-head__title">Многопоточность: что делают методы класса Thread</h1>
                                                                                                                                                                                                                                                                                                 <div class="post-head__source"><div class="post-source-meta"><div class="post-source-meta__main"><a class="post-source-meta__link" href="https://javarush.ru/groups/java-developer">Статья из группы
                                                                                                                                                                                                                                                                                                         Java Developer</a></div>
                                                                                                                                                                                                                                                                                                     <div class="post-source-meta__extra">28028
                                                                                                                                                                                                                                                                                                         участников
                                                                                                                                                                                                                                                                                                       </div></div></div>
                                                                                                                                                                                                                                                                                                 <div class="post-head__status"><button class="button button--md button--info-alt">Присоединиться</button>

                                                                                                                                                                                                                                                                                               </div></div></div></div>
                                                                                                                                                                                                                                                                                                     <div id="post-content" class="article__content container-narrow"><div class="content content--raw">Привет! Сегодня продолжаем говорить о многопоточности. Рассмотрим класс Thread и работу его нескольких методов. Раньше, когда мы изучали методы класса, чаще всего просто писали это так: «название метода» -> «что он делает».
                                                                                                                                                                                                                                                                                             <div class='row justify-content-center jr-image-wrap'><div class='col-12 col-sm-10 col-md-8'><img data-id="a721b583-c502-4047-b2d9-a49895b5a89a" data-max-width="710" alt="Многопоточность: что делают методы класса Thread - 1" data-src="https://cdn.javarush.ru/images/article/a721b583-c502-4047-b2d9-a49895b5a89a/1024.jpeg"></div></div>С методами Thread так не получится :) Их логика сложнее, и без нескольких примеров не разобраться.

                                                                                                                                                                                                                                                                                             <h2>Метод Thread.start()</h2>Начнем с повторения. Как ты наверняка помнишь, создать поток можно унаследовав свой класс от класса <code>Thread</code> и переопределив в нем метод <code>run()</code>.

                                                                                                                                                                                                                                                                                             Но сам он, конечно, не запустится. Для этого у нашего объекта вызываем метод <code>start()</code>.
                                                                                                                                                                                                                                                                                             <img data-id="b9b6e5a5-b771-4c79-8122-2e453ab57ace" data-max-width="850" alt="Многопоточность: что делают методы класса Thread - 2" data-src="https://cdn.javarush.ru/images/article/b9b6e5a5-b771-4c79-8122-2e453ab57ace/1024.jpeg">Давай вспомним пример из предыдущей лекции:

                                                                                                                                                                                                                                                                                             <pre class='lang-java line-numbers'><code>
                                                                                                                                                                                                                                                                                             public class MyFirstThread extends Thread {

                                                                                                                                                                                                                                                                                                @Override
                                                                                                                                                                                                                                                                                                public void run() {
                                                                                                                                                                                                                                                                                                    System.out.println("Выполнен поток " + getName());
                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                             }


                                                                                                                                                                                                                                                                                             public class Main {

                                                                                                                                                                                                                                                                                                public static void main(String[] args) {

                                                                                                                                                                                                                                                                                                    for (int i = 0; i < 10; i++) {
                                                                                                                                                                                                                                                                                                        MyFirstThread thread = new MyFirstThread();
                                                                                                                                                                                                                                                                                                        thread.start();
                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                             }
                                                                                                                                                                                                                                                                                             </code></pre>
                                                                                                                                                                                                                                                                                             <em><strong>Обрати внимание:</strong></em> чтобы запустить поток, необходимо вызвать специальный метод <code>start()</code>, а не метод <code>run()</code>! Эту ошибку легко допустить, особенно в начале изучения многопоточности.

                                                                                                                                                                                                                                                                                             Если в нашем примере ты 10 раз вызовешь у объекта метод <code>run()</code> вместо <code>start()</code>, результат будет таким:

                                                                                                                                                                                                                                                                                             <pre class='lang-java line-numbers'><code>
                                                                                                                                                                                                                                                                                             public class Main {

                                                                                                                                                                                                                                                                                                public static void main(String[] args) {

                                                                                                                                                                                                                                                                                                    for (int i = 0; i < 10; i++) {
                                                                                                                                                                                                                                                                                                        MyFirstThread thread = new MyFirstThread();
                                                                                                                                                                                                                                                                                                        thread.run();
                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                             }
                                                                                                                                                                                                                                                                                             </code></pre>

                                                                                                                                                                                                                                                                                             <em><strong>Выполнен поток Thread-0
                                                                                                                                                                                                                                                                                             Выполнен поток Thread-1
                                                                                                                                                                                                                                                                                             Выполнен поток Thread-2
                                                                                                                                                                                                                                                                                             Выполнен поток Thread-3
                                                                                                                                                                                                                                                                                             Выполнен поток Thread-4
                                                                                                                                                                                                                                                                                             Выполнен поток Thread-5
                                                                                                                                                                                                                                                                                             Выполнен поток Thread-6
                                                                                                                                                                                                                                                                                             Выполнен поток Thread-7
                                                                                                                                                                                                                                                                                             Выполнен поток Thread-8
                                                                                                                                                                                                                                                                                             Выполнен поток Thread-9</strong></em>

                                                                                                                                                                                                                                                                                             Посмотри на последовательность вывода: все идет строго по порядку. Странно, да? Мы к такому не привыкли, ведь уже знаем, что порядок запуска и выполнения потоков определяет сверхразум внутри нашей операционной системы — планировщик потоков. Может, просто повезло?

                                                                                                                                                                                                                                                                                             Конечно, дело не в везении. В этом можешь убедиться, запустив программу еще пару раз.

                                                                                                                                                                                                                                                                                             Дело в том, что прямой вызов метода <code>run()</code> не имеет отношения к многопоточности. В этом случае программа будет выполнена в главном потоке — том, в котором выполняется метод <code>main()</code>. Он просто последовательно выведет 10 строк на консоль и все. Никакие 10 потоков не запустятся.

                                                                                                                                                                                                                                                                                             Поэтому запомни на будущее и постоянно себя проверяй. Хочешь, чтобы выполнился <code>run()</code>, вызывай <code>start()</code>. Поехали дальше.

                                                                                                                                                                                                                                                                                             <h2>Метод Thread.sleep()</h2>Для приостановки выполнения текущего потока на какое-то время, используем метод <code>sleep()</code>.
                                                                                                                                                                                                                                                                                             <img data-id="1e9f01d2-6dba-4189-9bf6-121c25c29110" data-max-width="850" alt="Многопоточность: что делают методы класса Thread - 3" data-src="https://cdn.javarush.ru/images/article/1e9f01d2-6dba-4189-9bf6-121c25c29110/1024.jpeg">Метод <code>sleep()</code> принимает в качестве параметра число миллисекунд, то есть то время, на которое необходимо «усыпить» поток.

                                                                                                                                                                                                                                                                                             <pre class='lang-java line-numbers'><code>
                                                                                                                                                                                                                                                                                             public class Main {

                                                                                                                                                                                                                                                                                                public static void main(String[] args) throws InterruptedException {

                                                                                                                                                                                                                                                                                                    long start = System.currentTimeMillis();

                                                                                                                                                                                                                                                                                                    Thread.sleep(3000);

                                                                                                                                                                                                                                                                                                    System.out.println(" - Сколько я проспал? \n - " + ((System.currentTimeMillis()-start)) / 1000 + " секунды");

                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                             }
                                                                                                                                                                                                                                                                                             </code></pre>
                                                                                                                                                                                                                                                                                             <strong>Вывод в консоль:

                                                                                                                                                                                                                                                                                             <em> - Сколько я проспал?
                                                                                                                                                                                                                                                                                              - 3 секунды</em></strong>

                                                                                                                                                                                                                                                                                             Обрати внимание: метод <code>sleep()</code> — статический: он усыпляет текущий поток. То есть тот, который работает в данный момент.

                                                                                                                                                                                                                                                                                             Еще один важный нюанс: поток в состоянии сна можно прервать. В таком случае в программе возникнет исключение <code>InterruptedException</code>. Мы рассмотрим пример ниже.

                                                                                                                                                                                                                                                                                             Кстати, а что произойдет после того, как поток «проснется»? Продолжит ли он сразу же свое выполнение с того места, где закончил? Нет.

                                                                                                                                                                                                                                                                                             После того, как поток «просыпается» — когда заканчивается время, переданное в качестве аргумента в <code>Thread.sleep()</code>, — он переходит в состояние <em>runnable</em>, «работоспособный». Однако это не значит, что планировщик потоков запустит именно его. Вполне возможно, он отдаст предпочтение какому-то другому «неспящему» потоку, а наш «свежепроснувшийся» продолжит работу чуть позже.

                                                                                                                                                                                                                                                                                             Обязательно запомни: «проснулся — не значит продолжил работать в ту же секунду»!

                                                                                                                                                                                                                                                                                             <h2>Метод Thread.join()</h2><img data-id="c3c0548b-4341-4b3f-a577-44ba15c84b23" data-max-width="850" alt="Многопоточность: что делают методы класса Thread - 4" data-src="https://cdn.javarush.ru/images/article/c3c0548b-4341-4b3f-a577-44ba15c84b23/1024.jpeg">Метод <code>join()</code> приостанавливает выполнение текущего потока до тех пор, пока не завершится другой поток.

                                                                                                                                                                                                                                                                                             Если у нас есть 2 потока, <code>t1</code> и <code>t2</code>, и мы напишем —

                                                                                                                                                                                                                                                                                             <pre class='lang-java line-numbers'><code>
                                                                                                                                                                                                                                                                                             t1.join()
                                                                                                                                                                                                                                                                                             </code></pre>
                                                                                                                                                                                                                                                                                             <code>t2</code> не начнет работу, пока t1 не завершит свою. Метод <code>join()</code> можно использовать, чтобы гарантировать последовательность выполнения потоков.

                                                                                                                                                                                                                                                                                             Давай рассмотрим работу <code>join()</code> на примере:

                                                                                                                                                                                                                                                                                             <pre class='lang-java line-numbers'><code>
                                                                                                                                                                                                                                                                                             public class ThreadExample extends Thread {

                                                                                                                                                                                                                                                                                                @Override
                                                                                                                                                                                                                                                                                                public void run() {

                                                                                                                                                                                                                                                                                                    System.out.println("Начало работы потока " + getName());

                                                                                                                                                                                                                                                                                                    try {
                                                                                                                                                                                                                                                                                                        Thread.sleep(5000);
                                                                                                                                                                                                                                                                                                    } catch (InterruptedException e) {
                                                                                                                                                                                                                                                                                                        e.printStackTrace();
                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                    System.out.println("Поток " + getName() +  " завершил работу.");
                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                             }


                                                                                                                                                                                                                                                                                             public class Main {

                                                                                                                                                                                                                                                                                                public static void main(String[] args) throws InterruptedException {

                                                                                                                                                                                                                                                                                                    ThreadExample t1 = new ThreadExample();
                                                                                                                                                                                                                                                                                                    ThreadExample t2 = new ThreadExample();

                                                                                                                                                                                                                                                                                                    t1.start();


                                                                                                                                                                                                                                                                                              /*Второй поток t2 начнет выполнение только после того, как будет завершен
                                                                                                                                                                                                                                                                                                    (или бросит исключение) первый поток - t1*/
                                                                                                                                                                                                                                                                                                    try {
                                                                                                                                                                                                                                                                                                        t1.join();
                                                                                                                                                                                                                                                                                                    } catch (InterruptedException e) {
                                                                                                                                                                                                                                                                                                        e.printStackTrace();
                                                                                                                                                                                                                                                                                                    }

                                                                                                                                                                                                                                                                                                    t2.start();

                                                                                                                                                                                                                                                                                                    //Главный поток продолжит работу только после того, как t1 и t2 завершат работу
                                                                                                                                                                                                                                                                                                    try {
                                                                                                                                                                                                                                                                                                        t1.join();
                                                                                                                                                                                                                                                                                                        t2.join();
                                                                                                                                                                                                                                                                                                    } catch (InterruptedException e) {
                                                                                                                                                                                                                                                                                                        e.printStackTrace();
                                                                                                                                                                                                                                                                                                    }

                                                                                                                                                                                                                                                                                                    System.out.println("Все потоки закончили работу, программа завершена");

                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                             }
                                                                                                                                                                                                                                                                                             </code></pre>
                                                                                                                                                                                                                                                                                             Мы создали простой класс <code>ThreadExample</code>. Его задача — вывести на экран сообщение о начале работы, потом уснуть на 5 секунд и в конце сообщить о завершении работы. Ничего сложного.

                                                                                                                                                                                                                                                                                             Главная логика заключена в классе <code>Main</code>. Посмотри на комментарии: с помощью метода <code>join()</code> мы успешно управляем последовательностью выполнения потоков. Если ты вспомнишь начало темы, этим занимался планировщик потоков. Он запускал их на свое усмотрение: каждый раз по-разному.

                                                                                                                                                                                                                                                                                             Здесь же мы с помощью метода гарантировали, что сначала будет запущен и выполнен поток <code>t1</code>, затем — <code>t2</code>, и только после них — главный поток выполнения программы.

                                                                                                                                                                                                                                                                                             Идем дальше.

                                                                                                                                                                                                                                                                                             В реальных программах тебе не раз встретятся ситуации, когда необходимо будет прервать выполнение какого-то потока.

                                                                                                                                                                                                                                                                                             Например, наш поток выполняется, но при этом ждет определенного события или выполнения условия. Если это произошло, он останавливается. Было бы, наверное, логично, если бы существовал какой-то метод типа <code>stop()</code>.

                                                                                                                                                                                                                                                                                             Однако все не так просто. Когда-то давно метод <code><strong>Thread.stop()</strong></code> в Java действительно был и позволял прерывать работу потока. Но позже его удалили из библиотеки Java. Ты можешь найти его в документации Oracle и увидеть, что он помечен как <em>deprecated</em>.

                                                                                                                                                                                                                                                                                             Почему? Потому что он просто останавливал поток без какой-либо дополнительной работы.

                                                                                                                                                                                                                                                                                             Например, поток мог работать с данными и что-то в них менять. Потом его резко вырубали методом <code>stop()</code> посреди работы — и все. Ни корректного завершения работы, ни освобождения ресурсов, ни хотя бы обработки ошибок — ничего этого не было.

                                                                                                                                                                                                                                                                                             Метод <code>stop()</code>, если утрировать, просто крушил все на своем пути.

                                                                                                                                                                                                                                                                                             Его работу можно сравнить с тем, как кто-то выдергивает вилку из розетки, чтобы выключить компьютер. Да, нужного результата добиться можно. Но все понимают, что через пару недель компьютер не скажет за это «спасибо».

                                                                                                                                                                                                                                                                                             По этой причине логику прерывания потоков в Java изменили, и теперь используется специальный метод — <code>interrupt()</code>.

                                                                                                                                                                                                                                                                                             <h2>Метод Thread.interrupt()</h2>Что произойдет, если у потока вызвать <strong>метод</strong> <code><strong>interrupt()</strong></code>?

                                                                                                                                                                                                                                                                                             Есть 2 варианта:

                                                                                                                                                                                                                                                                                             <ol>
                                                                                                                                                                                                                                                                                             <li>Если объект находился в этот момент в состоянии ожидания, например, <code>join</code> или <code>sleep</code>, ожидание будет прервано, и программа выбросит <code>InterruptedException</code>.</li>
                                                                                                                                                                                                                                                                                             <li>Если же поток в этот момент был в работоспособном состоянии, у объекта будет установлен boolean-флаг <code><strong>interrupted</strong></code>.</li></ol>
                                                                                                                                                                                                                                                                                             Но проверить объект на значение этого флага и корректно завершить работу мы должны будем самостоятельно! Для этого в классе <code>Thread</code> есть специальный метод — <code><strong>boolean isInterrupted()</strong></code>.

                                                                                                                                                                                                                                                                                             Давай вернемся к примеру с часами, который был в лекции основного курса. Для удобства он немного упрощен:

                                                                                                                                                                                                                                                                                             <pre class='lang-java line-numbers'><code>
                                                                                                                                                                                                                                                                                             public class Clock extends Thread {

                                                                                                                                                                                                                                                                                                public static void main(String[] args) throws InterruptedException {
                                                                                                                                                                                                                                                                                                    Clock clock = new Clock();
                                                                                                                                                                                                                                                                                                    clock.start();

                                                                                                                                                                                                                                                                                                    Thread.sleep(10000);
                                                                                                                                                                                                                                                                                                    clock.interrupt();
                                                                                                                                                                                                                                                                                                }

                                                                                                                                                                                                                                                                                                public void run() {
                                                                                                                                                                                                                                                                                                    Thread current = Thread.currentThread();

                                                                                                                                                                                                                                                                                                    while (!current.isInterrupted())
                                                                                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                                                                                        try {
                                                                                                                                                                                                                                                                                                            Thread.sleep(1000);
                                                                                                                                                                                                                                                                                                        } catch (InterruptedException e) {
                                                                                                                                                                                                                                                                                                            System.out.println("Работа потока была прервана");
                                                                                                                                                                                                                                                                                                            break;
                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                        System.out.println("Tik");
                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                             }
                                                                                                                                                                                                                                                                                             </code></pre>
                                                                                                                                                                                                                                                                                             В нашем случае часы стартуют и начинают тикать каждую секунду. На 10-й секунде мы прерываем поток часов.

                                                                                                                                                                                                                                                                                             Как ты уже знаешь, если поток, который мы пытаемся прервать, находится в одном из состояний ожидания, это приводит к <code>InterruptedException</code>. Данный вид исключения — проверяемый, поэтому его можно легко перехватить и выполнить нашу логику завершения программы. Что мы и сделали.

                                                                                                                                                                                                                                                                                             <strong>Вот наш результат:</strong>

                                                                                                                                                                                                                                                                                             <em><strong>Tik
                                                                                                                                                                                                                                                                                             Tik
                                                                                                                                                                                                                                                                                             Tik
                                                                                                                                                                                                                                                                                             Tik
                                                                                                                                                                                                                                                                                             Tik
                                                                                                                                                                                                                                                                                             Tik
                                                                                                                                                                                                                                                                                             Tik
                                                                                                                                                                                                                                                                                             Tik
                                                                                                                                                                                                                                                                                             Tik</strong></em>

                                                                                                                                                                                                                                                                                             Работа потока была прервана

                                                                                                                                                                                                                                                                                             На этом мы заканчиваем знакомство с основными методами класса <code>Thread</code>.

                                                                                                                                                                                                                                                                                             Чтобы закрепить знания, можешь посмотреть эту видеолекцию о многопоточности:
                                                                                                                                                                                                                                                                                             <div class="row">
                                                                                                                                                                                                                                                                                             <div class="col col-md-10 col-lg-8">
                                                                                                                                                                                                                                                                                             <div class="embed-responsive embed-responsive-16by9">
                                                                                                                                                                                                                                                                                             <iframe width="560" height="315" src="https://www.youtube.com/embed/zxZ0BXlTys0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                                                                                                                                                                                                                                                                                             </div>
                                                                                                                                                                                                                                                                                             </div>
                                                                                                                                                                                                                                                                                             </div>она послужит отличным дополнительным материалом! В конце, после обзора методов, в ней рассказывается как раз о том, что мы будем проходить дальше по курсу :)

                                                                                                                                                                                                                                                                                             Успехов!</div></div>
                                                                                                                                                                                                                                                                                                     <div class="article__discussion"><div class="discussion-wrap"><div class="share-and-rating"><div class="share-and-rating__container"><div class="share-and-rating__share"><div class="discussion-sharing"><div class="discussion-sharing__item"><div class="social-button-wrap"><a class="social-button social-button--vk social-button--sm"><span class="social-button__icon"><svg class="icon icon--social-vk" aria-hidden="true"><use xlink:href="/sapper/assets/icons/social.svg?v=19#icon-vk"></use></svg></span>
                                                                                                                                                                                                                                                                                                 </a></div></div>
                                                                                                                                                                                                                                                                                               <div class="discussion-sharing__item"><div class="social-button-wrap"><a class="social-button social-button--facebook social-button--sm"><span class="social-button__icon"><svg class="icon icon--social-facebook" aria-hidden="true"><use xlink:href="/sapper/assets/icons/social.svg?v=19#icon-facebook"></use></svg></span>
                                                                                                                                                                                                                                                                                                 </a></div></div>
                                                                                                                                                                                                                                                                                               <div class="discussion-sharing__item"><div class="social-button-wrap"><a class="social-button social-button--linkedin social-button--sm"><span class="social-button__icon"><svg class="icon icon--social-linkedin" aria-hidden="true"><use xlink:href="/sapper/assets/icons/social.svg?v=19#icon-linkedin"></use></svg></span>
                                                                                                                                                                                                                                                                                                 </a></div></div>
                                                                                                                                                                                                                                                                                               <div class="discussion-sharing__item"><div class="social-button-wrap"><a class="social-button social-button--twitter social-button--sm"><span class="social-button__icon"><svg class="icon icon--social-twitter" aria-hidden="true"><use xlink:href="/sapper/assets/icons/social.svg?v=19#icon-twitter"></use></svg></span>
                                                                                                                                                                                                                                                                                                 </a></div></div></div></div>
                                                                                                                                                                                                                                                                                                     <div class="share-and-rating__stars"></div>
                                                                                                                                                                                                                                                                                                     <div class="share-and-rating__rating"></div></div></div>

                                                                                                                                                                                                                                                                                               <div class="comments-container" id="discussion"><div class="comments-head d-sm-flex"><div class="comments-head__title">Комментарии
                                                                                                                                                                                                                                                                                                 (109)</div></div>
                                                                                                                                                                                                                                                                                                 <div class="comments vertical-gutter-bottom"><div class="comment-layout"><div class="no-content"><div class="no-content__body"><span class="text-uppercase">Чтобы просмотреть все комментарии или
                                                                                                                                                                                                                                                                                                           оставить свой,<br>
                                                                                                                                                                                                                                                                                                           <span class="link">перейдите в полную версию</span></span></div></div></div>
                                                                                                                                                                                                                                                                                                   <div class="comment-layout"><div class="comment-wrap"><div class="comment"><span class="ava__wrapper"><a href="https://javarush.ru/users/2204027" target="_blank" class="ava" tabindex="-1" style="background-image: url('https://cdn.javarush.ru/images/anonymous.svg')"><span></span></a></span>
                                                                                                                                                                                                                                                                                                 <div class="comment-head"><div class="head-left"><a href="https://javarush.ru/users/2204027" target="_blank" class="user">Andrzej Latysz</a>
                                                                                                                                                                                                                                                                                                     <span class="more-info">22
                                                                                                                                                                                                                                                                                                       уровень</span>



                                                                                                                                                                                                                                                                                                     </div>
                                                                                                                                                                                                                                                                                                   <div class="head-right"><span class="date">22 декабря 2020</span>
                                                                                                                                                                                                                                                                                                     </div></div>
                                                                                                                                                                                                                                                                                                 <div class="comment-body"><div class="view-text">Прошу прощения но в следующем предложении, кажется содержится ошибка - "Метод join() приостанавливает выполнение текущего потока до тех пор, пока не завершится другой поток."</div></div></div></div>
                                                                                                                                                                                                                                                                                                     </div><div class="comment-layout"><div class="comment-wrap"><div class="comment"><span class="ava__wrapper"><a href="https://javarush.ru/users/2181104" target="_blank" class="ava" tabindex="-1" style="background-image: url('https://cdn.javarush.ru/images/anonymous.svg')"><span></span></a></span>
                                                                                                                                                                                                                                                                                                 <div class="comment-head"><div class="head-left"><a href="https://javarush.ru/users/2181104" target="_blank" class="user">Игорь</a>
                                                                                                                                                                                                                                                                                                     <span class="more-info">26
                                                                                                                                                                                                                                                                                                       уровень, Санкт-Петербург</span>



                                                                                                                                                                                                                                                                                                     </div>
                                                                                                                                                                                                                                                                                                   <div class="head-right"><span class="date">7 декабря 2020</span>
                                                                                                                                                                                                                                                                                                     </div></div>
                                                                                                                                                                                                                                                                                                 <div class="comment-body"><div class="view-text">По-моему это лишнее
                                                                                                                                                                                                                                                                                                Thread current = Thread.currentThread();

                                                                                                                                                                                                                                                                                             Можно просто написать :

                                                                                                                                                                                                                                                                                                 public void run() {
                                                                                                                                                                                                                                                                                                     while (!isInterrupted())
                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                  ///код
                                                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                                                 }

                                                                                                                                                                                                                                                                                             </div></div></div></div>
                                                                                                                                                                                                                                                                                                     </div><div class="comment-layout"><div class="comment-wrap"><div class="comment"><span class="ava__wrapper"><a href="https://javarush.ru/users/2275993" target="_blank" class="ava" tabindex="-1" style="background-image: url('https://cdn.javarush.ru/images/avatar/2275993/64.webp')"><span></span></a></span>
                                                                                                                                                                                                                                                                                                 <div class="comment-head"><div class="head-left"><a href="https://javarush.ru/users/2275993" target="_blank" class="user">Максим Дудин</a>
                                                                                                                                                                                                                                                                                                     <span class="more-info">18
                                                                                                                                                                                                                                                                                                       уровень, Калининград</span>



                                                                                                                                                                                                                                                                                                     </div>
                                                                                                                                                                                                                                                                                                   <div class="head-right"><span class="date">7 декабря 2020</span>
                                                                                                                                                                                                                                                                                                     </div></div>
                                                                                                                                                                                                                                                                                                 <div class="comment-body"><div class="view-text">фух.... насколько же мне проще читать текст, чем слушать лектора....  хотя он и шире излагает, но это прям на морально волевых... </div></div></div></div>
                                                                                                                                                                                                                                                                                                     </div><div class="comment-layout"><div class="comment-wrap"><div class="comment"><span class="ava__wrapper"><a href="https://javarush.ru/users/2241979" target="_blank" class="ava" tabindex="-1" style="background-image: url('https://cdn.javarush.ru/images/anonymous.svg')"><span></span></a></span>
                                                                                                                                                                                                                                                                                                 <div class="comment-head"><div class="head-left"><a href="https://javarush.ru/users/2241979" target="_blank" class="user">Алексей</a>
                                                                                                                                                                                                                                                                                                     <span class="more-info">19
                                                                                                                                                                                                                                                                                                       уровень, Night city</span>



                                                                                                                                                                                                                                                                                                     </div>
                                                                                                                                                                                                                                                                                                   <div class="head-right"><span class="date">23 ноября 2020</span>
                                                                                                                                                                                                                                                                                                     </div></div>
                                                                                                                                                                                                                                                                                                 <div class="comment-body"><div class="view-text">"Но проверить объект на значение этого флага и корректно завершить работу мы должны будем самостоятельно!"

                                                                                                                                                                                                                                                                                             так как же завершить поток?</div></div></div></div>
                                                                                                                                                                                                                                                                                                     </div><div class="comment-layout"><div class="comment-wrap"><div class="comment"><span class="ava__wrapper"><a href="https://javarush.ru/users/2412909" target="_blank" class="ava" tabindex="-1" style="background-image: url('https://cdn.javarush.ru/images/avatar/2412909/64.webp')"><span></span></a></span>
                                                                                                                                                                                                                                                                                                 <div class="comment-head"><div class="head-left"><a href="https://javarush.ru/users/2412909" target="_blank" class="user">Е К</a>
                                                                                                                                                                                                                                                                                                     <span class="more-info">20
                                                                                                                                                                                                                                                                                                       уровень, Краснодар</span>



                                                                                                                                                                                                                                                                                                     </div>
                                                                                                                                                                                                                                                                                                   <div class="head-right"><span class="date">30 октября 2020</span>
                                                                                                                                                                                                                                                                                                     </div></div>
                                                                                                                                                                                                                                                                                                 <div class="comment-body"><div class="view-text">Заинтересовала разница между volatile и synchronized.
                                                                                                                                                                                                                                                                                             Насколько я понял для себя - основное отличие это, то что volatile применяется только для полей(fields), а synchronized применяется для классов, экземпляров и блоков кода{}. Смысл же один - обеспечить одномоментный доступ к ресурсу.

                                                                                                                                                                                                                                                                                             Только вот понятно, что synchronized захватывает флаг(?) monitor. А вот механизм работы volatile не понятен мне пока. Иду гуглить)

                                                                                                                                                                                                                                                                                             Поправьте, если где ошибся.</div></div></div></div>
                                                                                                                                                                                                                                                                                                     </div><div class="comment-layout"><div class="comment-wrap"><div class="comment"><span class="ava__wrapper"><a href="https://javarush.ru/users/2416255" target="_blank" class="ava" tabindex="-1" style="background-image: url('https://cdn.javarush.ru/images/avatar/2416255/64.webp')"><span></span></a></span>
                                                                                                                                                                                                                                                                                                 <div class="comment-head"><div class="head-left"><a href="https://javarush.ru/users/2416255" target="_blank" class="user">𝔐𝔢𝔱𝔞𝔪𝔬𝔯𝔭𝔥𝔬𝔤𝔢𝔫𝔢𝔰𝔦𝔰</a>
                                                                                                                                                                                                                                                                                                     <span class="more-info">20
                                                                                                                                                                                                                                                                                                       уровень, Житомир</span>



                                                                                                                                                                                                                                                                                                     </div>
                                                                                                                                                                                                                                                                                                   <div class="head-right"><span class="date">16 октября 2020</span>
                                                                                                                                                                                                                                                                                                     </div></div>
                                                                                                                                                                                                                                                                                                 <div class="comment-body"><div class="view-text">В одних примерах метод прерывается командой break; в других return;
                                                                                                                                                                                                                                                                                             Есть между ними разница?</div></div></div></div>
                                                                                                                                                                                                                                                                                                     </div><div class="comment-layout"><div class="comment-wrap"><div class="comment"><span class="ava__wrapper"><a href="https://javarush.ru/users/1812875" target="_blank" class="ava" tabindex="-1" style="background-image: url('https://cdn.javarush.ru/images/anonymous.svg')"><span></span></a></span>
                                                                                                                                                                                                                                                                                                 <div class="comment-head"><div class="head-left"><a href="https://javarush.ru/users/1812875" target="_blank" class="user">Иван</a>
                                                                                                                                                                                                                                                                                                     <span class="more-info">28
                                                                                                                                                                                                                                                                                                       уровень, Санкт-Петербург</span>



                                                                                                                                                                                                                                                                                                     </div>
                                                                                                                                                                                                                                                                                                   <div class="head-right"><span class="date">13 октября 2020</span>
                                                                                                                                                                                                                                                                                                     </div></div>
                                                                                                                                                                                                                                                                                                 <div class="comment-body"><div class="view-text">Почему не сказали что в последнем примере если не будет принудительного выхода ихз цикла break; то он будет вечным даже если мы его прервали?
                                                                                                                                                                                                                                                                                             о том что контроль исключения на InterruptedException сбрасывает признак прерывания у потока и проверка на isInterrupted() вернет ложь Нужно было написать.
                                                                                                                                                                                                                                                                                             Данный пример только вводит в заблуждение и показывает пример не оптимального кода.</div></div></div></div>
                                                                                                                                                                                                                                                                                                     </div><div class="comment-layout"><div class="comment-wrap"><div class="comment"><span class="ava__wrapper"><a href="https://javarush.ru/users/2273741" target="_blank" class="ava" tabindex="-1" style="background-image: url('https://cdn.javarush.ru/images/avatar/2273741/64.webp')"><span></span></a></span>
                                                                                                                                                                                                                                                                                                 <div class="comment-head"><div class="head-left"><a href="https://javarush.ru/users/2273741" target="_blank" class="user">Павел </a>
                                                                                                                                                                                                                                                                                                     <span class="more-info">17
                                                                                                                                                                                                                                                                                                       уровень, Подольск</span>



                                                                                                                                                                                                                                                                                                     </div>
                                                                                                                                                                                                                                                                                                   <div class="head-right"><span class="date">23 августа 2020</span>
                                                                                                                                                                                                                                                                                                     </div></div>
                                                                                                                                                                                                                                                                                                 <div class="comment-body"><div class="view-text"><pre class="lang-java line-numbers"><code>
                                                                                                                                                                                                                                                                                             public class Main {

                                                                                                                                                                                                                                                                                                public static void main(String[] args) throws InterruptedException {

                                                                                                                                                                                                                                                                                                    long start = System.currentTimeMillis();

                                                                                                                                                                                                                                                                                                    Thread.sleep(3000);

                                                                                                                                                                                                                                                                                                    System.out.println(" - Сколько я проспал? \n - " + ((System.currentTimeMillis()-start)) / 1000 + " секунды");

                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                             }
                                                                                                                                                                                                                                                                                             </code></pre>

                                                                                                                                                                                                                                                                                             Я немного запутался от большого объема информации, поправьте пожалуйста.
                                                                                                                                                                                                                                                                                             Метод main у нас является единственным потоком в данном случае? С помощью метода sleep приостанавливается работа главного потока main  на 3 сек. А  метод start у нас используется, только тогда, когда в программе помимо основного потока main, есть дополнительные потоки, все верно?
                                                                                                                                                                                                                                                                                             </div></div></div></div>
                                                                                                                                                                                                                                                                                                     </div><div class="comment-layout"><div class="comment-wrap"><div class="comment"><span class="ava__wrapper"><a href="https://javarush.ru/users/2361665" target="_blank" class="ava" tabindex="-1" style="background-image: url('https://cdn.javarush.ru/images/anonymous.svg')"><span></span></a></span>
                                                                                                                                                                                                                                                                                                 <div class="comment-head"><div class="head-left"><a href="https://javarush.ru/users/2361665" target="_blank" class="user">wan-derer.ru</a>
                                                                                                                                                                                                                                                                                                     <span class="more-info">39
                                                                                                                                                                                                                                                                                                       уровень, Москва</span>



                                                                                                                                                                                                                                                                                                     </div>
                                                                                                                                                                                                                                                                                                   <div class="head-right"><span class="date">16 августа 2020</span>
                                                                                                                                                                                                                                                                                                     </div></div>
                                                                                                                                                                                                                                                                                                 <div class="comment-body"><div class="view-text">Пример по<strong> join()</strong>:
                                                                                                                                                                                                                                                                                             <pre class="lang-java line-numbers"><code>
                                                                                                                                                                                                                                                                                                    //Главный поток продолжит работу только после того, как t1 и t2 завершат работу
                                                                                                                                                                                                                                                                                                    try {
                                                                                                                                                                                                                                                                                                        t1.join();
                                                                                                                                                                                                                                                                                                        t2.join();
                                                                                                                                                                                                                                                                                             </code></pre>
                                                                                                                                                                                                                                                                                             Но ведь <strong>t1.join();</strong> уже было раньше, значит t1 уже точно завершился. Зачем писать это второй раз?
                                                                                                                                                                                                                                                                                             </div></div></div></div>
                                                                                                                                                                                                                                                                                                     </div><div class="comment-layout"><div class="comment-wrap"><div class="comment"><span class="ava__wrapper"><a href="https://javarush.ru/users/2392258" target="_blank" class="ava" tabindex="-1" style="background-image: url('https://cdn.javarush.ru/images/avatar/2392258/64.webp')"><span></span></a></span>
                                                                                                                                                                                                                                                                                                 <div class="comment-head"><div class="head-left"><a href="https://javarush.ru/users/2392258" target="_blank" class="user">Erik</a>
                                                                                                                                                                                                                                                                                                     <span class="more-info">25
                                                                                                                                                                                                                                                                                                       уровень, Новосибирск</span>



                                                                                                                                                                                                                                                                                                     </div>
                                                                                                                                                                                                                                                                                                   <div class="head-right"><span class="date">9 августа 2020</span>
                                                                                                                                                                                                                                                                                                     </div></div>
                                                                                                                                                                                                                                                                                                 <div class="comment-body"><div class="view-text">После просмотра видеоролика больше вопросов, чем ответов, во всяком случае у меня.</div></div></div></div>
                                                                                                                                                                                                                                                                                                     </div></div></div></div></div></article></div></div></div>
                                                                                                                                                                                                                                                                                                       <div class="site-layout__footer"><div class="footer-wrap"><footer class="site-footer site-footer--common"><div class="site-footer__container"><div class="site-footer__nav"><div class="site-footer__nav-section"><div class="site-footer-nav-wrap"><div class="site-footer-nav"><div class="site-footer-nav__head">Обучение</div>
                                                                                                                                                                                                                                                                                                 <ul class="site-footer-nav__list"><li class="site-footer-nav__item"><a href="https://javarush.ru/quests" class="site-footer-nav__link">Курс Java</a>
                                                                                                                                                                                                                                                                                                     </li><li class="site-footer-nav__item"><a href="https://javarush.ru/quests/QUEST_HARVARD_CS50" class="site-footer-nav__link">Курс Harvard CS50</a>
                                                                                                                                                                                                                                                                                                     </li><li class="site-footer-nav__item"><a href="https://javarush.ru/quests/QUEST_GOOGLE_ANDROID" class="site-footer-nav__link">Курс по Android</a>
                                                                                                                                                                                                                                                                                                     </li><li class="site-footer-nav__item"><a href="https://javarush.ru/internship" class="site-footer-nav__link">Стажировка</a>
                                                                                                                                                                                                                                                                                                     </li><li class="site-footer-nav__item"><a href="https://javarush.ru/help" class="site-footer-nav__link">Помощь по задачам</a>
                                                                                                                                                                                                                                                                                                     </li><li class="site-footer-nav__item"><a href="https://javarush.ru/prices" class="site-footer-nav__link">Подписки</a>
                                                                                                                                                                                                                                                                                                     </li><li class="site-footer-nav__item"><a href="https://javarush.ru/projects/games" class="site-footer-nav__link">Задачи-игры</a>
                                                                                                                                                                                                                                                                                                     </li></ul></div></div></div>
                                                                                                                                                                                                                                                                                                     <div class="site-footer__nav-section"><div class="site-footer-nav-wrap"><div class="site-footer-nav"><div class="site-footer-nav__head">Сообщество</div>
                                                                                                                                                                                                                                                                                                 <ul class="site-footer-nav__list"><li class="site-footer-nav__item"><a href="https://javarush.ru/users" class="site-footer-nav__link">Пользователи</a>
                                                                                                                                                                                                                                                                                                     </li><li class="site-footer-nav__item"><a href="https://javarush.ru/groups/posts" class="site-footer-nav__link">Статьи</a>
                                                                                                                                                                                                                                                                                                     </li><li class="site-footer-nav__item"><a href="https://javarush.ru/forum" class="site-footer-nav__link">Форум</a>
                                                                                                                                                                                                                                                                                                     </li><li class="site-footer-nav__item"><a href="https://javarush.ru/chat" class="site-footer-nav__link">Чат</a>
                                                                                                                                                                                                                                                                                                     </li><li class="site-footer-nav__item"><a href="https://javarush.ru/groups/stories" class="site-footer-nav__link">Истории успеха</a>
                                                                                                                                                                                                                                                                                                     </li><li class="site-footer-nav__item"><a href="https://javarush.ru/news" class="site-footer-nav__link">Активности</a>
                                                                                                                                                                                                                                                                                                     </li><li class="site-footer-nav__item"><a href="https://javarush.ru/search/post?query=конкурс от JavaRush" class="site-footer-nav__link">Конкурсы</a>
                                                                                                                                                                                                                                                                                                     </li></ul></div></div></div>
                                                                                                                                                                                                                                                                                                     <div class="site-footer__nav-section"><div class="site-footer-nav-wrap"><div class="site-footer-nav"><div class="site-footer-nav__head">О нас</div>
                                                                                                                                                                                                                                                                                                 <ul class="site-footer-nav__list"><li class="site-footer-nav__item"><a href="https://javarush.ru/about/mission" class="site-footer-nav__link">О JavaRush</a>
                                                                                                                                                                                                                                                                                                     </li><li class="site-footer-nav__item"><a href="https://javarush.ru/about/contacts" class="site-footer-nav__link">Контакты</a>
                                                                                                                                                                                                                                                                                                     </li><li class="site-footer-nav__item"><a href="https://javarush.ru/about/reviews" class="site-footer-nav__link">Отзывы</a>
                                                                                                                                                                                                                                                                                                     </li><li class="site-footer-nav__item"><a href="https://javarush.ru/about/faq" class="site-footer-nav__link">FAQ</a>
                                                                                                                                                                                                                                                                                                     </li><li class="site-footer-nav__item"><a href="https://javarush.ru/dialogues/administration" class="site-footer-nav__link">Поддержка</a>
                                                                                                                                                                                                                                                                                                     </li></ul></div></div></div>
                                                                                                                                                                                                                                                                                                     <div class="site-footer__nav-section"><div class="site-footer-nav-wrap"><div class="site-footer-nav"><div class="site-footer-nav__head">Видео</div>
                                                                                                                                                                                                                                                                                                 <ul class="site-footer-nav__list"><li class="site-footer-nav__item"><a href="https://javarush.ru/groups/posts/557-uroki-programmirovanija-na-java#3-top-features-javarush" class="site-footer-nav__link">Топ-3 фичи JavaRush</a>
                                                                                                                                                                                                                                                                                                     </li><li class="site-footer-nav__item"><a href="https://javarush.ru/groups/posts/557-uroki-programmirovanija-na-java#section-course" class="site-footer-nav__link">Раздел «Курс»</a>
                                                                                                                                                                                                                                                                                                     </li><li class="site-footer-nav__item"><a href="https://javarush.ru/groups/posts/557-uroki-programmirovanija-na-java#section-help" class="site-footer-nav__link">Раздел «Помощь»</a>
                                                                                                                                                                                                                                                                                                     </li><li class="site-footer-nav__item"><a href="https://javarush.ru/groups/posts/2052-razdel-igrih-na-javarush-chastjh-1-populjarnihe-voprosih#section-game" class="site-footer-nav__link">Раздел «Игры»</a>
                                                                                                                                                                                                                                                                                                     </li><li class="site-footer-nav__item"><a href="https://javarush.ru/groups/posts/557-uroki-programmirovanija-na-java#3ide" class="site-footer-nav__link">3 IDE</a>
                                                                                                                                                                                                                                                                                                     </li><li class="site-footer-nav__item"><a href="https://javarush.ru/groups/posts/557-uroki-programmirovanija-na-java#light_theme" class="site-footer-nav__link">Светлая тема сайта</a>
                                                                                                                                                                                                                                                                                                     </li></ul></div></div></div></div>

                                                                                                                                                                                                                                                                                                   <div class="site-footer__social-and-copyright"><div class="site-footer__social"><div class="social-links"><ul class="social-links__list"><li class="social-links__item"><a class="social-links__link social-links__link--vk" href="https://vk.com/javarush" target="_blank"><svg class="icon icon--social-vk" aria-hidden="true"><use xlink:href="/sapper/assets/icons/social.svg?v=19#icon-vk"></use></svg></a></li>
                                                                                                                                                                                                                                                                                                 <li class="social-links__item"><a class="social-links__link social-links__link--facebook" href="https://www.facebook.com/www.javarush.ru/" target="_blank"><svg class="icon icon--social-facebook" aria-hidden="true"><use xlink:href="/sapper/assets/icons/social.svg?v=19#icon-facebook"></use></svg></a></li>
                                                                                                                                                                                                                                                                                                 <li class="social-links__item"><a class="social-links__link social-links__link--linkedin" href="https://www.linkedin.com/company/javarush/" target="_blank"><svg class="icon icon--social-linkedin" aria-hidden="true"><use xlink:href="/sapper/assets/icons/social.svg?v=19#icon-linkedin"></use></svg></a></li>
                                                                                                                                                                                                                                                                                                 <li class="social-links__item"><a class="social-links__link social-links__link--twitter" href="https://twitter.com/javarush_ru" target="_blank"><svg class="icon icon--social-twitter" aria-hidden="true"><use xlink:href="/sapper/assets/icons/social.svg?v=19#icon-twitter"></use></svg></a></li>
                                                                                                                                                                                                                                                                                                 <li class="social-links__item"><a class="social-links__link social-links__link--youtube" href="https://www.youtube.com/channel/UCMcDsSeqS531-HKz6GiJgtA" target="_blank"><svg class="icon icon--social-youtube" aria-hidden="true"><use xlink:href="/sapper/assets/icons/social.svg?v=19#icon-youtube"></use></svg></a></li>
                                                                                                                                                                                                                                                                                                 <li class="social-links__item"><a class="social-links__link social-links__link--instagram" href="https://www.instagram.com/javarush_photo/" target="_blank"><svg class="icon icon--social-instagram" aria-hidden="true"><use xlink:href="/sapper/assets/icons/social.svg?v=19#icon-instagram"></use></svg></a></li>
                                                                                                                                                                                                                                                                                                 <li class="social-links__item"><a class="social-links__link social-links__link--telegram" href="https://t.me/javarush_original" target="_blank"><svg class="icon icon--social-telegram" aria-hidden="true"><use xlink:href="/sapper/assets/icons/social.svg?v=19#icon-telegram"></use></svg></a></li></ul></div></div>
                                                                                                                                                                                                                                                                                                     <div class="site-footer__acceptance"><div class="footer-acceptance"><img class="footer-acceptance__item" src="/sapper/assets/images/site/payment-systems/visa.svg" alt="Visa">
                                                                                                                                                                                                                                                                                               <img class="footer-acceptance__item" src="/sapper/assets/images/site/payment-systems/mastercard.svg" alt="Mastercard"></div></div>
                                                                                                                                                                                                                                                                                                     <div class="site-footer__copyright site-footer__copyright--desktop">© 2021 JavaRush <span class="site-footer__tagline">«Программистами не рождаются»</span></div></div>

                                                                                                                                                                                                                                                                                                   <div class="site-footer__copyright site-footer__copyright--mobile">© 2021 JavaRush <span class="site-footer__tagline">«Программистами не рождаются»</span></div></div></footer></div></div></div></div></div></div></main></div>
                     java.awt.EventQueue.invokeLater(new Runnable() {
                         public void run() {
                             new Frame().setVisible(true);<!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1" name=viewport> <meta content=#333333 name=theme-color> <link href=https://www.googletagmanager.com rel=preconnect> <link href=https://www.google-analytics.com rel=preconnect> <base href="/"> <link href=/sapper/assets/global.min.css rel=stylesheet> <link href=/sapper/assets/favicon/apple-icon-57x57.png rel=apple-touch-icon sizes=57x57> <link href=/sapper/assets/favicon/apple-icon-60x60.png rel=apple-touch-icon sizes=60x60> <link href=/sapper/assets/favicon/apple-icon-72x72.png rel=apple-touch-icon sizes=72x72> <link href=/sapper/assets/favicon/apple-icon-76x76.png rel=apple-touch-icon sizes=76x76> <link href=/sapper/assets/favicon/apple-icon-114x114.png rel=apple-touch-icon sizes=114x114> <link href=/sapper/assets/favicon/apple-icon-120x120.png rel=apple-touch-icon sizes=120x120> <link href=/sapper/assets/favicon/apple-icon-144x144.png rel=apple-touch-icon sizes=144x144> <link href=/sapper/assets/favicon/apple-icon-152x152.png rel=apple-touch-icon sizes=152x152> <link href=/sapper/assets/favicon/apple-icon-180x180.png rel=apple-touch-icon sizes=180x180> <link href=/sapper/assets/favicon/android-icon-192x192.png rel=icon sizes=192x192 type=image/png> <link href=/sapper/assets/favicon/favicon-32x32.png rel=icon sizes=32x32 type=image/png> <link href=/sapper/assets/favicon/favicon-96x96.png rel=icon sizes=96x96 type=image/png> <link href=/sapper/assets/favicon/favicon-16x16.png rel=icon sizes=16x16 type=image/png> <script>__SAPPER__={baseUrl:"",preloaded:[(function(a,b){return {me:{id:2496069,key:"anonymous#2496070",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2496069\u002Foriginal.jpeg",displayName:"Fomin Dmitriy",prefferedLanguage:"RU",level:17,sublevel:9,blackMatter:608,rating:144,country:a,city:"Москва",isMailSet:b,isPasswordSet:b,email:"necronaft@mail.ru",phone:a,statusCode:"active",statusMessage:a,premiumStatus:"PREMIUM",roleStatus:"USER",userFeatures:["QUEST_JAVA_SYNTAX","QUEST_JAVA_SYNTAX_LOW","QUEST_JAVA_SYNTAX_HEIGHT","QUEST_JAVA_CORE","QUEST_JAVA_MULTITHREADING","QUEST_JAVA_COLLECTIONS","QUEST_GAMES","TASK_VALIDATION_INFO","TASK_VALIDATION_RECOMMENDATION_INFO","TASK_EXECUTION_INFO","TASK_COMPILATION_INFO","BONUS_TASKS","PRIORITY_VERIFICATION","FORUM_INVITATION","SMART_WEB_EDITOR","TASK_SAVING","QUEST_TUTORIAL"]},sideBarMode:"FULL",currentPath:"groups\u002Fposts\u002F1993-mnogopotochnostjh-chto-delajut-metodih-klassa-thread",isSaleActive:false}}(null,true)),null,null,(function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,_,$,aa,ab,ac,ad,ae,af,ag,ah,ai,aj,ak,al,am,an,ao,ap,aq,ar,as,at,au,av,aw,ax,ay,az,aA,aB,aC,aD,aE,aF,aG,aH,aI,aJ,aK,aL,aM,aN,aO,aP,aQ){return {me:{id:2496069,key:"anonymous#2496070",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2496069\u002Foriginal.jpeg",displayName:"Fomin Dmitriy",prefferedLanguage:"RU",level:o,sublevel:9,blackMatter:608,rating:144,country:a,city:p,isMailSet:ac,isPasswordSet:ac,email:"necronaft@mail.ru",phone:a,statusCode:"active",statusMessage:a,premiumStatus:"PREMIUM",roleStatus:"USER",userFeatures:["QUEST_JAVA_SYNTAX","QUEST_JAVA_SYNTAX_LOW","QUEST_JAVA_SYNTAX_HEIGHT","QUEST_JAVA_CORE","QUEST_JAVA_MULTITHREADING","QUEST_JAVA_COLLECTIONS","QUEST_GAMES","TASK_VALIDATION_INFO","TASK_VALIDATION_RECOMMENDATION_INFO","TASK_EXECUTION_INFO","TASK_COMPILATION_INFO","BONUS_TASKS","PRIORITY_VERIFICATION","FORUM_INVITATION","SMART_WEB_EDITOR","TASK_SAVING","QUEST_TUTORIAL"]},post:{id:1993,key:"1993-mnogopotochnostjh-chto-delajut-metodih-klassa-thread",title:R,description:"Привет! Сегодня продолжаем говорить о многопоточности. Рассмотрим класс Thread и работу его нескольких методов. Раньше, когда мы изучали методы класса, чаще всего просто писали это так: «название метода» -&gt; «что он делает». С методами Thread так не получится :) ...",content:"Привет! Сегодня продолжаем говорить о многопоточности. Рассмотрим класс Thread и работу его нескольких методов. Раньше, когда мы изучали методы класса, чаще всего просто писали это так: «название метода» -\u003E «что он делает».\n\u003Cdiv class='row justify-content-center jr-image-wrap'\u003E\u003Cdiv class='col-12 col-sm-10 col-md-8'\u003E\u003Cimg data-id=\"a721b583-c502-4047-b2d9-a49895b5a89a\" data-max-width=\"710\" alt=\"Многопоточность: что делают методы класса Thread - 1\" data-src=\"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Farticle\u002Fa721b583-c502-4047-b2d9-a49895b5a89a\u002F1024.jpeg\"\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003EС методами Thread так не получится :) Их логика сложнее, и без нескольких примеров не разобраться. \n\n\u003Ch2\u003EМетод Thread.start()\u003C\u002Fh2\u003EНачнем с повторения. Как ты наверняка помнишь, создать поток можно унаследовав свой класс от класса \u003Ccode\u003EThread\u003C\u002Fcode\u003E и переопределив в нем метод \u003Ccode\u003Erun()\u003C\u002Fcode\u003E.\n\nНо сам он, конечно, не запустится. Для этого у нашего объекта вызываем метод \u003Ccode\u003Estart()\u003C\u002Fcode\u003E.\n\u003Cimg data-id=\"b9b6e5a5-b771-4c79-8122-2e453ab57ace\" data-max-width=\"850\" alt=\"Многопоточность: что делают методы класса Thread - 2\" data-src=\"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Farticle\u002Fb9b6e5a5-b771-4c79-8122-2e453ab57ace\u002F1024.jpeg\"\u003EДавай вспомним пример из предыдущей лекции:\n\n\u003Cpre class='lang-java line-numbers'\u003E\u003Ccode\u003E\npublic class MyFirstThread extends Thread {\n\n   @Override\n   public void run() {\n       System.out.println(\"Выполнен поток \" + getName());\n   }\n}\n\n\npublic class Main {\n\n   public static void main(String[] args) {\n\n       for (int i = 0; i \u003C 10; i++) {\n           MyFirstThread thread = new MyFirstThread();\n           thread.start();\n       }\n   }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cem\u003E\u003Cstrong\u003EОбрати внимание:\u003C\u002Fstrong\u003E\u003C\u002Fem\u003E чтобы запустить поток, необходимо вызвать специальный метод \u003Ccode\u003Estart()\u003C\u002Fcode\u003E, а не метод \u003Ccode\u003Erun()\u003C\u002Fcode\u003E! Эту ошибку легко допустить, особенно в начале изучения многопоточности. \n\nЕсли в нашем примере ты 10 раз вызовешь у объекта метод \u003Ccode\u003Erun()\u003C\u002Fcode\u003E вместо \u003Ccode\u003Estart()\u003C\u002Fcode\u003E, результат будет таким:\n\n\u003Cpre class='lang-java line-numbers'\u003E\u003Ccode\u003E\npublic class Main {\n\n   public static void main(String[] args) {\n\n       for (int i = 0; i \u003C 10; i++) {\n           MyFirstThread thread = new MyFirstThread();\n           thread.run();\n       }\n   }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\n\u003Cem\u003E\u003Cstrong\u003EВыполнен поток Thread-0\nВыполнен поток Thread-1\nВыполнен поток Thread-2\nВыполнен поток Thread-3\nВыполнен поток Thread-4\nВыполнен поток Thread-5\nВыполнен поток Thread-6\nВыполнен поток Thread-7\nВыполнен поток Thread-8\nВыполнен поток Thread-9\u003C\u002Fstrong\u003E\u003C\u002Fem\u003E\n\nПосмотри на последовательность вывода: все идет строго по порядку. Странно, да? Мы к такому не привыкли, ведь уже знаем, что порядок запуска и выполнения потоков определяет сверхразум внутри нашей операционной системы — планировщик потоков. Может, просто повезло?\n\nКонечно, дело не в везении. В этом можешь убедиться, запустив программу еще пару раз.\n\nДело в том, что прямой вызов метода \u003Ccode\u003Erun()\u003C\u002Fcode\u003E не имеет отношения к многопоточности. В этом случае программа будет выполнена в главном потоке — том, в котором выполняется метод \u003Ccode\u003Emain()\u003C\u002Fcode\u003E. Он просто последовательно выведет 10 строк на консоль и все. Никакие 10 потоков не запустятся. \n\nПоэтому запомни на будущее и постоянно себя проверяй. Хочешь, чтобы выполнился \u003Ccode\u003Erun()\u003C\u002Fcode\u003E, вызывай \u003Ccode\u003Estart()\u003C\u002Fcode\u003E. Поехали дальше.\n\n\u003Ch2\u003EМетод Thread.sleep()\u003C\u002Fh2\u003EДля приостановки выполнения текущего потока на какое-то время, используем метод \u003Ccode\u003Esleep()\u003C\u002Fcode\u003E.\n\u003Cimg data-id=\"1e9f01d2-6dba-4189-9bf6-121c25c29110\" data-max-width=\"850\" alt=\"Многопоточность: что делают методы класса Thread - 3\" data-src=\"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Farticle\u002F1e9f01d2-6dba-4189-9bf6-121c25c29110\u002F1024.jpeg\"\u003EМетод \u003Ccode\u003Esleep()\u003C\u002Fcode\u003E принимает в качестве параметра число миллисекунд, то есть то время, на которое необходимо «усыпить» поток.\n\n\u003Cpre class='lang-java line-numbers'\u003E\u003Ccode\u003E\npublic class Main {\n\n   public static void main(String[] args) throws InterruptedException {\n\n       long start = System.currentTimeMillis();\n\n       Thread.sleep(3000);\n\n       System.out.println(\" - Сколько я проспал? \\n - \" + ((System.currentTimeMillis()-start)) \u002F 1000 + \" секунды\");\n\n   }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cstrong\u003EВывод в консоль:\n\n\u003Cem\u003E - Сколько я проспал? \n - 3 секунды\u003C\u002Fem\u003E\u003C\u002Fstrong\u003E\n\nОбрати внимание: метод \u003Ccode\u003Esleep()\u003C\u002Fcode\u003E — статический: он усыпляет текущий поток. То есть тот, который работает в данный момент.\n\nЕще один важный нюанс: поток в состоянии сна можно прервать. В таком случае в программе возникнет исключение \u003Ccode\u003EInterruptedException\u003C\u002Fcode\u003E. Мы рассмотрим пример ниже.\n\nКстати, а что произойдет после того, как поток «проснется»? Продолжит ли он сразу же свое выполнение с того места, где закончил? Нет.\n\nПосле того, как поток «просыпается» — когда заканчивается время, переданное в качестве аргумента в \u003Ccode\u003EThread.sleep()\u003C\u002Fcode\u003E, — он переходит в состояние \u003Cem\u003Erunnable\u003C\u002Fem\u003E, «работоспособный». Однако это не значит, что планировщик потоков запустит именно его. Вполне возможно, он отдаст предпочтение какому-то другому «неспящему» потоку, а наш «свежепроснувшийся» продолжит работу чуть позже.\n\nОбязательно запомни: «проснулся — не значит продолжил работать в ту же секунду»!\n\n\u003Ch2\u003EМетод Thread.join()\u003C\u002Fh2\u003E\u003Cimg data-id=\"c3c0548b-4341-4b3f-a577-44ba15c84b23\" data-max-width=\"850\" alt=\"Многопоточность: что делают методы класса Thread - 4\" data-src=\"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Farticle\u002Fc3c0548b-4341-4b3f-a577-44ba15c84b23\u002F1024.jpeg\"\u003EМетод \u003Ccode\u003Ejoin()\u003C\u002Fcode\u003E приостанавливает выполнение текущего потока до тех пор, пока не завершится другой поток.\n\nЕсли у нас есть 2 потока, \u003Ccode\u003Et1\u003C\u002Fcode\u003E и \u003Ccode\u003Et2\u003C\u002Fcode\u003E, и мы напишем —\n\n\u003Cpre class='lang-java line-numbers'\u003E\u003Ccode\u003E\nt1.join()\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ccode\u003Et2\u003C\u002Fcode\u003E не начнет работу, пока t1 не завершит свою. Метод \u003Ccode\u003Ejoin()\u003C\u002Fcode\u003E можно использовать, чтобы гарантировать последовательность выполнения потоков. \n\nДавай рассмотрим работу \u003Ccode\u003Ejoin()\u003C\u002Fcode\u003E на примере:\n\n\u003Cpre class='lang-java line-numbers'\u003E\u003Ccode\u003E\npublic class ThreadExample extends Thread {\n\n   @Override\n   public void run() {\n\n       System.out.println(\"Начало работы потока \" + getName());\n\n       try {\n           Thread.sleep(5000);\n       } catch (InterruptedException e) {\n           e.printStackTrace();\n       }\n       System.out.println(\"Поток \" + getName() +  \" завершил работу.\");\n   }\n}\n\n\npublic class Main {\n\n   public static void main(String[] args) throws InterruptedException {\n\n       ThreadExample t1 = new ThreadExample();\n       ThreadExample t2 = new ThreadExample();\n\n       t1.start();\n\n      \n \u002F*Второй поток t2 начнет выполнение только после того, как будет завершен\n       (или бросит исключение) первый поток - t1*\u002F\n       try {\n           t1.join();\n       } catch (InterruptedException e) {\n           e.printStackTrace();\n       }\n\n       t2.start();\n\n       \u002F\u002FГлавный поток продолжит работу только после того, как t1 и t2 завершат работу\n       try {\n           t1.join();\n           t2.join();\n       } catch (InterruptedException e) {\n           e.printStackTrace();\n       }\n\n       System.out.println(\"Все потоки закончили работу, программа завершена\");\n\n   }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\nМы создали простой класс \u003Ccode\u003EThreadExample\u003C\u002Fcode\u003E. Его задача — вывести на экран сообщение о начале работы, потом уснуть на 5 секунд и в конце сообщить о завершении работы. Ничего сложного.\n\nГлавная логика заключена в классе \u003Ccode\u003EMain\u003C\u002Fcode\u003E. Посмотри на комментарии: с помощью метода \u003Ccode\u003Ejoin()\u003C\u002Fcode\u003E мы успешно управляем последовательностью выполнения потоков. Если ты вспомнишь начало темы, этим занимался планировщик потоков. Он запускал их на свое усмотрение: каждый раз по-разному. \n\nЗдесь же мы с помощью метода гарантировали, что сначала будет запущен и выполнен поток \u003Ccode\u003Et1\u003C\u002Fcode\u003E, затем — \u003Ccode\u003Et2\u003C\u002Fcode\u003E, и только после них — главный поток выполнения программы.  \n\nИдем дальше.\n\nВ реальных программах тебе не раз встретятся ситуации, когда необходимо будет прервать выполнение какого-то потока.\n\nНапример, наш поток выполняется, но при этом ждет определенного события или выполнения условия. Если это произошло, он останавливается. Было бы, наверное, логично, если бы существовал какой-то метод типа \u003Ccode\u003Estop()\u003C\u002Fcode\u003E.\n\nОднако все не так просто. Когда-то давно метод \u003Ccode\u003E\u003Cstrong\u003EThread.stop()\u003C\u002Fstrong\u003E\u003C\u002Fcode\u003E в Java действительно был и позволял прерывать работу потока. Но позже его удалили из библиотеки Java. Ты можешь найти его в документации Oracle и увидеть, что он помечен как \u003Cem\u003Edeprecated\u003C\u002Fem\u003E.\n\nПочему? Потому что он просто останавливал поток без какой-либо дополнительной работы. \n\nНапример, поток мог работать с данными и что-то в них менять. Потом его резко вырубали методом \u003Ccode\u003Estop()\u003C\u002Fcode\u003E посреди работы — и все. Ни корректного завершения работы, ни освобождения ресурсов, ни хотя бы обработки ошибок — ничего этого не было.\n\nМетод \u003Ccode\u003Estop()\u003C\u002Fcode\u003E, если утрировать, просто крушил все на своем пути.\n\nЕго работу можно сравнить с тем, как кто-то выдергивает вилку из розетки, чтобы выключить компьютер. Да, нужного результата добиться можно. Но все понимают, что через пару недель компьютер не скажет за это «спасибо».\n\nПо этой причине логику прерывания потоков в Java изменили, и теперь используется специальный метод — \u003Ccode\u003Einterrupt()\u003C\u002Fcode\u003E.\n\n\u003Ch2\u003EМетод Thread.interrupt()\u003C\u002Fh2\u003EЧто произойдет, если у потока вызвать \u003Cstrong\u003Eметод\u003C\u002Fstrong\u003E \u003Ccode\u003E\u003Cstrong\u003Einterrupt()\u003C\u002Fstrong\u003E\u003C\u002Fcode\u003E?\n\nЕсть 2 варианта:\n\n\u003Col\u003E\n\u003Cli\u003EЕсли объект находился в этот момент в состоянии ожидания, например, \u003Ccode\u003Ejoin\u003C\u002Fcode\u003E или \u003Ccode\u003Esleep\u003C\u002Fcode\u003E, ожидание будет прервано, и программа выбросит \u003Ccode\u003EInterruptedException\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\n\u003Cli\u003EЕсли же поток в этот момент был в работоспособном состоянии, у объекта будет установлен boolean-флаг \u003Ccode\u003E\u003Cstrong\u003Einterrupted\u003C\u002Fstrong\u003E\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\u003C\u002Fol\u003E\nНо проверить объект на значение этого флага и корректно завершить работу мы должны будем самостоятельно! Для этого в классе \u003Ccode\u003EThread\u003C\u002Fcode\u003E есть специальный метод — \u003Ccode\u003E\u003Cstrong\u003Eboolean isInterrupted()\u003C\u002Fstrong\u003E\u003C\u002Fcode\u003E.\n\nДавай вернемся к примеру с часами, который был в лекции основного курса. Для удобства он немного упрощен:\n\n\u003Cpre class='lang-java line-numbers'\u003E\u003Ccode\u003E\npublic class Clock extends Thread {\n\n   public static void main(String[] args) throws InterruptedException {\n       Clock clock = new Clock();\n       clock.start();\n\n       Thread.sleep(10000);\n       clock.interrupt();\n   }\n\n   public void run() {\n       Thread current = Thread.currentThread();\n\n       while (!current.isInterrupted())\n       {\n           try {\n               Thread.sleep(1000);\n           } catch (InterruptedException e) {\n               System.out.println(\"Работа потока была прервана\");\n               break;\n           }\n           System.out.println(\"Tik\");\n       }\n   }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\nВ нашем случае часы стартуют и начинают тикать каждую секунду. На 10-й секунде мы прерываем поток часов.\n\nКак ты уже знаешь, если поток, который мы пытаемся прервать, находится в одном из состояний ожидания, это приводит к \u003Ccode\u003EInterruptedException\u003C\u002Fcode\u003E. Данный вид исключения — проверяемый, поэтому его можно легко перехватить и выполнить нашу логику завершения программы. Что мы и сделали.\n\n\u003Cstrong\u003EВот наш результат:\u003C\u002Fstrong\u003E\n\n\u003Cem\u003E\u003Cstrong\u003ETik\nTik\nTik\nTik\nTik\nTik\nTik\nTik\nTik\u003C\u002Fstrong\u003E\u003C\u002Fem\u003E\n\nРабота потока была прервана\n\nНа этом мы заканчиваем знакомство с основными методами класса \u003Ccode\u003EThread\u003C\u002Fcode\u003E.\n\nЧтобы закрепить знания, можешь посмотреть эту видеолекцию о многопоточности: \n\u003Cdiv class=\"row\"\u003E\n\u003Cdiv class=\"col col-md-10 col-lg-8\"\u003E\n\u003Cdiv class=\"embed-responsive embed-responsive-16by9\"\u003E\n\u003Ciframe width=\"560\" height=\"315\" src=\"https:\u002F\u002Fwww.youtube.com\u002Fembed\u002FzxZ0BXlTys0\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen\u003E\u003C\u002Fiframe\u003E\n\u003C\u002Fdiv\u003E\n\u003C\u002Fdiv\u003E\n\u003C\u002Fdiv\u003Eона послужит отличным дополнительным материалом! В конце, после обзора методов, в ней рассказывается как раз о том, что мы будем проходить дальше по курсу :)\n\nУспехов!",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Farticle\u002Fa11feba5-e610-4125-bce8-a8e73bc30eb6\u002Foriginal.jpeg",type:"USUAL",views:47142,commentsCount:ad,createdTime:1538066518000,updatedTime:1542273830593,rating:4.978201634877384,ratingCount:367,originalGroupInfo:{id:S,key:"java-developer",type:"TECH",title:"Java Developer",description:"Мы все тут очень любим Java! Уверены, ты тоже полюбишь, когда углубишься в самые дебри и познаешь истинные возможности этого языка! Присоединяйся! В нашей группе — статьи и новости о Java, информация о работе Java-программистом, общение, обсуждение вопросов и многое другое.",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Fsystem\u002F243fcb29-d895-4f94-b537-b4c08d29d6ce\u002Foriginal.jpeg",avatarUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Fsystem\u002F7bfe9928-c13b-4658-8cce-ab42a8907ea4\u002Foriginal.jpeg",usersCount:28028,meGroupInfo:a,levelToEditor:ae,visibilityStatus:c,userDiscussionInfo:a,commentsCount:a},groupInfo:a,authorInfo:{id:af,userId:af,key:"anonymous#1770672",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F1770672\u002Foriginal.png",displayName:"Professor Hans Noodles",position:a,job:a,country:a,city:a,level:41,rating:11,publicStatus:"HAVE_JOB",publicStatusMessage:a},likesInfo:{count:410,status:a},visibilityStatus:c,userDiscussionInfo:a},comments:[{id:ag,time:1608667685026,message:"Прошу прощения но в следующем предложении, кажется содержится ошибка - \"Метод join() приостанавливает выполнение текущего потока до тех пор, пока не завершится другой поток.\"",owner:{id:F,userId:F,key:ah,pictureUrl:m,displayName:ai,position:a,job:a,country:d,city:d,level:k,rating:aj,publicStatus:i,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:a,status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:a,childrenComments:[{id:647981,time:1609249119870,message:"А в чём ошибка? \nТы в первом потоке прописываешь join() с указанием второго потока. И пока второй поток не завершится - первый ждёт, т.е. не будет идти дальше по коду.",owner:{id:ak,userId:ak,key:"anonymous#2444882",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Fanonymous.svg?1604407903641",displayName:"Veygard",position:a,job:a,country:d,city:p,level:S,rating:323,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:F,userId:F,key:ah,pictureUrl:m,displayName:ai,position:a,job:a,country:d,city:d,level:k,rating:aj,publicStatus:i,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:ag,childrenComments:a,likes:{count:h,status:a}}],likes:{count:h,status:a}},{id:634544,time:1607366363821,message:"По-моему это лишнее\n   Thread current = Thread.currentThread();\n\nМожно просто написать :\n\n    public void run() {\n        while (!isInterrupted())\n        {\n     \u002F\u002F\u002Fкод\n        }\n    }\n\n",owner:{id:al,userId:al,key:"anonymous#2181104",pictureUrl:m,displayName:"Игорь",position:a,job:a,country:a,city:am,level:26,rating:259,publicStatus:i,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:a,status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:a,childrenComments:[],likes:{count:h,status:a}},{id:634375,time:1607352553780,message:"фух.... насколько же мне проще читать текст, чем слушать лектора....  хотя он и шире излагает, но это прям на морально волевых... ",owner:{id:an,userId:an,key:"anonymous#2275993",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2275993\u002Foriginal.jpeg",displayName:"Максим Дудин",position:a,job:a,country:a,city:"Калининград",level:S,rating:487,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:a,status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:a,childrenComments:[],likes:{count:h,status:a}},{id:ao,time:1606152307397,message:"\"Но проверить объект на значение этого флага и корректно завершить работу мы должны будем самостоятельно!\"\n\nтак как же завершить поток?",owner:{id:G,userId:G,key:ap,pictureUrl:m,displayName:aq,position:a,job:a,country:d,city:ar,level:C,rating:as,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:a,status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:a,childrenComments:[{id:625290,time:1606153232278,message:"Нужно, чтобы метод run полностью выполнился:\n\u003Cpre class=\"language-java line-numbers\"\u003E\u003Ccode\u003E\npublic void run() {\n       Thread current = Thread.currentThread();\n\n       while (!current.isInterrupted())\n       {\n           try {\n               Thread.sleep(1000);\n           } catch (InterruptedException e) {\n               System.out.println(\"Работа потока была прервана\");\n               break;\n           }\n           System.out.println(\"Tik\");\n       }\n   }\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\nВ этом примере программа находится в постоянном цикле, пока значение флага false. Как только он становится true, цикл while завершается, далее в коде больше нет команд, так что и метод run() тоже завершается, ну а вместе с ним и поток.",owner:{id:at,userId:at,key:"anonymous#2328485",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2328484\u002Foriginal.jpeg",displayName:"Гордей",position:a,job:a,country:a,city:a,level:27,rating:483,publicStatus:i,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:G,userId:G,key:ap,pictureUrl:m,displayName:aq,position:a,job:a,country:d,city:ar,level:C,rating:as,publicStatus:f,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:ao,childrenComments:a,likes:{count:h,status:a}}],likes:{count:h,status:a}},{id:H,time:1604054471820,message:"Заинтересовала разница между volatile и synchronized.\nНасколько я понял для себя - основное отличие это, то что volatile применяется только для полей(fields), а synchronized применяется для классов, экземпляров и блоков кода{}. Смысл же один - обеспечить одномоментный доступ к ресурсу.\n\nТолько вот понятно, что synchronized захватывает флаг(?) monitor. А вот механизм работы volatile не понятен мне пока. Иду гуглить)\n\nПоправьте, если где ошибся.",owner:{id:q,userId:q,key:I,pictureUrl:J,displayName:K,position:d,job:a,country:g,city:L,level:r,rating:M,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:a,status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:a,childrenComments:[{id:624109,time:1605972563249,message:"Насколько я знаю volatile используется в том случае, если только 1 поток записывает данные в переменную,в то время как остальные считывают их оттуда.Volatile используется для запрета кеширования этой переменной.Поправь если не так.",owner:{id:D,userId:D,key:T,pictureUrl:U,displayName:V,position:d,job:d,country:g,city:p,level:C,rating:W,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:q,userId:q,key:I,pictureUrl:J,displayName:K,position:d,job:a,country:g,city:L,level:r,rating:M,publicStatus:f,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:H,childrenComments:a,likes:{count:h,status:a}},{id:625105,time:1606137159877,message:"Похоже, что именно так всё и устроено.\n\u003Ca href=\"https:\u002F\u002Furvanov.ru\u002F2017\u002F07\u002F20\u002F%D0%B7%D0%B0%D1%87%D0%B5%D0%BC-%D0%BD%D1%83%D0%B6%D0%BD%D0%BE-volatile-%D0%B2-java\u002F\" target=\"_blank\" rel=\"nofollow\"\u003EСтатейка на тему\u003C\u002Fa\u003E",owner:{id:q,userId:q,key:I,pictureUrl:J,displayName:K,position:d,job:a,country:g,city:L,level:r,rating:M,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:D,userId:D,key:T,pictureUrl:U,displayName:V,position:d,job:d,country:g,city:p,level:C,rating:W,publicStatus:f,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:H,childrenComments:a,likes:{count:h,status:a}},{id:625377,time:1606159804782,message:"спасибо за статью",owner:{id:D,userId:D,key:T,pictureUrl:U,displayName:V,position:d,job:d,country:g,city:p,level:C,rating:W,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:q,userId:q,key:I,pictureUrl:J,displayName:K,position:d,job:a,country:g,city:L,level:r,rating:M,publicStatus:f,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:H,childrenComments:a,likes:{count:h,status:a}}],likes:{count:h,status:a}},{id:X,time:1602870715931,message:"В одних примерах метод прерывается командой break; в других return;\nЕсть между ними разница?",owner:{id:E,userId:E,key:Y,pictureUrl:Z,displayName:_,position:a,job:a,country:d,city:$,level:r,rating:aa,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:a,status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:a,childrenComments:[{id:603471,time:1603068308986,message:"Команда break прерывает работу \u003Cstrong\u003Eцикла\u003C\u002Fstrong\u003E, а return прерывает работу \u003Cstrong\u003Eметода\u003C\u002Fstrong\u003E",owner:{id:au,userId:au,key:"anonymous#2399651",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2399651\u002Foriginal.jpeg",displayName:"Merch",position:"Студент",job:"uio",country:"Узбекистан",city:"Ташкент",level:k,rating:423,publicStatus:i,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:E,userId:E,key:Y,pictureUrl:Z,displayName:_,position:a,job:a,country:d,city:$,level:r,rating:aa,publicStatus:f,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:X,childrenComments:a,likes:{count:ae,status:a}},{id:609602,time:1603914660967,message:"Оператор break приводит к завершению цикла, он выйдет из цикла и остановит дальнейшие итерации.\nReturn : Оператор return выводит вас из метода. Он прекращает выполнение метода и возвращается из выполнения метода.",owner:{id:av,userId:av,key:"anonymous#2421688",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2421688\u002Foriginal.jpeg",displayName:"Dara",position:"Software Developer",job:d,country:a,city:d,level:C,rating:654,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:E,userId:E,key:Y,pictureUrl:Z,displayName:_,position:a,job:a,country:d,city:$,level:r,rating:aa,publicStatus:f,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:X,childrenComments:a,likes:{count:aw,status:a}}],likes:{count:h,status:a}},{id:599969,time:1602596155517,message:"Почему не сказали что в последнем примере если не будет принудительного выхода ихз цикла break; то он будет вечным даже если мы его прервали? \nо том что контроль исключения на InterruptedException сбрасывает признак прерывания у потока и проверка на isInterrupted() вернет ложь Нужно было написать.\nДанный пример только вводит в заблуждение и показывает пример не оптимального кода.",owner:{id:ax,userId:ax,key:"anonymous#1812875",pictureUrl:m,displayName:ab,position:a,job:a,country:g,city:am,level:ay,rating:702,publicStatus:i,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:a,status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:a,childrenComments:[],likes:{count:1,status:a}},{id:n,time:1598172300280,message:"\u003Cpre class=\"lang-java line-numbers\"\u003E\u003Ccode\u003E\npublic class Main {\n\n   public static void main(String[] args) throws InterruptedException {\n\n       long start = System.currentTimeMillis();\n\n       Thread.sleep(3000);\n\n       System.out.println(\" - Сколько я проспал? \\n - \" + ((System.currentTimeMillis()-start)) \u002F 1000 + \" секунды\");\n\n   }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\nЯ немного запутался от большого объема информации, поправьте пожалуйста.\nМетод main у нас является единственным потоком в данном случае? С помощью метода sleep приостанавливается работа главного потока main  на 3 сек. А  метод start у нас используется, только тогда, когда в программе помимо основного потока main, есть дополнительные потоки, все верно? \n",owner:{id:j,userId:j,key:s,pictureUrl:t,displayName:u,position:a,job:a,country:g,city:v,level:o,rating:w,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:a,status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:a,childrenComments:[{id:567800,time:1598440026505,message:"Да, верно. main метод выполняется первым, по дефолту. \nОн является родительской нитью, которая может запускать другие нити. \nВ данном примере дочерних нитей нет, приостанавливается именно работа основного метода. \nthread.start - запускает дочернюю нить",owner:{id:N,userId:N,key:az,pictureUrl:aA,displayName:aB,position:a,job:a,country:g,city:p,level:k,rating:aC,publicStatus:i,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:j,userId:j,key:s,pictureUrl:t,displayName:u,position:a,job:a,country:g,city:v,level:o,rating:w,publicStatus:f,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:n,childrenComments:a,likes:{count:h,status:a}},{id:569597,time:1598634510740,message:"Спасибо! 👍",owner:{id:j,userId:j,key:s,pictureUrl:t,displayName:u,position:a,job:a,country:g,city:v,level:o,rating:w,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:N,userId:N,key:az,pictureUrl:aA,displayName:aB,position:a,job:a,country:g,city:p,level:k,rating:aC,publicStatus:i,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:n,childrenComments:a,likes:{count:h,status:a}},{id:573312,time:1599154658404,message:"Не совсем верно)\nВо первых формулировка: \n\u003Cem\u003EМетод main у нас является единственным потоком\u003C\u002Fem\u003E\nневерна) метод main не является потоком. Верно сказать, что наш классический метод main, является точкой входа в программу, коих может быть множество) и тот поток, который запускается с методом main, является главным)\n\n\u003Cem\u003E С помощью метода sleep приостанавливается работа главного потока main\u003C\u002Fem\u003E\nС помощью статического метода sleep, приостанавливается текущий поток, тот из которого метод sleep был вызван. Он может быть прописан, в методе run(), одного из наших дочерних потоков. Или где угодно еще. Важно, откуда происходит вызов. Для примера набросал немного:\n\u003Cpre class=\"lang-java line-numbers\"\u003E\u003Ccode\u003E\npublic class MainClass {\n    public static void main(String[] args) throws InterruptedException {\n        TestThread ourThread = new TestThread();\n        ourThread.current.sleep(1000);\n    }\n    \n    static class TestThread extends Thread {\n        Thread current;\n\n        public TestThread() {\n            start();\n        }\n\n        @Override\n        public void run() {\n            current = Thread.currentThread();\n            \n            while (!isInterrupted()) {\n                \u002F\u002F...\n            }\n        }\n    }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\nКак по вашему, какая нить остановится в данном случае?))\n\n\u003Cem\u003EА  метод start у нас используется, только тогда, когда в программе помимо основного потока main, есть дополнительные потоки, все верно? \u003C\u002Fem\u003E\nМетод start() используется не \"когда\") он вызывается у созданных вами потоков. Единожды, для того чтобы начать выполнение, переопределенного метода run()",owner:{id:l,userId:l,key:y,pictureUrl:z,displayName:A,position:a,job:a,country:d,city:x,level:k,rating:B,publicStatus:i,publicStatusMessage:a,isFriend:a,subscription:a,badge:O},answerTo:{id:j,userId:j,key:s,pictureUrl:t,displayName:u,position:a,job:a,country:g,city:v,level:o,rating:w,publicStatus:f,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:n,childrenComments:a,likes:{count:aD,status:a}},{id:573780,time:1599228133759,message:"В этом примере просто поясняется как работает sleep: здесь он просто добавляет время простоя к потоку метода main. Переменная long start сохраняет системное время в мс до выполнения метода statlc void sleep() класса java.lang.Thread \u003Ca href=\"https:\u002F\u002Fdocs.oracle.com\u002Fjavase\u002Ftutorial\u002Fessential\u002Fconcurrency\u002Fsleep.html\" target=\"_blank\" rel=\"nofollow\"\u003EPausing Execution with Sleep\u003C\u002Fa\u003E",owner:{id:aE,userId:aE,key:"anonymous#2395987",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2395987\u002Foriginal.jpeg?1605643663546",displayName:"jv.tab",position:a,job:a,country:g,city:p,level:r,rating:422,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:j,userId:j,key:s,pictureUrl:t,displayName:u,position:a,job:a,country:g,city:v,level:o,rating:w,publicStatus:f,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:n,childrenComments:a,likes:{count:h,status:a}},{id:574581,time:1599347602208,message:" \" тот поток, который запускается с методом main, является главным) \" . В лекции у нас 2 потока , t1 и t2, какой поток главный получается? Ни один из них? Там же в лекции написано \"\u002F\u002FГлавный поток продолжит работу только после того, как t1 и t2 завершат работу\". Спасибо за ответ.",owner:{id:j,userId:j,key:s,pictureUrl:t,displayName:u,position:a,job:a,country:g,city:v,level:o,rating:w,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:l,userId:l,key:y,pictureUrl:z,displayName:A,position:a,job:a,country:d,city:x,level:k,rating:B,publicStatus:i,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:n,childrenComments:a,likes:{count:h,status:a}},{id:575558,time:1599492323356,message:"У нас всегда есть основной поток, который мы не запускаем явно. В нем происходит основная работа нашей программы)\nt1 и t2 же - создаются программой явно из основного потока, в методе main(). Всё сходится, ни один из них, не главный)\nВы всё верно поняли) обращайтесь)",owner:{id:l,userId:l,key:y,pictureUrl:z,displayName:A,position:a,job:a,country:d,city:x,level:k,rating:B,publicStatus:i,publicStatusMessage:a,isFriend:a,subscription:a,badge:O},answerTo:{id:j,userId:j,key:s,pictureUrl:t,displayName:u,position:a,job:a,country:g,city:v,level:o,rating:w,publicStatus:f,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:n,childrenComments:a,likes:{count:aD,status:a}},{id:587589,time:1600955358666,message:"хорошее объяснение",owner:{id:aF,userId:aF,key:"facebook#1079488365436381",pictureUrl:m,displayName:"Andrei Po",position:a,job:a,country:a,city:a,level:ay,rating:503,publicStatus:"UNKNOWN",publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:l,userId:l,key:y,pictureUrl:z,displayName:A,position:a,job:a,country:d,city:x,level:k,rating:B,publicStatus:i,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:n,childrenComments:a,likes:{count:h,status:a}},{id:598733,time:1602423210287,message:"Метод  main как раз является потоком (вернее конечно же main содержит внутри себя поток, который создается автоматически при запуске программы), причем главным, если создаем 1 новый поток в своей программе, то у нас их будет 2, главный и побочный.\nИнтересное мнение по поводу входа в программу, не очень понятно как их может быть несколько, если метод main может быть только 1, и только с этого метода начинается выполнение",owner:{id:P,userId:P,key:aG,pictureUrl:m,displayName:ab,position:a,job:a,country:g,city:aH,level:k,rating:aI,publicStatus:i,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:l,userId:l,key:y,pictureUrl:z,displayName:A,position:a,job:a,country:d,city:x,level:k,rating:B,publicStatus:i,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:n,childrenComments:a,likes:{count:h,status:a}},{id:599205,time:1602496534225,message:"Методов main может быть бесчисленное множество - по количеству классов в вашей программе. Каждый может иметь свой метод main",owner:{id:l,userId:l,key:y,pictureUrl:z,displayName:A,position:a,job:a,country:d,city:x,level:k,rating:B,publicStatus:i,publicStatusMessage:a,isFriend:a,subscription:a,badge:O},answerTo:{id:P,userId:P,key:aG,pictureUrl:m,displayName:ab,position:a,job:a,country:g,city:aH,level:k,rating:aI,publicStatus:i,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:n,childrenComments:a,likes:{count:h,status:a}},{id:599462,time:1602520271202,message:"Но ведь при компиляции и запуске программы выбираем главный класс, main которого и запускается. + если вывести имя главного потока, там будет main)",owner:{id:aJ,userId:aJ,key:"github#31883252",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2302914\u002Foriginal.jpeg",displayName:"Darth Nihilus",position:a,job:a,country:a,city:"Planet Korriban",level:o,rating:296,publicStatus:f,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:{id:j,userId:j,key:s,pictureUrl:t,displayName:u,position:a,job:a,country:g,city:v,level:o,rating:w,publicStatus:f,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:n,childrenComments:a,likes:{count:h,status:a}}],likes:{count:h,status:a}},{id:aK,time:1597594072402,message:"Пример по\u003Cstrong\u003E join()\u003C\u002Fstrong\u003E:\n\u003Cpre class=\"lang-java line-numbers\"\u003E\u003Ccode\u003E\n       \u002F\u002FГлавный поток продолжит работу только после того, как t1 и t2 завершат работу\n       try {\n           t1.join();\n           t2.join();\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\nНо ведь \u003Cstrong\u003Et1.join();\u003C\u002Fstrong\u003E уже было раньше, значит t1 уже точно завершился. Зачем писать это второй раз?\n",owner:{id:Q,userId:Q,key:aL,pictureUrl:m,displayName:aM,position:a,job:a,country:g,city:p,level:aN,rating:aO,publicStatus:i,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:a,status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:a,childrenComments:[{id:573315,time:1599154854515,message:"что для одного может быть очевидно, для другого может стать спасительным билетом) уж лучше так, вместо того, как иногда здесь бывает;)",owner:{id:l,userId:l,key:y,pictureUrl:z,displayName:A,position:a,job:a,country:d,city:x,level:k,rating:B,publicStatus:i,publicStatusMessage:a,isFriend:a,subscription:a,badge:O},answerTo:{id:Q,userId:Q,key:aL,pictureUrl:m,displayName:aM,position:a,job:a,country:g,city:p,level:aN,rating:aO,publicStatus:i,publicStatusMessage:a},status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:aK,childrenComments:a,likes:{count:h,status:a}}],likes:{count:aw,status:a}},{id:557274,time:1596976586534,message:"После просмотра видеоролика больше вопросов, чем ответов, во всяком случае у меня.",owner:{id:aP,userId:aP,key:"github#55682148",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2392258\u002Foriginal.jpeg",displayName:"Erik",position:a,job:a,country:g,city:x,level:25,rating:352,publicStatus:i,publicStatusMessage:a,isFriend:a,subscription:a,badge:a},answerTo:a,status:e,visibilityStatus:c,attributes:{answer:b,useful:b},parentCommentId:a,childrenComments:[],likes:{count:h,status:a}}],siteMetaData:{title:R,description:aQ,ogTitle:R,ogDescription:aQ,ogPageUrl:"\u002Fgroups\u002Fposts\u002F1993-mnogopotochnostjh-chto-delajut-metodih-klassa-thread",ogPictureUrl:"https:\u002F\u002Fjavarush.ru\u002Fimages\u002Farticle\u002Fa7b37e99-94fd-4795-b95b-cb659ac50939\u002Foriginal.png"},commentsCount:ad}}(null,false,"PUBLIC","","UNVERIFIED","ACTIVE","Россия",0,"STRONG",2273741,22,2105047,"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Fanonymous.svg",565801,17,"Москва",2412909,20,"google#109464292040820866931","https:\u002F\u002Fjavarush.ru\u002Fpictures\u002F2273741\u002Favatar\u002F5v0dk953.png","Павел ","Подольск",351,"Новосибирск","google#111797909486156556924","https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2105047\u002Foriginal.png","Учиха Шисуи",606,19,2437405,2416255,2204027,2241979,610505,"anonymous#2412909","https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2412909\u002Foriginal.jpeg","Е К","Краснодар",520,2377421,"EXPERT",2310084,2361665,"Многопоточность: что делают методы класса Thread",18,"google#111088516188669462182","https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2437405\u002Foriginal.jpeg","Кирилл",335,602291,"anonymous#2416255","https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2416255\u002Foriginal.jpeg","𝔐𝔢𝔱𝔞𝔪𝔬𝔯𝔭𝔥𝔬𝔤𝔢𝔫𝔢𝔰𝔦𝔰","Житомир",529,"Иван",true,109,5,1770672,644125,"anonymous#2204027","Andrzej Latysz",363,2444871,2181104,"Санкт-Петербург",2275993,625277,"anonymous#2241979","Алексей","Night city",430,2328484,2399651,2421688,2,1812875,28,"google#102533881098458520784","https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2377421\u002Foriginal.jpeg","Udjin",412,3,2395987,838725,"anonymous#2310085","Рязань",518,2302914,561907,"anonymous#2361665","wan-derer.ru",39,1214,2392258,"Привет! Сегодня продолжаем говорить о многопоточности. Рассмотрим класс Thread и работу его нескольких методов. Раньше, когда мы изучали методы класса, чаще все"))],session:(function(a,b,c){return {cookie:"_ga=GA1.2.1635737358.1591724185; _fbp=fb.1.1591724185323.1870404734; intercom-id-mqlef7yz=84d17a4c-0270-4786-829d-112c48d9097f; intercom-session-mqlef7yz=; jr-site-tour-default=completed; __stripe_mid=1f326e89-6d32-436a-aca4-107fa6585a232446de; jr-sidebar-group-training-collapsed=0; jr-sidebar-mode=FULL; javarush.user.id=2496069; JSESSIONID=3d655f8b-b927-47d3-be89-86d3188d4a91; javarush.internet.user.key=5361539; javarush.daynight=; _gid=GA1.2.1389844986.1610214788; jr-last-route=%2Fquests%2Flectures%2Fquestcore.level07.lecture01",userIp:"::ffff:10.100.20.20",isDeviceMobile:b,me:{id:2496069,key:"anonymous#2496070",pictureUrl:"https:\u002F\u002Fcdn.javarush.ru\u002Fimages\u002Favatar\u002F2496069\u002Foriginal.jpeg",displayName:"Fomin Dmitriy",prefferedLanguage:"RU",level:17,sublevel:9,blackMatter:608,rating:144,country:a,city:"Москва",isMailSet:c,isPasswordSet:c,email:"necronaft@mail.ru",phone:a,statusCode:"active",statusMessage:a,premiumStatus:"PREMIUM",roleStatus:"USER",userFeatures:["QUEST_JAVA_SYNTAX","QUEST_JAVA_SYNTAX_LOW","QUEST_JAVA_SYNTAX_HEIGHT","QUEST_JAVA_CORE","QUEST_JAVA_MULTITHREADING","QUEST_JAVA_COLLECTIONS","QUEST_GAMES","TASK_VALIDATION_INFO","TASK_VALIDATION_RECOMMENDATION_INFO","TASK_EXECUTION_INFO","TASK_COMPILATION_INFO","BONUS_TASKS","PRIORITY_VERIFICATION","FORUM_INVITATION","SMART_WEB_EDITOR","TASK_SAVING","QUEST_TUTORIAL"]},isCompact:b,colorTheme:"dark"}}(null,false,true))};var s=document.createElement("script");try{new Function("if(0)import('')")();s.src="/client/client.ce79b86b.js";s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@2.0.4.js";s.setAttribute("data-main","/client/client.ce79b86b.js")}document.head.appendChild(s)</script>  <title>Многопоточность: что делают методы класса Thread</title><meta name="description" content="Привет! Сегодня продолжаем говорить о многопоточности. Рассмотрим класс Thread и работу его нескольких методов. Раньше, когда мы изучали методы класса, чаще все" data-svelte="svelte-1cntlp0"><meta property="og:title" content="Многопоточность: что делают методы класса Thread" data-svelte="svelte-1cntlp0"><meta property="og:description" content="Привет! Сегодня продолжаем говорить о многопоточности. Рассмотрим класс Thread и работу его нескольких методов. Раньше, когда мы изучали методы класса, чаще все" data-svelte="svelte-1cntlp0"><meta property="og:url" content="/groups/posts/1993-mnogopotochnostjh-chto-delajut-metodih-klassa-thread" data-svelte="svelte-1cntlp0"><meta property="og:image" content="https://javarush.ru/images/article/a7b37e99-94fd-4795-b95b-cb659ac50939/original.png" data-svelte="svelte-1cntlp0"><meta property="og:site_name" content="JavaRush" data-svelte="svelte-1cntlp0"><meta property="og:type" content="website" data-svelte="svelte-1cntlp0"><link rel="canonical" href="https://javarush.ru/groups/posts/1993-mnogopotochnostjh-chto-delajut-metodih-klassa-thread" data-svelte="svelte-1cntlp0"><script type="application/ld+json">{
                                                            "@context": "http://schema.org",
                                                            "@type": "Article",
                                                            "mainEntityOfPage": {
                                                              "@type": "WebPage",
                                                              "@id": "https://javarush.ru/groups/posts/1993-mnogopotochnostjh-chto-delajut-metodih-klassa-thread"
                                                            },
                                                            "headline": "Многопоточность: что делают методы класса Thread",
                                                            "description": "Привет! Сегодня продолжаем говорить о многопоточности. Рассмотрим класс Thread и работу его нескольких методов. Раньше, когда мы изучали методы класса, чаще всего просто писали это так: «название метода» -&gt; «что он делает». С методами Thread так не получится :) ...",
                                                            "image": [
                                                              "https://cdn.javarush.ru/images/article/a11feba5-e610-4125-bce8-a8e73bc30eb6/original.jpeg"
                                                            ],
                                                            "datePublished": "2018-09-27T16:41:58.000Z",
                                                            "dateModified": "2018-11-15T09:23:50.593Z",
                                                            "author": {
                                                              "@type": "Person",
                                                              "name": "Professor Hans Noodles"
                                                            },
                                                            "publisher": {
                                                              "@type": "Organization",
                                                              "name": "JavaRush",
                                                              "logo": {
                                                                "@type": "ImageObject",
                                                                "url": "https://javarush.ru/assets/images/site/logo/logo-short.svg"
                                                              }
                                                            }
                                                          }</script> <script> (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                                                                  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                                                                j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                                                                'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                                                              })(window,document,'script','dataLayer','GTM-NH6ZXRJ'); </script> </head> <body> <div id=sapper>


                                                          <main class=""><div class="javarush-site"><div class="sidebar"><nav class="sidebar-nav"><a href="https://javarush.ru/" class="sidebar-nav__home"><div class="sidebar-nav__logo-container"><img src="/sapper/assets/images/site/logo/sidebar-logo.svg" class="sidebar-nav__logo" alt="JavaRush"></div></a>
                                                              <div class="sidebar-nav__sections"><div class="side-bar-group"><div class="sidebar-group-head sidebar-group-head--has-collapse"><a href="https://javarush.ru/learn" class="sidebar-group-head__link">
                                                          Обучение
                                                          </a>

                                                              <button class="sidebar-group-head__collapse"><span class="sidebar-group-head__collapse-icon"><svg class="icon icon--common-caret" aria-hidden="true"><use xlink:href="/sapper/assets/icons/common.svg?v=19#icon-caret"></use></svg></span></button></div>
                                                            <div class="sidebar-group-items"><div class="sidebar-nav-item" data-site-tour-target="QUESTS"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-course" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-course"></use></svg></div>





                                                            <a href="https://javarush.ru/quests" class="sidebar-nav-link"><div class="sidebar-nav-label">Курс</div>
                                                          </a></div><div class="sidebar-nav-item" data-site-tour-target="TASKS"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-tasks" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-tasks"></use></svg></div>





                                                            <a href="https://javarush.ru/tasks" class="sidebar-nav-link"><div class="sidebar-nav-label">Задачи</div>
                                                          </a></div><div class="sidebar-nav-item" data-site-tour-target="QUIZZES"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-quizzes" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-quizzes"></use></svg></div>





                                                            <a href="https://javarush.ru/quizzes" class="sidebar-nav-link"><div class="sidebar-nav-label">Опросы</div>
                                                          </a></div><div class="sidebar-nav-item" data-site-tour-target="PROJECTS"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-games" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-games"></use></svg></div>





                                                            <a href="https://javarush.ru/projects/games" class="sidebar-nav-link"><div class="sidebar-nav-label">Игры</div>
                                                          </a></div><div class="sidebar-nav-item" data-site-tour-target="HELP"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-help" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-help"></use></svg></div>





                                                            <a href="https://javarush.ru/help" class="sidebar-nav-link"><div class="sidebar-nav-label">Помощь</div>
                                                          </a></div><div class="sidebar-nav-item" data-site-tour-target="NONE"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-kick" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-kick"></use></svg></div>





                                                            <a href="https://javarush.ru/schedule" class="sidebar-nav-link"><div class="sidebar-nav-label">График пинков</div>
                                                          </a></div><div class="sidebar-nav-item" data-site-tour-target="INTERNSHIP"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-internship" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-internship"></use></svg></div>





                                                            <a href="https://javarush.ru/internship" class="sidebar-nav-link"><div class="sidebar-nav-label">Стажировка</div>
                                                          </a></div></div></div><div class="side-bar-group"><div class="sidebar-group-head sidebar-group-head--has-collapse"><a href="https://javarush.ru/community" class="sidebar-group-head__link">
                                                          Сообщество
                                                          </a>

                                                              <button class="sidebar-group-head__collapse"><span class="sidebar-group-head__collapse-icon"><svg class="icon icon--common-caret" aria-hidden="true"><use xlink:href="/sapper/assets/icons/common.svg?v=19#icon-caret"></use></svg></span></button></div>
                                                            <div class="sidebar-group-items"><div class="sidebar-nav-item" data-site-tour-target="USERS"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-friends" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-friends"></use></svg></div>





                                                            <a href="https://javarush.ru/users" class="sidebar-nav-link"><div class="sidebar-nav-label">Друзья</div>
                                                          </a></div><div class="sidebar-nav-item" data-site-tour-target="FORUM"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-forum" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-forum"></use></svg></div>





                                                            <a href="https://javarush.ru/forum" class="sidebar-nav-link"><div class="sidebar-nav-label">Форум</div>
                                                          </a></div><div class="sidebar-nav-item" data-site-tour-target="CHAT"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-chat" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-chat"></use></svg></div>





                                                            <a href="https://javarush.ru/chat" class="sidebar-nav-link"><div class="sidebar-nav-label">Чат</div>
                                                          </a></div><div class="sidebar-nav-item sidebar-nav-item--active" data-site-tour-target="GROUPS"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-articles" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-articles"></use></svg></div>





                                                            <a href="https://javarush.ru/groups/posts" class="sidebar-nav-link"><div class="sidebar-nav-label">Статьи</div>
                                                          </a></div><div class="sidebar-nav-item" data-site-tour-target="NONE"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-success-stories" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-success-stories"></use></svg></div>





                                                            <a href="https://javarush.ru/groups/stories" class="sidebar-nav-link"><div class="sidebar-nav-label">Истории успеха</div>
                                                          </a></div><div class="sidebar-nav-item" data-site-tour-target="NEWS"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-activity" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-activity"></use></svg></div>





                                                            <a href="https://javarush.ru/news" class="sidebar-nav-link"><div class="sidebar-nav-label">Активности</div>
                                                          </a></div><div class="sidebar-nav-item" data-site-tour-target="NONE"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-reviews" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-reviews"></use></svg></div>





                                                            <a href="https://javarush.ru/about/reviews" class="sidebar-nav-link"><div class="sidebar-nav-label">Отзывы</div>
                                                          </a></div></div></div><div class="side-bar-group"><div class="sidebar-group-head sidebar-group-head--has-collapse"><a href="https://javarush.ru/me" class="sidebar-group-head__link">
                                                          Мой аккаунт
                                                          </a>

                                                              <button class="sidebar-group-head__collapse"><span class="sidebar-group-head__collapse-icon"><svg class="icon icon--common-caret" aria-hidden="true"><use xlink:href="/sapper/assets/icons/common.svg?v=19#icon-caret"></use></svg></span></button></div>
                                                            <div class="sidebar-group-items"><div class="sidebar-nav-item" data-site-tour-target="DIALOGUES"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-dialogues" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-dialogues"></use></svg></div>





                                                            <a href="https://javarush.ru/dialogues" class="sidebar-nav-link"><div class="sidebar-nav-label">Сообщения</div>
                                                          </a></div><div class="sidebar-nav-item" data-site-tour-target="NONE"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-notifications" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-notifications"></use></svg></div>





                                                            <a href="https://javarush.ru/dialogues/notices" class="sidebar-nav-link"><div class="sidebar-nav-label">Уведомления</div>
                                                          </a></div><div class="sidebar-nav-item" data-site-tour-target="PRICES"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-subscriptions" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-subscriptions"></use></svg></div>





                                                            <a href="https://javarush.ru/prices" class="sidebar-nav-link"><div class="sidebar-nav-label">Подписки</div>
                                                          </a></div><div class="sidebar-nav-item" data-site-tour-target="NONE"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-rating" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-rating"></use></svg></div>





                                                            <a href="https://javarush.ru/rating" class="sidebar-nav-link"><div class="sidebar-nav-label">Рейтинги</div>
                                                          </a></div><div class="sidebar-nav-item" data-site-tour-target="NONE"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-support" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-support"></use></svg></div>





                                                            <a href="https://javarush.ru/dialogues/administration" class="sidebar-nav-link"><div class="sidebar-nav-label">Поддержка</div>
                                                          </a></div><div class="sidebar-nav-item" data-site-tour-target="NONE"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-settings" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-settings"></use></svg></div>





                                                            <a href="https://javarush.ru/settings" class="sidebar-nav-link"><div class="sidebar-nav-label">Настройки</div>
                                                          </a></div><div class="sidebar-nav-item" data-site-tour-target="NONE"><div class="sidebar-nav-icon"><svg class="icon icon--sidebar-nav-bookmarks" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-bookmarks"></use></svg></div>





                                                            <a href="https://javarush.ru/bookmarks" class="sidebar-nav-link"><div class="sidebar-nav-label">Закладки</div>
                                                          </a></div></div></div></div></nav>
                                                            <button title="Свернуть" type="button" class="sidebar-nav__toggle"><span class="sidebar-nav__toggle-icon"><svg class="icon icon--common-caret" aria-hidden="true"><use xlink:href="/sapper/assets/icons/common.svg?v=19#icon-caret"></use></svg></span></button></div>
                                                              <div class="site-layout site-layout--post-page"><div class="site-layout__container"><div class="site-layout__main"><div class="site-layout__overlay"><svg class="icon icon--common-cross" aria-hidden="true"><use xlink:href="/sapper/assets/icons/common.svg?v=19#icon-cross"></use></svg></div>
                                                                    <div class="site-layout__header"><header class="site-header"><div class="site-header__container"><div class="site-header__toggle-menu"><button class="toggle-menu-button" type="button" aria-label="Открыть меню"><div class="toggle-menu-button__icon"></div></button></div>
                                                              <div class="site-header__title-and-search"><div class="site-header__title"><div class="site-header-title">Статья</div></div>

                                                                <div class="site-header__search"><div><div class="header-search-panel"><input type="search" class="header-search-panel__input" placeholder="Поиск">
                                                              <div class="header-search-panel__icon"><svg class="icon icon--common-search" aria-hidden="true"><use xlink:href="/sapper/assets/icons/common.svg?v=19#icon-search"></use></svg></div>
                                                              <button class="header-search-panel__close" type="button"><svg class="icon icon--common-cross" aria-hidden="true"><use xlink:href="/sapper/assets/icons/common.svg?v=19#icon-cross"></use></svg></button></div></div></div></div>
                                                              <div class="site-header__user-panel"><div class="me-short-panel-host"><a href="https://javarush.ru/me" class="me-short-panel"><div class="me-short-panel__avatar"><figure class="avatar avatar--smd"><div style="background-image: url('https://cdn.javarush.ru/images/avatar/2496069/64.webp')" class="avatar__image" role="img"></div>
                                                            <figcaption class="avatar__caption">
                                                              Fomin Dmitriy</figcaption></figure></div>
                                                              <div class="me-short-panel__info"><div class="me-short-panel__name-and-level"><div class="me-short-panel__name" title="Fomin Dmitriy">Fomin Dmitriy</div>
                                                                  <div class="me-short-panel__level">17 уровень</div></div>
                                                                <div class="me-short-panel__force"><div class="me-short-panel__dark-matter"><div class="dark-matter"><div class="dark-matter__icon"><svg class="icon icon--common-dark-matter" aria-hidden="true"><use xlink:href="/sapper/assets/icons/common.svg?v=19#icon-dark-matter"></use></svg></div>
                                                                      <div class="dark-matter__value">608</div></div></div></div></div></a></div>
                                                                  <div class="site-header__subscription-status"><a href="https://javarush.ru/prices/my" class="me-subscription-status"><div class="subscription-status subscription-status--premium"><div class="subscription-status__label">Premium</div></div></a></div>
                                                                  <div class="site-header__notifications"><div class="user-notifications"><a class="user-notifications__link" href="https://javarush.ru/dialogues"><div class="user-notifications__icon"><svg class="icon icon--sidebar-nav-dialogues" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-dialogues"></use></svg></div>
                                                                        </a>

                                                                      <a class="user-notifications__link" href="https://javarush.ru/dialogues/notices"><div class="user-notifications__icon"><svg class="icon icon--sidebar-nav-notifications" aria-hidden="true"><use xlink:href="/sapper/assets/icons/sidebar-nav.svg?v=19#icon-notifications"></use></svg></div>
                                                                        </a></div></div></div>

                                                              <div class="site-header__theme-switcher"><div class="switcher-daynight"><input class="switcher-daynight__checkbox" type="checkbox">
                                                            <div class="switcher-daynight__track"><div class="switcher-daynight__toggle"></div>
                                                              <div class="switcher-daynight__icon switcher-daynight__icon--night"><svg class="icon icon--common-night-mode" aria-hidden="true"><use xlink:href="/sapper/assets/icons/common.svg?v=19#icon-night-mode"></use></svg></div>
                                                              <div class="switcher-daynight__icon switcher-daynight__icon--day"><svg class="icon icon--common-day-mode" aria-hidden="true"><use xlink:href="/sapper/assets/icons/common.svg?v=19#icon-day-mode"></use></svg></div></div></div></div></div></header></div>

                                                                    <div class="site-layout__header-guest-fixed"></div>
                                                                    <div class="site-layout__content">

                                                          <div class="page"><div class="page__nav container-narrow"><div class="tabs"><ul class="tabs__list" role="tablist"><li class="tabs__item"><a class="tabs__button" href="https://javarush.ru/groups/posts">Список статей</a>
                                                                  </li><li class="tabs__item"><a class="tabs__button" href="https://javarush.ru/groups/all">Все группы</a>
                                                                  </li><li class="tabs__item"><a class="tabs__button" href="https://javarush.ru/groups/my">Мои группы</a>
                                                                  </li></ul></div></div>
                                                            <div class="page__content"><article class="article"><div class="article__head container-narrow"><div class="post-head"><div class="post-head__user"><a href="https://javarush.ru/users/1770672" target="_blank" class="user-short-info-card"><div class="user-short-info-card__avatar"><figure class="avatar avatar--lg"><div style="background-image: url('https://cdn.javarush.ru/images/avatar/1770672/128.webp')" class="avatar__image" role="img"></div>
                                                            <figcaption class="avatar__caption">Пользователь
                                                              Professor Hans Noodles</figcaption></figure></div>
                                                            <div class="user-short-info-card__name">Professor Hans Noodles</div>
                                                            <div class="user-short-info-card__level">41 уровень</div>
                                                            </a></div>
                                                            <div class="post-head__info"><div class="post-head__meta"><ul class="post-meta-panel"><li class="post-meta-panel__item post-meta-panel__date"><span class="post-meta-panel__icon"><svg class="icon icon--common-date" aria-hidden="true"><use xlink:href="/sapper/assets/icons/common.svg?v=19#icon-date"></use></svg></span>
                                                                <span class="post-meta-panel__value">27 сентября 2018</span></li>
                                                            <li class="post-meta-panel__item post-meta-panel__hits"><span class="post-meta-panel__icon"><svg class="icon icon--common-hits" aria-hidden="true"><use xlink:href="/sapper/assets/icons/common.svg?v=19#icon-hits"></use></svg></span>
                                                                <span class="post-meta-panel__value">47142</span>
                                                                <span class="post-meta-panel__label">просмотров</span></li>
                                                            <li class="post-meta-panel__item post-meta-panel__comments"><a class="post-meta-panel__link" href="https://javarush.ru/groups/posts/1993-mnogopotochnostjh-chto-delajut-metodih-klassa-thread#discussion"><span class="post-meta-panel__icon"><svg class="icon icon--common-comments" aria-hidden="true"><use xlink:href="/sapper/assets/icons/common.svg?v=19#icon-comments"></use></svg></span>
                                                                  <span class="post-meta-panel__value">109</span>
                                                                  <span class="post-meta-panel__label">комментариев</span>
                                                                  </a></li>
                                                            </ul></div>
                                                              <h1 class="post-head__title">Многопоточность: что делают методы класса Thread</h1>
                                                              <div class="post-head__source"><div class="post-source-meta"><div class="post-source-meta__main"><a class="post-source-meta__link" href="https://javarush.ru/groups/java-developer">Статья из группы
                                                                      Java Developer</a></div>
                                                                  <div class="post-source-meta__extra">28028
                                                                      участников
                                                                    </div></div></div>
                                                              <div class="post-head__status"><button class="button button--md button--info-alt">Присоединиться</button>

                                                            </div></div></div></div>
                                                                  <div id="post-content" class="article__content container-narrow"><div class="content content--raw">Привет! Сегодня продолжаем говорить о многопоточности. Рассмотрим класс Thread и работу его нескольких методов. Раньше, когда мы изучали методы класса, чаще всего просто писали это так: «название метода» -> «что он делает».
                                                          <div class='row justify-content-center jr-image-wrap'><div class='col-12 col-sm-10 col-md-8'><img data-id="a721b583-c502-4047-b2d9-a49895b5a89a" data-max-width="710" alt="Многопоточность: что делают методы класса Thread - 1" data-src="https://cdn.javarush.ru/images/article/a721b583-c502-4047-b2d9-a49895b5a89a/1024.jpeg"></div></div>С методами Thread так не получится :) Их логика сложнее, и без нескольких примеров не разобраться.

                                                          <h2>Метод Thread.start()</h2>Начнем с повторения. Как ты наверняка помнишь, создать поток можно унаследовав свой класс от класса <code>Thread</code> и переопределив в нем метод <code>run()</code>.

                                                          Но сам он, конечно, не запустится. Для этого у нашего объекта вызываем метод <code>start()</code>.
                                                          <img data-id="b9b6e5a5-b771-4c79-8122-2e453ab57ace" data-max-width="850" alt="Многопоточность: что делают методы класса Thread - 2" data-src="https://cdn.javarush.ru/images/article/b9b6e5a5-b771-4c79-8122-2e453ab57ace/1024.jpeg">Давай вспомним пример из предыдущей лекции:

                                                          <pre class='lang-java line-numbers'><code>
                                                          public class MyFirstThread extends Thread {

                                                             @Override
                                                             public void run() {
                                                                 System.out.println("Выполнен поток " + getName());
                                                             }
                                                          }


                                                          public class Main {

                                                             public static void main(String[] args) {

                                                                 for (int i = 0; i < 10; i++) {
                                                                     MyFirstThread thread = new MyFirstThread();
                                                                     thread.start();
                                                                 }
                                                             }
                                                          }
                                                          </code></pre>
                                                          <em><strong>Обрати внимание:</strong></em> чтобы запустить поток, необходимо вызвать специальный метод <code>start()</code>, а не метод <code>run()</code>! Эту ошибку легко допустить, особенно в начале изучения многопоточности.

                                                          Если в нашем примере ты 10 раз вызовешь у объекта метод <code>run()</code> вместо <code>start()</code>, результат будет таким:

                                                          <pre class='lang-java line-numbers'><code>
                                                          public class Main {

                                                             public static void main(String[] args) {

                                                                 for (int i = 0; i < 10; i++) {
                                                                     MyFirstThread thread = new MyFirstThread();
                                                                     thread.run();
                                                                 }
                                                             }
                                                          }
                                                          </code></pre>

                                                          <em><strong>Выполнен поток Thread-0
                                                          Выполнен поток Thread-1
                                                          Выполнен поток Thread-2
                                                          Выполнен поток Thread-3
                                                          Выполнен поток Thread-4
                                                          Выполнен поток Thread-5
                                                          Выполнен поток Thread-6
                                                          Выполнен поток Thread-7
                                                          Выполнен поток Thread-8
                                                          Выполнен поток Thread-9</strong></em>

                                                          Посмотри на последовательность вывода: все идет строго по порядку. Странно, да? Мы к такому не привыкли, ведь уже знаем, что порядок запуска и выполнения потоков определяет сверхразум внутри нашей операционной системы — планировщик потоков. Может, просто повезло?

                                                          Конечно, дело не в везении. В этом можешь убедиться, запустив программу еще пару раз.

                                                          Дело в том, что прямой вызов метода <code>run()</code> не имеет отношения к многопоточности. В этом случае программа будет выполнена в главном потоке — том, в котором выполняется метод <code>main()</code>. Он просто последовательно выведет 10 строк на консоль и все. Никакие 10 потоков не запустятся.

                                                          Поэтому запомни на будущее и постоянно себя проверяй. Хочешь, чтобы выполнился <code>run()</code>, вызывай <code>start()</code>. Поехали дальше.

                                                          <h2>Метод Thread.sleep()</h2>Для приостановки выполнения текущего потока на какое-то время, используем метод <code>sleep()</code>.
                                                          <img data-id="1e9f01d2-6dba-4189-9bf6-121c25c29110" data-max-width="850" alt="Многопоточность: что делают методы класса Thread - 3" data-src="https://cdn.javarush.ru/images/article/1e9f01d2-6dba-4189-9bf6-121c25c29110/1024.jpeg">Метод <code>sleep()</code> принимает в качестве параметра число миллисекунд, то есть то время, на которое необходимо «усыпить» поток.

                                                          <pre class='lang-java line-numbers'><code>
                                                          public class Main {

                                                             public static void main(String[] args) throws InterruptedException {

                                                                 long start = System.currentTimeMillis();

                                                                 Thread.sleep(3000);

                                                                 System.out.println(" - Сколько я проспал? \n - " + ((System.currentTimeMillis()-start)) / 1000 + " секунды");

                                                             }
                                                          }
                                                          </code></pre>
                                                          <strong>Вывод в консоль:

                                                          <em> - Сколько я проспал?
                                                           - 3 секунды</em></strong>

                                                          Обрати внимание: метод <code>sleep()</code> — статический: он усыпляет текущий поток. То есть тот, который работает в данный момент.

                                                          Еще один важный нюанс: поток в состоянии сна можно прервать. В таком случае в программе возникнет исключение <code>InterruptedException</code>. Мы рассмотрим пример ниже.

                                                          Кстати, а что произойдет после того, как поток «проснется»? Продолжит ли он сразу же свое выполнение с того места, где закончил? Нет.

                                                          После того, как поток «просыпается» — когда заканчивается время, переданное в качестве аргумента в <code>Thread.sleep()</code>, — он переходит в состояние <em>runnable</em>, «работоспособный». Однако это не значит, что планировщик потоков запустит именно его. Вполне возможно, он отдаст предпочтение какому-то другому «неспящему» потоку, а наш «свежепроснувшийся» продолжит работу чуть позже.

                                                          Обязательно запомни: «проснулся — не значит продолжил работать в ту же секунду»!

                                                          <h2>Метод Thread.join()</h2><img data-id="c3c0548b-4341-4b3f-a577-44ba15c84b23" data-max-width="850" alt="Многопоточность: что делают методы класса Thread - 4" data-src="https://cdn.javarush.ru/images/article/c3c0548b-4341-4b3f-a577-44ba15c84b23/1024.jpeg">Метод <code>join()</code> приостанавливает выполнение текущего потока до тех пор, пока не завершится другой поток.

                                                          Если у нас есть 2 потока, <code>t1</code> и <code>t2</code>, и мы напишем —

                                                          <pre class='lang-java line-numbers'><code>
                                                          t1.join()
                                                          </code></pre>
                                                          <code>t2</code> не начнет работу, пока t1 не завершит свою. Метод <code>join()</code> можно использовать, чтобы гарантировать последовательность выполнения потоков.

                                                          Давай рассмотрим работу <code>join()</code> на примере:

                                                          <pre class='lang-java line-numbers'><code>
                                                          public class ThreadExample extends Thread {

                                                             @Override
                                                             public void run() {

                                                                 System.out.println("Начало работы потока " + getName());

                                                                 try {
                                                                     Thread.sleep(5000);
                                                                 } catch (InterruptedException e) {
                                                                     e.printStackTrace();
                                                                 }
                                                                 System.out.println("Поток " + getName() +  " завершил работу.");
                                                             }
                                                          }


                                                          public class Main {

                                                             public static void main(String[] args) throws InterruptedException {

                                                                 ThreadExample t1 = new ThreadExample();
                                                                 ThreadExample t2 = new ThreadExample();

                                                                 t1.start();


                                                           /*Второй поток t2 начнет выполнение только после того, как будет завершен
                                                                 (или бросит исключение) первый поток - t1*/
                                                                 try {
                                                                     t1.join();
                                                                 } catch (InterruptedException e) {
                                                                     e.printStackTrace();
                                                                 }

                                                                 t2.start();

                                                                 //Главный поток продолжит работу только после того, как t1 и t2 завершат работу
                                                                 try {
                                                                     t1.join();
                                                                     t2.join();
                                                                 } catch (InterruptedException e) {
                                                                     e.printStackTrace();
                                                                 }

                                                                 System.out.println("Все потоки закончили работу, программа завершена");

                                                             }
                                                          }
                                                          </code></pre>
                                                          Мы создали простой класс <code>ThreadExample</code>. Его задача — вывести на экран сообщение о начале работы, потом уснуть на 5 секунд и в конце сообщить о завершении работы. Ничего сложного.

                                                          Главная логика заключена в классе <code>Main</code>. Посмотри на комментарии: с помощью метода <code>join()</code> мы успешно управляем последовательностью выполнения потоков. Если ты вспомнишь начало темы, этим занимался планировщик потоков. Он запускал их на свое усмотрение: каждый раз по-разному.

                                                          Здесь же мы с помощью метода гарантировали, что сначала будет запущен и выполнен поток <code>t1</code>, затем — <code>t2</code>, и только после них — главный поток выполнения программы.

                                                          Идем дальше.

                                                          В реальных программах тебе не раз встретятся ситуации, когда необходимо будет прервать выполнение какого-то потока.

                                                          Например, наш поток выполняется, но при этом ждет определенного события или выполнения условия. Если это произошло, он останавливается. Было бы, наверное, логично, если бы существовал какой-то метод типа <code>stop()</code>.

                                                          Однако все не так просто. Когда-то давно метод <code><strong>Thread.stop()</strong></code> в Java действительно был и позволял прерывать работу потока. Но позже его удалили из библиотеки Java. Ты можешь найти его в документации Oracle и увидеть, что он помечен как <em>deprecated</em>.

                                                          Почему? Потому что он просто останавливал поток без какой-либо дополнительной работы.

                                                          Например, поток мог работать с данными и что-то в них менять. Потом его резко вырубали методом <code>stop()</code> посреди работы — и все. Ни корректного завершения работы, ни освобождения ресурсов, ни хотя бы обработки ошибок — ничего этого не было.

                                                          Метод <code>stop()</code>, если утрировать, просто крушил все на своем пути.

                                                          Его работу можно сравнить с тем, как кто-то выдергивает вилку из розетки, чтобы выключить компьютер. Да, нужного результата добиться можно. Но все понимают, что через пару недель компьютер не скажет за это «спасибо».

                                                          По этой причине логику прерывания потоков в Java изменили, и теперь используется специальный метод — <code>interrupt()</code>.

                                                          <h2>Метод Thread.interrupt()</h2>Что произойдет, если у потока вызвать <strong>метод</strong> <code><strong>interrupt()</strong></code>?

                                                          Есть 2 варианта:

                                                          <ol>
                                                          <li>Если объект находился в этот момент в состоянии ожидания, например, <code>join</code> или <code>sleep</code>, ожидание будет прервано, и программа выбросит <code>InterruptedException</code>.</li>
                                                          <li>Если же поток в этот момент был в работоспособном состоянии, у объекта будет установлен boolean-флаг <code><strong>interrupted</strong></code>.</li></ol>
                                                          Но проверить объект на значение этого флага и корректно завершить работу мы должны будем самостоятельно! Для этого в классе <code>Thread</code> есть специальный метод — <code><strong>boolean isInterrupted()</strong></code>.

                                                          Давай вернемся к примеру с часами, который был в лекции основного курса. Для удобства он немного упрощен:

                                                          <pre class='lang-java line-numbers'><code>
                                                          public class Clock extends Thread {

                                                             public static void main(String[] args) throws InterruptedException {
                                                                 Clock clock = new Clock();
                                                                 clock.start();

                                                                 Thread.sleep(10000);
                                                                 clock.interrupt();
                                                             }

                                                             public void run() {
                                                                 Thread current = Thread.currentThread();

                                                                 while (!current.isInterrupted())
                                                                 {
                                                                     try {
                                                                         Thread.sleep(1000);
                                                                     } catch (InterruptedException e) {
                                                                         System.out.println("Работа потока была прервана");
                                                                         break;
                                                                     }
                                                                     System.out.println("Tik");
                                                                 }
                                                             }
                                                          }
                                                          </code></pre>
                                                          В нашем случае часы стартуют и начинают тикать каждую секунду. На 10-й секунде мы прерываем поток часов.

                                                          Как ты уже знаешь, если поток, который мы пытаемся прервать, находится в одном из состояний ожидания, это приводит к <code>InterruptedException</code>. Данный вид исключения — проверяемый, поэтому его можно легко перехватить и выполнить нашу логику завершения программы. Что мы и сделали.

                                                          <strong>Вот наш результат:</strong>

                                                          <em><strong>Tik
                                                          Tik
                                                          Tik
                                                          Tik
                                                          Tik
                                                          Tik
                                                          Tik
                                                          Tik
                                                          Tik</strong></em>

                                                          Работа потока была прервана

                                                          На этом мы заканчиваем знакомство с основными методами класса <code>Thread</code>.

                                                          Чтобы закрепить знания, можешь посмотреть эту видеолекцию о многопоточности:
                                                          <div class="row">
                                                          <div class="col col-md-10 col-lg-8">
                                                          <div class="embed-responsive embed-responsive-16by9">
                                                          <iframe width="560" height="315" src="https://www.youtube.com/embed/zxZ0BXlTys0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                                                          </div>
                                                          </div>
                                                          </div>она послужит отличным дополнительным материалом! В конце, после обзора методов, в ней рассказывается как раз о том, что мы будем проходить дальше по курсу :)

                                                          Успехов!</div></div>
                                                                  <div class="article__discussion"><div class="discussion-wrap"><div class="share-and-rating"><div class="share-and-rating__container"><div class="share-and-rating__share"><div class="discussion-sharing"><div class="discussion-sharing__item"><div class="social-button-wrap"><a class="social-button social-button--vk social-button--sm"><span class="social-button__icon"><svg class="icon icon--social-vk" aria-hidden="true"><use xlink:href="/sapper/assets/icons/social.svg?v=19#icon-vk"></use></svg></span>
                                                              </a></div></div>
                                                            <div class="discussion-sharing__item"><div class="social-button-wrap"><a class="social-button social-button--facebook social-button--sm"><span class="social-button__icon"><svg class="icon icon--social-facebook" aria-hidden="true"><use xlink:href="/sapper/assets/icons/social.svg?v=19#icon-facebook"></use></svg></span>
                                                              </a></div></div>
                                                            <div class="discussion-sharing__item"><div class="social-button-wrap"><a class="social-button social-button--linkedin social-button--sm"><span class="social-button__icon"><svg class="icon icon--social-linkedin" aria-hidden="true"><use xlink:href="/sapper/assets/icons/social.svg?v=19#icon-linkedin"></use></svg></span>
                                                              </a></div></div>
                                                            <div class="discussion-sharing__item"><div class="social-button-wrap"><a class="social-button social-button--twitter social-button--sm"><span class="social-button__icon"><svg class="icon icon--social-twitter" aria-hidden="true"><use xlink:href="/sapper/assets/icons/social.svg?v=19#icon-twitter"></use></svg></span>
                                                              </a></div></div></div></div>
                                                                  <div class="share-and-rating__stars"></div>
                                                                  <div class="share-and-rating__rating"></div></div></div>

                                                            <div class="comments-container" id="discussion"><div class="comments-head d-sm-flex"><div class="comments-head__title">Комментарии
                                                              (109)</div></div>
                                                              <div class="comments vertical-gutter-bottom"><div class="comment-layout"><div class="no-content"><div class="no-content__body"><span class="text-uppercase">Чтобы просмотреть все комментарии или
                                                                        оставить свой,<br>
                                                                        <span class="link">перейдите в полную версию</span></span></div></div></div>
                                                                <div class="comment-layout"><div class="comment-wrap"><div class="comment"><span class="ava__wrapper"><a href="https://javarush.ru/users/2204027" target="_blank" class="ava" tabindex="-1" style="background-image: url('https://cdn.javarush.ru/images/anonymous.svg')"><span></span></a></span>
                                                              <div class="comment-head"><div class="head-left"><a href="https://javarush.ru/users/2204027" target="_blank" class="user">Andrzej Latysz</a>
                                                                  <span class="more-info">22
                                                                    уровень</span>



                                                                  </div>
                                                                <div class="head-right"><span class="date">22 декабря 2020</span>
                                                                  </div></div>
                                                              <div class="comment-body"><div class="view-text">Прошу прощения но в следующем предложении, кажется содержится ошибка - "Метод join() приостанавливает выполнение текущего потока до тех пор, пока не завершится другой поток."</div></div></div></div>
                                                                  </div><div class="comment-layout"><div class="comment-wrap"><div class="comment"><span class="ava__wrapper"><a href="https://javarush.ru/users/2181104" target="_blank" class="ava" tabindex="-1" style="background-image: url('https://cdn.javarush.ru/images/anonymous.svg')"><span></span></a></span>
                                                              <div class="comment-head"><div class="head-left"><a href="https://javarush.ru/users/2181104" target="_blank" class="user">Игорь</a>
                                                                  <span class="more-info">26
                                                                    уровень, Санкт-Петербург</span>



                                                                  </div>
                                                                <div class="head-right"><span class="date">7 декабря 2020</span>
                                                                  </div></div>
                                                              <div class="comment-body"><div class="view-text">По-моему это лишнее
                                                             Thread current = Thread.currentThread();

                                                          Можно просто написать :

                                                              public void run() {
                                                                  while (!isInterrupted())
                                                                  {
                                                               ///код
                                                                  }
                                                              }

                                                          </div></div></div></div>
                                                                  </div><div class="comment-layout"><div class="comment-wrap"><div class="comment"><span class="ava__wrapper"><a href="https://javarush.ru/users/2275993" target="_blank" class="ava" tabindex="-1" style="background-image: url('https://cdn.javarush.ru/images/avatar/2275993/64.webp')"><span></span></a></span>
                                                              <div class="comment-head"><div class="head-left"><a href="https://javarush.ru/users/2275993" target="_blank" class="user">Максим Дудин</a>
                                                                  <span class="more-info">18
                                                                    уровень, Калининград</span>



                                                                  </div>
                                                                <div class="head-right"><span class="date">7 декабря 2020</span>
                                                                  </div></div>
                                                              <div class="comment-body"><div class="view-text">фух.... насколько же мне проще читать текст, чем слушать лектора....  хотя он и шире излагает, но это прям на морально волевых... </div></div></div></div>
                                                                  </div><div class="comment-layout"><div class="comment-wrap"><div class="comment"><span class="ava__wrapper"><a href="https://javarush.ru/users/2241979" target="_blank" class="ava" tabindex="-1" style="background-image: url('https://cdn.javarush.ru/images/anonymous.svg')"><span></span></a></span>
                                                              <div class="comment-head"><div class="head-left"><a href="https://javarush.ru/users/2241979" target="_blank" class="user">Алексей</a>
                                                                  <span class="more-info">19
                                                                    уровень, Night city</span>



                                                                  </div>
                                                                <div class="head-right"><span class="date">23 ноября 2020</span>
                                                                  </div></div>
                                                              <div class="comment-body"><div class="view-text">"Но проверить объект на значение этого флага и корректно завершить работу мы должны будем самостоятельно!"

                                                          так как же завершить поток?</div></div></div></div>
                                                                  </div><div class="comment-layout"><div class="comment-wrap"><div class="comment"><span class="ava__wrapper"><a href="https://javarush.ru/users/2412909" target="_blank" class="ava" tabindex="-1" style="background-image: url('https://cdn.javarush.ru/images/avatar/2412909/64.webp')"><span></span></a></span>
                                                              <div class="comment-head"><div class="head-left"><a href="https://javarush.ru/users/2412909" target="_blank" class="user">Е К</a>
                                                                  <span class="more-info">20
                                                                    уровень, Краснодар</span>



                                                                  </div>
                                                                <div class="head-right"><span class="date">30 октября 2020</span>
                                                                  </div></div>
                                                              <div class="comment-body"><div class="view-text">Заинтересовала разница между volatile и synchronized.
                                                          Насколько я понял для себя - основное отличие это, то что volatile применяется только для полей(fields), а synchronized применяется для классов, экземпляров и блоков кода{}. Смысл же один - обеспечить одномоментный доступ к ресурсу.

                                                          Только вот понятно, что synchronized захватывает флаг(?) monitor. А вот механизм работы volatile не понятен мне пока. Иду гуглить)

                                                          Поправьте, если где ошибся.</div></div></div></div>
                                                                  </div><div class="comment-layout"><div class="comment-wrap"><div class="comment"><span class="ava__wrapper"><a href="https://javarush.ru/users/2416255" target="_blank" class="ava" tabindex="-1" style="background-image: url('https://cdn.javarush.ru/images/avatar/2416255/64.webp')"><span></span></a></span>
                                                              <div class="comment-head"><div class="head-left"><a href="https://javarush.ru/users/2416255" target="_blank" class="user">𝔐𝔢𝔱𝔞𝔪𝔬𝔯𝔭𝔥𝔬𝔤𝔢𝔫𝔢𝔰𝔦𝔰</a>
                                                                  <span class="more-info">20
                                                                    уровень, Житомир</span>



                                                                  </div>
                                                                <div class="head-right"><span class="date">16 октября 2020</span>
                                                                  </div></div>
                                                              <div class="comment-body"><div class="view-text">В одних примерах метод прерывается командой break; в других return;
                                                          Есть между ними разница?</div></div></div></div>
                                                                  </div><div class="comment-layout"><div class="comment-wrap"><div class="comment"><span class="ava__wrapper"><a href="https://javarush.ru/users/1812875" target="_blank" class="ava" tabindex="-1" style="background-image: url('https://cdn.javarush.ru/images/anonymous.svg')"><span></span></a></span>
                                                              <div class="comment-head"><div class="head-left"><a href="https://javarush.ru/users/1812875" target="_blank" class="user">Иван</a>
                                                                  <span class="more-info">28
                                                                    уровень, Санкт-Петербург</span>



                                                                  </div>
                                                                <div class="head-right"><span class="date">13 октября 2020</span>
                                                                  </div></div>
                                                              <div class="comment-body"><div class="view-text">Почему не сказали что в последнем примере если не будет принудительного выхода ихз цикла break; то он будет вечным даже если мы его прервали?
                                                          о том что контроль исключения на InterruptedException сбрасывает признак прерывания у потока и проверка на isInterrupted() вернет ложь Нужно было написать.
                                                          Данный пример только вводит в заблуждение и показывает пример не оптимального кода.</div></div></div></div>
                                                                  </div><div class="comment-layout"><div class="comment-wrap"><div class="comment"><span class="ava__wrapper"><a href="https://javarush.ru/users/2273741" target="_blank" class="ava" tabindex="-1" style="background-image: url('https://cdn.javarush.ru/images/avatar/2273741/64.webp')"><span></span></a></span>
                                                              <div class="comment-head"><div class="head-left"><a href="https://javarush.ru/users/2273741" target="_blank" class="user">Павел </a>
                                                                  <span class="more-info">17
                                                                    уровень, Подольск</span>



                                                                  </div>
                                                                <div class="head-right"><span class="date">23 августа 2020</span>
                                                                  </div></div>
                                                              <div class="comment-body"><div class="view-text"><pre class="lang-java line-numbers"><code>
                                                          public class Main {

                                                             public static void main(String[] args) throws InterruptedException {

                                                                 long start = System.currentTimeMillis();

                                                                 Thread.sleep(3000);

                                                                 System.out.println(" - Сколько я проспал? \n - " + ((System.currentTimeMillis()-start)) / 1000 + " секунды");

                                                             }
                                                          }
                                                          </code></pre>

                                                          Я немного запутался от большого объема информации, поправьте пожалуйста.
                                                          Метод main у нас является единственным потоком в данном случае? С помощью метода sleep приостанавливается работа главного потока main  на 3 сек. А  метод start у нас используется, только тогда, когда в программе помимо основного потока main, есть дополнительные потоки, все верно?
                                                          </div></div></div></div>
                                                                  </div><div class="comment-layout"><div class="comment-wrap"><div class="comment"><span class="ava__wrapper"><a href="https://javarush.ru/users/2361665" target="_blank" class="ava" tabindex="-1" style="background-image: url('https://cdn.javarush.ru/images/anonymous.svg')"><span></span></a></span>
                                                              <div class="comment-head"><div class="head-left"><a href="https://javarush.ru/users/2361665" target="_blank" class="user">wan-derer.ru</a>
                                                                  <span class="more-info">39
                                                                    уровень, Москва</span>



                                                                  </div>
                                                                <div class="head-right"><span class="date">16 августа 2020</span>
                                                                  </div></div>
                                                              <div class="comment-body"><div class="view-text">Пример по<strong> join()</strong>:
                                                          <pre class="lang-java line-numbers"><code>
                                                                 //Главный поток продолжит работу только после того, как t1 и t2 завершат работу
                                                                 try {
                                                                     t1.join();
                                                                     t2.join();
                                                          </code></pre>
                                                          Но ведь <strong>t1.join();</strong> уже было раньше, значит t1 уже точно завершился. Зачем писать это второй раз?
                                                          </div></div></div></div>
                                                                  </div><div class="comment-layout"><div class="comment-wrap"><div class="comment"><span class="ava__wrapper"><a href="https://javarush.ru/users/2392258" target="_blank" class="ava" tabindex="-1" style="background-image: url('https://cdn.javarush.ru/images/avatar/2392258/64.webp')"><span></span></a></span>
                                                              <div class="comment-head"><div class="head-left"><a href="https://javarush.ru/users/2392258" target="_blank" class="user">Erik</a>
                                                                  <span class="more-info">25
                                                                    уровень, Новосибирск</span>



                                                                  </div>
                                                                <div class="head-right"><span class="date">9 августа 2020</span>
                                                                  </div></div>
                                                              <div class="comment-body"><div class="view-text">После просмотра видеоролика больше вопросов, чем ответов, во всяком случае у меня.</div></div></div></div>
                                                                  </div></div></div></div></div></article></div></div></div>
                                                                    <div class="site-layout__footer"><div class="footer-wrap"><footer class="site-footer site-footer--common"><div class="site-footer__container"><div class="site-footer__nav"><div class="site-footer__nav-section"><div class="site-footer-nav-wrap"><div class="site-footer-nav"><div class="site-footer-nav__head">Обучение</div>
                                                              <ul class="site-footer-nav__list"><li class="site-footer-nav__item"><a href="https://javarush.ru/quests" class="site-footer-nav__link">Курс Java</a>
                                                                  </li><li class="site-footer-nav__item"><a href="https://javarush.ru/quests/QUEST_HARVARD_CS50" class="site-footer-nav__link">Курс Harvard CS50</a>
                                                                  </li><li class="site-footer-nav__item"><a href="https://javarush.ru/quests/QUEST_GOOGLE_ANDROID" class="site-footer-nav__link">Курс по Android</a>
                                                                  </li><li class="site-footer-nav__item"><a href="https://javarush.ru/internship" class="site-footer-nav__link">Стажировка</a>
                                                                  </li><li class="site-footer-nav__item"><a href="https://javarush.ru/help" class="site-footer-nav__link">Помощь по задачам</a>
                                                                  </li><li class="site-footer-nav__item"><a href="https://javarush.ru/prices" class="site-footer-nav__link">Подписки</a>
                                                                  </li><li class="site-footer-nav__item"><a href="https://javarush.ru/projects/games" class="site-footer-nav__link">Задачи-игры</a>
                                                                  </li></ul></div></div></div>
                                                                  <div class="site-footer__nav-section"><div class="site-footer-nav-wrap"><div class="site-footer-nav"><div class="site-footer-nav__head">Сообщество</div>
                                                              <ul class="site-footer-nav__list"><li class="site-footer-nav__item"><a href="https://javarush.ru/users" class="site-footer-nav__link">Пользователи</a>
                                                                  </li><li class="site-footer-nav__item"><a href="https://javarush.ru/groups/posts" class="site-footer-nav__link">Статьи</a>
                                                                  </li><li class="site-footer-nav__item"><a href="https://javarush.ru/forum" class="site-footer-nav__link">Форум</a>
                                                                  </li><li class="site-footer-nav__item"><a href="https://javarush.ru/chat" class="site-footer-nav__link">Чат</a>
                                                                  </li><li class="site-footer-nav__item"><a href="https://javarush.ru/groups/stories" class="site-footer-nav__link">Истории успеха</a>
                                                                  </li><li class="site-footer-nav__item"><a href="https://javarush.ru/news" class="site-footer-nav__link">Активности</a>
                                                                  </li><li class="site-footer-nav__item"><a href="https://javarush.ru/search/post?query=конкурс от JavaRush" class="site-footer-nav__link">Конкурсы</a>
                                                                  </li></ul></div></div></div>
                                                                  <div class="site-footer__nav-section"><div class="site-footer-nav-wrap"><div class="site-footer-nav"><div class="site-footer-nav__head">О нас</div>
                                                              <ul class="site-footer-nav__list"><li class="site-footer-nav__item"><a href="https://javarush.ru/about/mission" class="site-footer-nav__link">О JavaRush</a>
                                                                  </li><li class="site-footer-nav__item"><a href="https://javarush.ru/about/contacts" class="site-footer-nav__link">Контакты</a>
                                                                  </li><li class="site-footer-nav__item"><a href="https://javarush.ru/about/reviews" class="site-footer-nav__link">Отзывы</a>
                                                                  </li><li class="site-footer-nav__item"><a href="https://javarush.ru/about/faq" class="site-footer-nav__link">FAQ</a>
                                                                  </li><li class="site-footer-nav__item"><a href="https://javarush.ru/dialogues/administration" class="site-footer-nav__link">Поддержка</a>
                                                                  </li></ul></div></div></div>
                                                                  <div class="site-footer__nav-section"><div class="site-footer-nav-wrap"><div class="site-footer-nav"><div class="site-footer-nav__head">Видео</div>
                                                              <ul class="site-footer-nav__list"><li class="site-footer-nav__item"><a href="https://javarush.ru/groups/posts/557-uroki-programmirovanija-na-java#3-top-features-javarush" class="site-footer-nav__link">Топ-3 фичи JavaRush</a>
                                                                  </li><li class="site-footer-nav__item"><a href="https://javarush.ru/groups/posts/557-uroki-programmirovanija-na-java#section-course" class="site-footer-nav__link">Раздел «Курс»</a>
                                                                  </li><li class="site-footer-nav__item"><a href="https://javarush.ru/groups/posts/557-uroki-programmirovanija-na-java#section-help" class="site-footer-nav__link">Раздел «Помощь»</a>
                                                                  </li><li class="site-footer-nav__item"><a href="https://javarush.ru/groups/posts/2052-razdel-igrih-na-javarush-chastjh-1-populjarnihe-voprosih#section-game" class="site-footer-nav__link">Раздел «Игры»</a>
                                                                  </li><li class="site-footer-nav__item"><a href="https://javarush.ru/groups/posts/557-uroki-programmirovanija-na-java#3ide" class="site-footer-nav__link">3 IDE</a>
                                                                  </li><li class="site-footer-nav__item"><a href="https://javarush.ru/groups/posts/557-uroki-programmirovanija-na-java#light_theme" class="site-footer-nav__link">Светлая тема сайта</a>
                                                                  </li></ul></div></div></div></div>

                                                                <div class="site-footer__social-and-copyright"><div class="site-footer__social"><div class="social-links"><ul class="social-links__list"><li class="social-links__item"><a class="social-links__link social-links__link--vk" href="https://vk.com/javarush" target="_blank"><svg class="icon icon--social-vk" aria-hidden="true"><use xlink:href="/sapper/assets/icons/social.svg?v=19#icon-vk"></use></svg></a></li>
                                                              <li class="social-links__item"><a class="social-links__link social-links__link--facebook" href="https://www.facebook.com/www.javarush.ru/" target="_blank"><svg class="icon icon--social-facebook" aria-hidden="true"><use xlink:href="/sapper/assets/icons/social.svg?v=19#icon-facebook"></use></svg></a></li>
                                                              <li class="social-links__item"><a class="social-links__link social-links__link--linkedin" href="https://www.linkedin.com/company/javarush/" target="_blank"><svg class="icon icon--social-linkedin" aria-hidden="true"><use xlink:href="/sapper/assets/icons/social.svg?v=19#icon-linkedin"></use></svg></a></li>
                                                              <li class="social-links__item"><a class="social-links__link social-links__link--twitter" href="https://twitter.com/javarush_ru" target="_blank"><svg class="icon icon--social-twitter" aria-hidden="true"><use xlink:href="/sapper/assets/icons/social.svg?v=19#icon-twitter"></use></svg></a></li>
                                                              <li class="social-links__item"><a class="social-links__link social-links__link--youtube" href="https://www.youtube.com/channel/UCMcDsSeqS531-HKz6GiJgtA" target="_blank"><svg class="icon icon--social-youtube" aria-hidden="true"><use xlink:href="/sapper/assets/icons/social.svg?v=19#icon-youtube"></use></svg></a></li>
                                                              <li class="social-links__item"><a class="social-links__link social-links__link--instagram" href="https://www.instagram.com/javarush_photo/" target="_blank"><svg class="icon icon--social-instagram" aria-hidden="true"><use xlink:href="/sapper/assets/icons/social.svg?v=19#icon-instagram"></use></svg></a></li>
                                                              <li class="social-links__item"><a class="social-links__link social-links__link--telegram" href="https://t.me/javarush_original" target="_blank"><svg class="icon icon--social-telegram" aria-hidden="true"><use xlink:href="/sapper/assets/icons/social.svg?v=19#icon-telegram"></use></svg></a></li></ul></div></div>
                                                                  <div class="site-footer__acceptance"><div class="footer-acceptance"><img class="footer-acceptance__item" src="/sapper/assets/images/site/payment-systems/visa.svg" alt="Visa">
                                                            <img class="footer-acceptance__item" src="/sapper/assets/images/site/payment-systems/mastercard.svg" alt="Mastercard"></div></div>
                                                                  <div class="site-footer__copyright site-footer__copyright--desktop">© 2021 JavaRush <span class="site-footer__tagline">«Программистами не рождаются»</span></div></div>

                                                                <div class="site-footer__copyright site-footer__copyright--mobile">© 2021 JavaRush <span class="site-footer__tagline">«Программистами не рождаются»</span></div></div></footer></div></div></div></div></div></div></main></div>
                         }
                     });
                 }

                 // Variables declaration - do not modify
                 private javax.swing.JButton jButton1;
                 private javax.swing.JLabel jLabel1;
                 private javax.swing.JLabel jLabel10;
                 private javax.swing.JLabel jLabel11;
                 private javax.swing.JLabel jLabel12;
                 private javax.swing.JLabel jLabel13;
                 private javax.swing.JLabel jLabel2;
                 private javax.swing.JLabel jLabel3;
                 private javax.swing.JLabel jLabel4;
                 private javax.swing.JLabel jLabel5;
                 private javax.swing.JLabel jLabel6;
                 private javax.swing.JLabel jLabel7;
                 private javax.swing.JLabel jLabel8;
                 private javax.swing.JLabel jLabel9;
                 private javax.swing.JScrollPane jScrollPane1;
                 private javax.swing.JTable jTable1;
                 private JTextField jTextField1;
                 private JTextField jTextField2;
                 private JTextField jTextField3;
                 private JTextField jTextField4;
                 private JTextField jTextField5;
                 // End of variables declaration
             }
             2.Скриншоты работы программы

             скриншот 1

             скриншот 2

             скриншот 3

             скриншот 4

             скриншот 5

             скриншот 6

             скриншот 7

             скриншот 8

             скриншот 9

             скриншот 10

             скриншот 11

Ivan Arsyonov
думаю на два бы разделили по 800 стр
НравитсяПоказать список оценивших29 мар 2020Ответитьэтом мы заканчиваем знакомство с основными методами класса Thread.div></footer></div></div></div></div></div></div></main></div>